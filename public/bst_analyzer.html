<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Binary Tree Analyzer - Origos Maximos</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e4d6b 0%, #2d5f7a 50%, #3b7391 100%);
            min-height: 100vh;
            padding: 2rem;
            color: #ffffff;
        }

        /* VÃ¡noÄnÃ­ svÄ›tÃ½lka - Christmas Lights */
        .christmas-lights {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 1000;
            overflow: hidden;
            pointer-events: none;
        }

        .wire {
            position: absolute;
            top: 8px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                #2a2a2a 0%, #3a3a3a 50%, #2a2a2a 100%);
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .lights-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 10px;
        }

        .light {
            position: relative;
            width: 12px;
            height: 20px;
            margin-top: 8px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            animation: swing 2s ease-in-out infinite;
        }

        .light::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 8px;
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            border-radius: 2px 2px 0 0;
        }

        .light::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 8px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(1px);
        }

        /* Barvy svÄ›tÃ½lek */
        .light.red {
            background: radial-gradient(ellipse at 30% 20%, #ff6b6b, #e63946);
            box-shadow: 0 0 15px 5px rgba(230, 57, 70, 0.6),
                        0 0 30px 10px rgba(230, 57, 70, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite, glow-red 1.5s ease-in-out infinite alternate;
        }

        .light.green {
            background: radial-gradient(ellipse at 30% 20%, #51cf66, #2d9e42);
            box-shadow: 0 0 15px 5px rgba(45, 158, 66, 0.6),
                        0 0 30px 10px rgba(45, 158, 66, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.3s, glow-green 1.5s ease-in-out infinite alternate 0.5s;
        }

        .light.blue {
            background: radial-gradient(ellipse at 30% 20%, #74c0fc, #339af0);
            box-shadow: 0 0 15px 5px rgba(51, 154, 240, 0.6),
                        0 0 30px 10px rgba(51, 154, 240, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.6s, glow-blue 1.5s ease-in-out infinite alternate 1s;
        }

        .light.yellow {
            background: radial-gradient(ellipse at 30% 20%, #ffe066, #fab005);
            box-shadow: 0 0 15px 5px rgba(250, 176, 5, 0.6),
                        0 0 30px 10px rgba(250, 176, 5, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.9s, glow-yellow 1.5s ease-in-out infinite alternate 1.5s;
        }

        .light.purple {
            background: radial-gradient(ellipse at 30% 20%, #da77f2, #be4bdb);
            box-shadow: 0 0 15px 5px rgba(190, 75, 219, 0.6),
                        0 0 30px 10px rgba(190, 75, 219, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 1.2s, glow-purple 1.5s ease-in-out infinite alternate 2s;
        }

        .light.orange {
            background: radial-gradient(ellipse at 30% 20%, #ffa94d, #fd7e14);
            box-shadow: 0 0 15px 5px rgba(253, 126, 20, 0.6),
                        0 0 30px 10px rgba(253, 126, 20, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.15s, glow-orange 1.5s ease-in-out infinite alternate 0.75s;
        }

        @keyframes swing {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        @keyframes glow-red {
            0% { box-shadow: 0 0 10px 3px rgba(230, 57, 70, 0.4), 0 0 20px 6px rgba(230, 57, 70, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(230, 57, 70, 0.8), 0 0 40px 15px rgba(230, 57, 70, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-green {
            0% { box-shadow: 0 0 10px 3px rgba(45, 158, 66, 0.4), 0 0 20px 6px rgba(45, 158, 66, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(45, 158, 66, 0.8), 0 0 40px 15px rgba(45, 158, 66, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-blue {
            0% { box-shadow: 0 0 10px 3px rgba(51, 154, 240, 0.4), 0 0 20px 6px rgba(51, 154, 240, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(51, 154, 240, 0.8), 0 0 40px 15px rgba(51, 154, 240, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-yellow {
            0% { box-shadow: 0 0 10px 3px rgba(250, 176, 5, 0.4), 0 0 20px 6px rgba(250, 176, 5, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(250, 176, 5, 0.8), 0 0 40px 15px rgba(250, 176, 5, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-purple {
            0% { box-shadow: 0 0 10px 3px rgba(190, 75, 219, 0.4), 0 0 20px 6px rgba(190, 75, 219, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(190, 75, 219, 0.8), 0 0 40px 15px rgba(190, 75, 219, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-orange {
            0% { box-shadow: 0 0 10px 3px rgba(253, 126, 20, 0.4), 0 0 20px 6px rgba(253, 126, 20, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(253, 126, 20, 0.8), 0 0 40px 15px rgba(253, 126, 20, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 3rem;
            background: linear-gradient(135deg, #64b5f6 0%, #2196f3 50%, #1565c0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 2rem 0 0.5rem 0;
        }

        .subtitle {
            text-align: center;
            color: #bbdefb;
            letter-spacing: 6px;
            margin-bottom: 0.5rem;
        }

        .author {
            text-align: center;
            color: #90caf9;
            font-style: italic;
            margin-bottom: 2rem;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%);
            border-color: #2196f3;
            transform: scale(1.05);
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h2 {
            color: #64b5f6;
            margin-bottom: 1rem;
            border-bottom: 2px solid rgba(100, 181, 246, 0.3);
            padding-bottom: 0.5rem;
        }

        .input-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        input, textarea {
            flex: 1;
            min-width: 200px;
            padding: 0.8rem;
            border-radius: 8px;
            border: 2px solid rgba(100, 181, 246, 0.3);
            background: rgba(255, 255, 255, 0.95);
            font-size: 1rem;
            color: #1e4d6b;
        }

        textarea {
            font-family: 'Courier New', monospace;
            min-height: 200px;
            resize: vertical;
        }

        button {
            padding: 0.8rem 2rem;
            background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .btn-remove {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }

        .tree-viz {
            background: white;
            color: #1e4d6b;
            padding: 2rem;
            border-radius: 10px;
            overflow-x: auto;
            min-height: 200px;
        }

        .node-visual {
            display: inline-block;
            padding: 0.8rem 1.2rem;
            margin: 0.3rem;
            border-radius: 50%;
            background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%);
            color: white;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
            cursor: pointer;
            min-width: 50px;
            text-align: center;
        }

        .node-visual:hover {
            transform: scale(1.15);
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.5);
        }

        .node-visual.highlight {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            animation: pulse 1s infinite;
        }

        .node-visual.found {
            background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%);
            transform: scale(1.2);
        }

        .node-visual.path {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        .tree-level {
            text-align: center;
            margin: 1.5rem 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .level-label {
            display: block;
            color: #64b5f6;
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .search-result {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.2) 0%, rgba(46, 125, 50, 0.2) 100%);
            border-left: 4px solid #4caf50;
        }

        .path-info {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            background: rgba(156, 39, 176, 0.2);
            border-radius: 5px;
            margin: 0.2rem;
            font-family: 'Courier New', monospace;
        }

        canvas {
            border-radius: 10px;
            background: white;
            max-width: 100%;
        }

        .viz-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .viz-mode {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .viz-mode.active {
            background: linear-gradient(135deg, #2196f3 0%, #1565c0 100%);
            border-color: #2196f3;
        }

        .result-box {
            background: rgba(33, 150, 243, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin: 0.5rem 0;
            border-left: 4px solid #2196f3;
        }

        .result-label {
            color: #64b5f6;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .scrollable-panel {
            max-height: 320px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.25);
            padding: 1rem;
            border-radius: 10px;
            margin-top: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.15) 0%, rgba(21, 101, 192, 0.15) 100%);
            padding: 1.5rem;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #64b5f6;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #bbdefb;
        }

        code {
            background: rgba(33, 150, 243, 0.2);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- VÃ¡noÄnÃ­ svÄ›tÃ½lka -->
    <div class="christmas-lights">
        <div class="wire"></div>
        <div class="lights-container" id="lightsContainer"></div>
    </div>
    
    <div class="container">
        <h1>ğŸ„ Universal Binary Tree Analyzer ğŸ„</h1>
        <div class="subtitle">âœ¨ ORIGOS MAXIMOS âœ¨</div>
        <div class="author">Designed by Jan Dub</div>

        <!-- MODE SELECTOR -->
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="bst" onclick="switchMode(event, 'bst')">
                ğŸ”¢ Binary Search Tree (BST)
            </button>
            <button class="mode-btn" data-mode="binary" onclick="switchMode(event, 'binary')">
                ğŸ“Š Binary Tree (Level-Order)
            </button>
        </div>

        <div class="card" id="treeTheoryCard">
            <h2>ğŸ“˜ TeoretickÃ½ pÅ™ehled pojmÅ¯</h2>
            <p style="color: #bbdefb;">
                PotÅ™ebujete si rychle pÅ™ipomenout rozdÃ­ly mezi jednotlivÃ½mi typy stromÅ¯ a prÅ¯chody?
                Tady je struÄnÃ½ slovnÃ­k pouÅ¾Ã­vanÃ½ napÅ™Ã­Ä aplikacÃ­.
            </p>
            <ul style="line-height: 1.8; padding-left: 1.25rem; color: #e3f2fd;">
                <li><strong>Strom:</strong> SouvislÃ½ acyklickÃ½ graf â€“ mezi libovolnÃ½mi dvÄ›ma uzly vede prÃ¡vÄ› jedna cesta.</li>
                <li><strong>BinÃ¡rnÃ­ strom:</strong> KaÅ¾dÃ½ uzel mÅ¯Å¾e mÃ­t nanejvÃ½Å¡ dva potomky (levÃ½ a pravÃ½). V reÅ¾imu â€Binary Treeâ€œ zapisujeme strom po vrstvÃ¡ch.</li>
                <li><strong>BinÃ¡rnÃ­ vyhledÃ¡vacÃ­ strom (BST):</strong> BinÃ¡rnÃ­ strom s podmÃ­nkou, Å¾e levÃ½ podstrom obsahuje menÅ¡Ã­ hodnoty a pravÃ½ podstrom vÄ›tÅ¡Ã­ â€“ dÃ­ky tomu lze rychle hledat.</li>
                <li><strong>Level-order:</strong> PrÅ¯chod po ÃºrovnÃ­ch (BFS) â€“ hodÃ­ se pro vizualizaci a prÃ¡ci s ÃºplnÃ½mi stromy.</li>
                <li><strong>Pre-order:</strong> Nejprve uzel, pak levÃ½ a pravÃ½ podstrom (DFS). VhodnÃ© pro serializaci stromu.</li>
                <li><strong>In-order:</strong> LevÃ½ podstrom â†’ uzel â†’ pravÃ½ podstrom. U BST vracÃ­ prvky seÅ™azenÃ©.</li>
                <li><strong>Post-order:</strong> LevÃ½, pravÃ½, teprve potÃ© uzel. PouÅ¾Ã­vÃ¡ se napÅ™. pro mazÃ¡nÃ­ stromu nebo generovÃ¡nÃ­ postfixovÃ½ch vÃ½razÅ¯.</li>
                <li><strong>ProhledÃ¡vÃ¡nÃ­ do hloubky (DFS):</strong> ZÃ¡kladnÃ­ rodina prÅ¯chodÅ¯ (pre/in/post-order), kterÃ© vÅ¾dy jdou co nejdÃ¡l do jednÃ© vÄ›tve.</li>
                <li><strong>ProhledÃ¡vÃ¡nÃ­ do Å¡Ã­Å™ky (BFS):</strong> StejnÃ½ princip jako level-order â€“ vrstvu po vrstvÄ›, ideÃ¡lnÃ­ pro mÄ›Å™enÃ­ vzdÃ¡lenosti od koÅ™ene.</li>
            </ul>
        </div>

        <!-- BST MODE -->
        <div id="bstMode">
            <div class="card">
                <h2>â• Operace nad BST</h2>
                
                <div class="input-group">
                    <input type="text" id="insertValues" placeholder="Hodnoty k vloÅ¾enÃ­ (napÅ™: 50, 25, 41, 77)">
                    <button onclick="insertValues()">VloÅ¾it hodnoty</button>
                </div>

                <div class="input-group">
                    <input type="text" id="removeValues" placeholder="Hodnoty k odebrÃ¡nÃ­ (napÅ™: 53, 12, 77)">
                    <button class="btn-remove" onclick="removeValues()">Odebrat hodnoty</button>
                </div>

                <div class="input-group">
                    <input type="number" id="searchValue" placeholder="HledanÃ¡ hodnota">
                    <button onclick="searchValue()">ğŸ” Vyhledat</button>
                    <button onclick="findPath()">ğŸ—ºï¸ NajÃ­t cestu</button>
                </div>

                <div class="input-group">
                    <input type="number" id="rangeMin" placeholder="Min rozsah">
                    <input type="number" id="rangeMax" placeholder="Max rozsah">
                    <button onclick="findInRange()">ğŸ“Š Hledat v rozsahu</button>
                </div>

                <div class="input-group">
                    <input type="number" id="dfsStartValue" placeholder="PoÄÃ¡teÄnÃ­ uzel pro DFS/BFS">
                    <button onclick="runDfsFromValue()">ğŸ” DFS od uzlu</button>
                    <button onclick="runBfsFromValue()">ğŸ”„ BFS od uzlu</button>
                </div>

                <button onclick="showAllMethods()" style="width: 100%; margin-top: 1rem;">ğŸ“Š Analyzovat BST</button>
            </div>
        </div>

        <!-- BINARY TREE MODE -->
        <div id="binaryMode" class="hidden">
            <div class="card">
                <h2>ğŸ“ Vstup Binary Tree (Level-Order)</h2>
                <p style="margin-bottom: 1rem; color: #bbdefb;">
                    FormÃ¡t: <code>u identifikÃ¡tor;</code> pro uzly, <code>u *;</code> pro prÃ¡zdnÃ© uzly.
                </p>
                
                <textarea id="binaryInput" placeholder="u A;
u B;
u C;
...">u A;
u B;
u C;
u D;
u E;
u F;
u G;
u H;
u *;
u *;
u *;
u *;
u I;
u *;
u *;</textarea>

                <div class="input-group" style="margin-top: 1rem;">
                    <input type="text" id="searchBinaryValue" placeholder="Hledat identifikÃ¡tor (napÅ™: A, B, C)">
                    <button onclick="searchBinaryNode()">ğŸ” Vyhledat uzel</button>
                </div>

                <div class="input-group" style="margin-top: 1rem;">
                    <input type="text" id="dfsStartBinaryValue" placeholder="PoÄÃ¡teÄnÃ­ uzel pro DFS/BFS (napÅ™: A, B)">
                    <button onclick="runBinaryDfsFromValue()">ğŸ” DFS od uzlu</button>
                    <button onclick="runBinaryBfsFromValue()">ğŸ”„ BFS od uzlu</button>
                </div>

                <button onclick="analyzeBinaryTree()" style="width: 100%; margin-top: 1rem;">ğŸ“Š Analyzovat Binary Tree</button>
            </div>
        </div>

        <!-- RESULTS -->
        <div id="statsCard" class="card hidden">
            <h2>ğŸ“Š Statistiky stromu</h2>
            <div class="stats-grid" id="statsGrid"></div>
        </div>

        <div id="vizCard" class="card hidden">
            <h2>ğŸŒ² Vizualizace stromu</h2>
            <div class="viz-controls">
                <button class="viz-mode active" data-viz="text" onclick="changeVizMode(event, 'text')">ğŸ“ Text</button>
                <button class="viz-mode" data-viz="levels" onclick="changeVizMode(event, 'levels')">ğŸ“Š ÃšrovnÄ›</button>
                <button class="viz-mode" data-viz="canvas" onclick="changeVizMode(event, 'canvas')">ğŸ¨ Canvas</button>
            </div>
            <div id="treeViz" class="tree-viz"></div>
        </div>

        <div id="traversalsCard" class="card hidden">
            <h2>ğŸš¶ PrÅ¯chody stromem</h2>
            <div id="traversals"></div>
        </div>

        <div id="propertiesCard" class="card hidden">
            <h2>ğŸ” Vlastnosti stromu</h2>
            <div id="properties"></div>
        </div>

        <div id="methodsCard" class="card hidden">
            <h2>âš™ï¸ VÅ¡echny dostupnÃ© metody</h2>
            <div id="methods"></div>
        </div>

        <div id="advancedStatsCard" class="card hidden">
            <h2>ğŸ“ˆ PokroÄilÃ¡ statistika</h2>
            <div id="advancedStats"></div>
        </div>

        <div id="searchResultCard" class="card hidden">
            <h2>ğŸ” VÃ½sledek vyhledÃ¡vÃ¡nÃ­</h2>
            <div id="searchResult"></div>
        </div>

        <div id="nodeTableCard" class="card hidden">
            <h2>ğŸ—‚ï¸ Seznam uzlÅ¯ & vazeb</h2>
            <div id="nodeTable"></div>
        </div>

        <div id="pathInsightsCard" class="card hidden">
            <h2>ğŸ§­ StromovÃ© cesty & metriky</h2>
            <div id="pathInsights"></div>
        </div>

        <div id="cpmCard" class="card hidden">
            <h2>ğŸ•’ SÃ­Å¥ovÃ½ graf & CPM pro stromy</h2>
            <p style="color: #bbdefb;">
                Strom je orientovanÃ½ acyklickÃ½ graf â€“ proto mÅ¯Å¾eme jeho hrany chÃ¡pat jako Äinnosti v sÃ­ti (zdroj = koÅ™en, cÃ­le = listy)
                a spoÄÃ­tat kritickou cestu pomocÃ­ metody CPM.
            </p>
            
            <!-- Legenda CPM pojmÅ¯ -->
            <div style="background: rgba(33, 150, 243, 0.15); border-left: 4px solid #2196f3; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                <strong style="color: #64b5f6;">ğŸ“– Co je CPM (Critical Path Method)?</strong>
                <div style="margin-top: 0.5rem; line-height: 1.8; font-size: 0.95rem;">
                    <strong>CPM</strong> = Metoda kritickÃ© cesty â€“ technika pro plÃ¡novÃ¡nÃ­ projektÅ¯, kterÃ¡ identifikuje nejdelÅ¡Ã­ cestu ÃºkolÅ¯.<br>
                    <strong>ES (Early Start)</strong> = NejdÅ™Ã­ve moÅ¾nÃ½ zaÄÃ¡tek â€“ kdy mÅ¯Å¾e Äinnost nejdÅ™Ã­ve zaÄÃ­t.<br>
                    <strong>EF (Early Finish)</strong> = NejdÅ™Ã­ve moÅ¾nÃ½ konec â€“ ES + dÃ©lka Äinnosti.<br>
                    <strong>LS (Late Start)</strong> = NejpozdÄ›ji pÅ™Ã­pustnÃ½ zaÄÃ¡tek â€“ kdy musÃ­ Äinnost nejpozdÄ›ji zaÄÃ­t.<br>
                    <strong>LF (Late Finish)</strong> = NejpozdÄ›ji pÅ™Ã­pustnÃ½ konec â€“ deadline Äinnosti.<br>
                    <strong>Rezerva (Slack/Float)</strong> = LS âˆ’ ES = o kolik lze Äinnost zpozdit bez ohroÅ¾enÃ­ projektu.<br>
                    <strong>KritickÃ¡ cesta</strong> = Cesta s nulovou rezervou â€“ jakÃ©koli zpoÅ¾dÄ›nÃ­ prodlouÅ¾Ã­ celÃ½ projekt.<br>
                    <strong>ğŸ”¥</strong> = KritickÃ¡ Äinnost (rezerva = 0) â€“ musÃ­ bÃ½t dokonÄena vÄas!
                </div>
            </div>
            
            <div class="input-group">
                <input type="number" id="defaultEdgeDuration" value="1" min="0" step="0.1"
                       placeholder="VÃ½chozÃ­ dÃ©lka hrany (napÅ™. 1)">
                <input type="text" id="customDurations"
                       placeholder="VolitelnÃ© dÃ©lky: A=3, B=2, C=1.5">
                <button onclick="runTreeCpm()">Analyzovat CPM / sÃ­Å¥</button>
            </div>
            <p style="color: #bbdefb; font-size: 0.9rem; margin-bottom: 1rem;">
                Pokud uzly obsahujÃ­ ÄÃ­sla, jejich absolutnÃ­ hodnota se pouÅ¾ije jako dÃ©lka Äinnosti (jinak vÃ½chozÃ­ hodnota).
                Do pole s vlastnÃ­mi dÃ©lkami zadejte dvojice ve tvaru <code>Uzel=ÄŒÃ­slo</code>, oddÄ›lenÃ© ÄÃ¡rkou nebo stÅ™ednÃ­kem.
            </p>
            <div id="cpmResult"></div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CURRENT MODE & VISUALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let currentMode = 'bst';
        let currentVizMode = 'text';
        let highlightedNodes = new Set();
        let searchPath = [];

        function switchMode(evt, mode) {
            currentMode = mode;
            
            // Update buttons
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            const targetButton = evt?.currentTarget ?? evt?.target ?? document.querySelector(`.mode-btn[data-mode="${mode}"]`);
            targetButton?.classList.add('active');
            
            // Show/hide sections
            document.getElementById('bstMode').classList.toggle('hidden', mode !== 'bst');
            document.getElementById('binaryMode').classList.toggle('hidden', mode !== 'binary');
            
            // Hide results
            hideResults();
        }

        function changeVizMode(evt, mode) {
            currentVizMode = mode;
            
            // Update buttons
            document.querySelectorAll('.viz-mode').forEach(btn => btn.classList.remove('active'));
            const targetButton = evt?.currentTarget ?? evt?.target ?? document.querySelector(`.viz-mode[data-viz="${mode}"]`);
            targetButton?.classList.add('active');
            
            // Refresh visualization
            if (currentMode === 'bst') {
                visualizeBST();
            } else if (binaryTree) {
                visualizeBinaryTree();
            }
        }

        function hideResults() {
            document.getElementById('statsCard').classList.add('hidden');
            document.getElementById('vizCard').classList.add('hidden');
            document.getElementById('traversalsCard').classList.add('hidden');
            document.getElementById('propertiesCard').classList.add('hidden');
            document.getElementById('methodsCard').classList.add('hidden');
            document.getElementById('advancedStatsCard').classList.add('hidden');
            document.getElementById('searchResultCard').classList.add('hidden');
            document.getElementById('nodeTableCard').classList.add('hidden');
            document.getElementById('pathInsightsCard').classList.add('hidden');
            document.getElementById('nodeTable').innerHTML = '';
            document.getElementById('pathInsights').innerHTML = '';
            document.getElementById('cpmCard').classList.add('hidden');
            document.getElementById('cpmResult').innerHTML = '';
            highlightedNodes.clear();
            searchPath = [];
        }

        function showResults() {
            document.getElementById('statsCard').classList.remove('hidden');
            document.getElementById('vizCard').classList.remove('hidden');
            document.getElementById('traversalsCard').classList.remove('hidden');
            document.getElementById('cpmCard').classList.remove('hidden');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BST NODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        class BSTNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BINARY SEARCH TREE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        class BST {
            constructor() {
                this.root = null;
                this._nodeCount = 0;
            }

            insert(value) {
                const newNode = new BSTNode(value);
                
                if (this.root === null) {
                    this.root = newNode;
                    this._nodeCount++;
                    return true;
                }

                let current = this.root;
                while (true) {
                    if (value === current.value) return false;
                    
                    if (value < current.value) {
                        if (current.left === null) {
                            current.left = newNode;
                            this._nodeCount++;
                            return true;
                        }
                        current = current.left;
                    } else {
                        if (current.right === null) {
                            current.right = newNode;
                            this._nodeCount++;
                            return true;
                        }
                        current = current.right;
                    }
                }
            }

            remove(value) {
                this.root = this._removeNode(this.root, value);
            }

            _removeNode(node, value) {
                if (node === null) return null;

                if (value < node.value) {
                    node.left = this._removeNode(node.left, value);
                    return node;
                } else if (value > node.value) {
                    node.right = this._removeNode(node.right, value);
                    return node;
                } else {
                    this._nodeCount--;

                    if (node.left === null && node.right === null) {
                        return null;
                    }

                    if (node.left === null) return node.right;
                    if (node.right === null) return node.left;

                    let minRight = this._findMin(node.right);
                    node.value = minRight.value;
                    node.right = this._removeNode(node.right, minRight.value);
                    this._nodeCount++;
                    return node;
                }
            }

            _findMin(node) {
                while (node.left !== null) {
                    node = node.left;
                }
                return node;
            }

            search(value) {
                let current = this.root;
                
                while (current !== null) {
                    if (value === current.value) return true;
                    if (value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }
                
                return false;
            }

            levelOrder() {
                if (this.root === null) return [];

                const result = [];
                const queue = [this.root];

                while (queue.length > 0) {
                    const node = queue.shift();
                    result.push(node.value);

                    if (node.left !== null) queue.push(node.left);
                    if (node.right !== null) queue.push(node.right);
                }

                return result;
            }

            preOrder() {
                const result = [];
                const stack = [];
                
                if (this.root !== null) {
                    stack.push(this.root);
                }

                while (stack.length > 0) {
                    const node = stack.pop();
                    result.push(node.value);

                    if (node.right !== null) stack.push(node.right);
                    if (node.left !== null) stack.push(node.left);
                }

                return result;
            }

            inOrder() {
                const result = [];
                const stack = [];
                let current = this.root;

                while (stack.length > 0 || current !== null) {
                    while (current !== null) {
                        stack.push(current);
                        current = current.left;
                    }

                    current = stack.pop();
                    result.push(current.value);
                    current = current.right;
                }

                return result;
            }

            postOrder() {
                const result = [];
                const stack = [];
                const visited = new Set();

                if (this.root !== null) {
                    stack.push(this.root);
                }

                while (stack.length > 0) {
                    const node = stack[stack.length - 1];

                    const leftDone = node.left === null || visited.has(node.left);
                    const rightDone = node.right === null || visited.has(node.right);

                    if (leftDone && rightDone) {
                        result.push(node.value);
                        visited.add(node);
                        stack.pop();
                    } else {
                        if (!rightDone) stack.push(node.right);
                        if (!leftDone) stack.push(node.left);
                    }
                }

                return result;
            }

            findMin() {
                if (this.root === null) return null;
                
                let current = this.root;
                while (current.left !== null) {
                    current = current.left;
                }
                return current.value;
            }

            findMax() {
                if (this.root === null) return null;
                
                let current = this.root;
                while (current.right !== null) {
                    current = current.right;
                }
                return current.value;
            }

            height() {
                return this._heightNode(this.root);
            }

            _heightNode(node) {
                if (node === null) return 0;
                
                let maxHeight = 0;
                const stack = [{ node, height: 1 }];

                while (stack.length > 0) {
                    const { node: current, height: h } = stack.pop();
                    maxHeight = Math.max(maxHeight, h);

                    if (current.right !== null) {
                        stack.push({ node: current.right, height: h + 1 });
                    }
                    if (current.left !== null) {
                        stack.push({ node: current.left, height: h + 1 });
                    }
                }

                return maxHeight;
            }

            count() {
                return this._nodeCount;
            }

            visualize() {
                if (this.root === null) return "PrÃ¡zdnÃ½ strom";

                let result = "";
                this._visualizeNode(this.root, "", true, (line) => { result += line + "\n"; });
                return result;
            }

            _visualizeNode(node, prefix, isTail, output) {
                if (node === null) return;

                output(prefix + (isTail ? "â””â”€â”€ " : "â”œâ”€â”€ ") + node.value);

                const children = [];
                if (node.left !== null) children.push({ node: node.left, isRight: false });
                if (node.right !== null) children.push({ node: node.right, isRight: true });

                children.forEach((child, index) => {
                    const isLast = index === children.length - 1;
                    const newPrefix = prefix + (isTail ? "    " : "â”‚   ");
                    this._visualizeNode(child.node, newPrefix, isLast, output);
                });
            }

            isValidBST() {
                return this._isValidNode(this.root, -Infinity, Infinity);
            }

            _isValidNode(node, min, max) {
                if (node === null) return true;
                
                if (node.value <= min || node.value >= max) {
                    return false;
                }

                return this._isValidNode(node.left, min, node.value) &&
                       this._isValidNode(node.right, node.value, max);
            }

            // NEW ADVANCED METHODS
            findPath(value) {
                const path = [];
                let current = this.root;
                
                while (current !== null) {
                    path.push(current.value);
                    
                    if (value === current.value) {
                        return { found: true, path, depth: path.length - 1 };
                    }
                    
                    if (value < current.value) {
                        current = current.left;
                    } else {
                        current = current.right;
                    }
                }
                
                return { found: false, path, depth: -1 };
            }

            findInRange(min, max) {
                const result = [];
                const stack = [];
                
                if (this.root !== null) {
                    stack.push(this.root);
                }

                while (stack.length > 0) {
                    const node = stack.pop();
                    
                    if (node.value >= min && node.value <= max) {
                        result.push(node.value);
                    }
                    
                    if (node.right !== null && node.value < max) {
                        stack.push(node.right);
                    }
                    
                    if (node.left !== null && node.value > min) {
                        stack.push(node.left);
                    }
                }
                
                return result.sort((a, b) => a - b);
            }

            getBalance() {
                return this._getBalanceNode(this.root);
            }

            _getBalanceNode(node) {
                const traverse = (current) => {
                    if (current === null) {
                        return {
                            balanced: true,
                            height: 0,
                            leftHeight: 0,
                            rightHeight: 0,
                            balanceFactor: 0,
                            maxDiff: 0
                        };
                    }

                    const left = traverse(current.left);
                    const right = traverse(current.right);
                    const balanceFactor = left.height - right.height;
                    const diff = Math.abs(balanceFactor);
                    const balanced = left.balanced && right.balanced && diff <= 1;

                    return {
                        balanced,
                        height: Math.max(left.height, right.height) + 1,
                        leftHeight: left.height,
                        rightHeight: right.height,
                        balanceFactor,
                        maxDiff: Math.max(diff, left.maxDiff, right.maxDiff)
                    };
                };

                const summary = traverse(node);
                return {
                    balanced: summary.balanced,
                    leftHeight: summary.leftHeight,
                    rightHeight: summary.rightHeight,
                    balanceFactor: summary.balanceFactor,
                    maxDiff: summary.maxDiff,
                    height: summary.height
                };
            }

            getDepth(value) {
                let depth = 0;
                let current = this.root;
                
                while (current !== null) {
                    if (value === current.value) return depth;
                    depth++;
                    current = value < current.value ? current.left : current.right;
                }
                
                return -1;
            }

            getLevelNodes(level) {
                if (this.root === null || level < 0) return [];
                
                const result = [];
                const queue = [{node: this.root, level: 0}];
                
                while (queue.length > 0) {
                    const {node, level: currentLevel} = queue.shift();
                    
                    if (currentLevel === level) {
                        result.push(node.value);
                    } else if (currentLevel < level) {
                        if (node.left !== null) queue.push({node: node.left, level: currentLevel + 1});
                        if (node.right !== null) queue.push({node: node.right, level: currentLevel + 1});
                    }
                }
                
                return result;
            }

            // DFS (Pre-Order) od konkrÃ©tnÃ­ho uzlu
            dfsFrom(startValue) {
                const startNode = this._findNode(startValue);
                if (!startNode) return { found: false, result: [] };

                const result = [];
                const stack = [startNode];

                while (stack.length > 0) {
                    const node = stack.pop();
                    result.push(node.value);

                    if (node.right !== null) stack.push(node.right);
                    if (node.left !== null) stack.push(node.left);
                }

                return { found: true, result };
            }

            // BFS (Level-Order) od konkrÃ©tnÃ­ho uzlu
            bfsFrom(startValue) {
                const startNode = this._findNode(startValue);
                if (!startNode) return { found: false, result: [] };

                const result = [];
                const queue = [startNode];

                while (queue.length > 0) {
                    const node = queue.shift();
                    result.push(node.value);

                    if (node.left !== null) queue.push(node.left);
                    if (node.right !== null) queue.push(node.right);
                }

                return { found: true, result };
            }

            // PomocnÃ¡ metoda pro nalezenÃ­ uzlu podle hodnoty
            _findNode(value) {
                let current = this.root;
                while (current !== null) {
                    if (value === current.value) return current;
                    current = value < current.value ? current.left : current.right;
                }
                return null;
            }

            getAdvancedStats() {
                if (this.root === null) return null;
                
                const inOrderVals = this.inOrder();
                const levelOrderVals = this.levelOrder();
                
                let sum = 0;
                let leafCount = 0;
                let internalCount = 0;
                
                const stack = [this.root];
                const visited = new Set();
                
                while (stack.length > 0) {
                    const node = stack.pop();
                    if (visited.has(node)) continue;
                    visited.add(node);
                    
                    sum += node.value;
                    
                    const isLeaf = node.left === null && node.right === null;
                    if (isLeaf) leafCount++;
                    else internalCount++;
                    
                    if (node.right !== null) stack.push(node.right);
                    if (node.left !== null) stack.push(node.left);
                }
                
                const avg = sum / this.count();
                const median = inOrderVals[Math.floor(inOrderVals.length / 2)];
                
                const balance = this.getBalance();
                
                return {
                    sum,
                    average: avg.toFixed(2),
                    median,
                    leafCount,
                    internalCount,
                    balance
                };
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BINARY TREE (Level-Order representation)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        class BinaryTree {
            constructor() {
                this.nodes = [];
                this.totalNodes = 0;
                this.filledNodes = 0;
                this.emptyNodes = 0;
            }

            parse(text) {
                this.nodes = [];
                this.totalNodes = 0;
                this.filledNodes = 0;
                this.emptyNodes = 0;

                const lines = text.split(/\r?\n/);
                const nodePattern = /^u\s+([^\s;]+)\s*;/i;

                for (const line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed) continue;

                    const match = nodePattern.exec(trimmed);
                    if (match) {
                        const identifier = match[1];
                        this.nodes.push(identifier);
                        this.totalNodes++;

                        if (identifier === '*') {
                            this.emptyNodes++;
                        } else {
                            this.filledNodes++;
                        }
                    }
                }

                if (this.nodes.length === 0) {
                    throw new Error('Nebyl nalezen Å¾Ã¡dnÃ½ platnÃ½ uzel!');
                }
            }

            getHeight() {
                if (this.nodes.length === 0) return 0;
                
                let lastFilledIndex = -1;
                for (let i = this.nodes.length - 1; i >= 0; i--) {
                    if (this.nodes[i] !== '*') {
                        lastFilledIndex = i;
                        break;
                    }
                }

                if (lastFilledIndex === -1) return 0;
                
                return Math.floor(Math.log2(lastFilledIndex + 1)) + 1;
            }

            levelOrder() {
                const result = [];
                for (let i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i] !== '*') {
                        result.push(this.nodes[i]);
                    }
                }
                return result;
            }

            preOrder() {
                if (this.nodes.length === 0 || this.nodes[0] === '*') {
                    return [];
                }

                const result = [];
                const stack = [0];

                while (stack.length > 0) {
                    const index = stack.pop();
                    
                    if (index >= this.nodes.length || this.nodes[index] === '*') {
                        continue;
                    }

                    result.push(this.nodes[index]);

                    const right = 2 * index + 2;
                    if (right < this.nodes.length) {
                        stack.push(right);
                    }

                    const left = 2 * index + 1;
                    if (left < this.nodes.length) {
                        stack.push(left);
                    }
                }

                return result;
            }

            inOrder() {
                if (this.nodes.length === 0 || this.nodes[0] === '*') {
                    return [];
                }

                const result = [];
                const stack = [];
                let current = 0;

                while (stack.length > 0 || current !== null) {
                    while (current !== null && current < this.nodes.length) {
                        if (this.nodes[current] === '*') {
                            break;
                        }
                        stack.push(current);
                        current = 2 * current + 1;
                    }

                    if (stack.length === 0) break;

                    current = stack.pop();
                    result.push(this.nodes[current]);

                    current = 2 * current + 2;
                }

                return result;
            }

            postOrder() {
                if (this.nodes.length === 0 || this.nodes[0] === '*') {
                    return [];
                }

                const result = [];
                const stack = [0];
                const visited = new Set();

                while (stack.length > 0) {
                    const index = stack[stack.length - 1];

                    if (index >= this.nodes.length || this.nodes[index] === '*') {
                        stack.pop();
                        continue;
                    }

                    const left = 2 * index + 1;
                    const right = 2 * index + 2;

                    const leftProcessed = left >= this.nodes.length || 
                                         this.nodes[left] === '*' || visited.has(left);
                    const rightProcessed = right >= this.nodes.length || 
                                          this.nodes[right] === '*' || visited.has(right);

                    if (leftProcessed && rightProcessed) {
                        result.push(this.nodes[index]);
                        visited.add(index);
                        stack.pop();
                    } else {
                        if (!rightProcessed) {
                            stack.push(right);
                        }
                        if (!leftProcessed) {
                            stack.push(left);
                        }
                    }
                }

                return result;
            }

            isComplete() {
                let foundEmpty = false;
                
                for (let i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i] === '*') {
                        foundEmpty = true;
                    } else if (foundEmpty) {
                        return false;
                    }
                }
                
                return true;
            }

            isFull() {
                for (let i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i] === '*') continue;
                    
                    const left = 2 * i + 1;
                    const right = 2 * i + 2;

                    const leftExists = left < this.nodes.length && this.nodes[left] !== '*';
                    const rightExists = right < this.nodes.length && this.nodes[right] !== '*';

                    if (leftExists !== rightExists) {
                        return false;
                    }
                }
                
                return true;
            }

            isPerfect() {
                if (!this.isFull()) return false;
                
                const height = this.getHeight();
                const expectedNodes = Math.pow(2, height) - 1;
                
                return this.filledNodes === expectedNodes;
            }

            visualize() {
                if (this.nodes.length === 0) return "PrÃ¡zdnÃ½ strom";

                let result = "";
                const height = this.getHeight();
                
                for (let level = 0; level < height; level++) {
                    result += `ÃšroveÅˆ ${level}: `;
                    const startIndex = Math.pow(2, level) - 1;
                    const endIndex = Math.pow(2, level + 1) - 1;
                    
                    const levelNodes = [];
                    for (let i = startIndex; i < endIndex && i < this.nodes.length; i++) {
                        levelNodes.push(`[${i}]:${this.nodes[i]}`);
                    }
                    
                    result += levelNodes.join(' ') + '\n';
                }

                return result;
            }

            // NEW BINARY TREE METHODS
            findNode(identifier) {
                for (let i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i] === identifier) {
                        return {
                            found: true,
                            index: i,
                            level: Math.floor(Math.log2(i + 1)),
                            leftChild: 2 * i + 1,
                            rightChild: 2 * i + 2,
                            parent: i > 0 ? Math.floor((i - 1) / 2) : null
                        };
                    }
                }
                return { found: false };
            }

            getNodesByLevel(level) {
                const startIndex = Math.pow(2, level) - 1;
                const endIndex = Math.pow(2, level + 1) - 1;
                const result = [];
                
                for (let i = startIndex; i < endIndex && i < this.nodes.length; i++) {
                    if (this.nodes[i] !== '*') {
                        result.push({ index: i, value: this.nodes[i] });
                    }
                }
                
                return result;
            }

            // DFS (Pre-Order) od konkrÃ©tnÃ­ho uzlu
            dfsFrom(startIdentifier) {
                const nodeInfo = this.findNode(startIdentifier);
                if (!nodeInfo.found) return { found: false, result: [] };

                const result = [];
                const stack = [nodeInfo.index];

                while (stack.length > 0) {
                    const index = stack.pop();
                    
                    if (index >= this.nodes.length || this.nodes[index] === '*') {
                        continue;
                    }

                    result.push(this.nodes[index]);

                    const right = 2 * index + 2;
                    if (right < this.nodes.length) {
                        stack.push(right);
                    }

                    const left = 2 * index + 1;
                    if (left < this.nodes.length) {
                        stack.push(left);
                    }
                }

                return { found: true, result };
            }

            // BFS (Level-Order) od konkrÃ©tnÃ­ho uzlu
            bfsFrom(startIdentifier) {
                const nodeInfo = this.findNode(startIdentifier);
                if (!nodeInfo.found) return { found: false, result: [] };

                const result = [];
                const queue = [nodeInfo.index];

                while (queue.length > 0) {
                    const index = queue.shift();
                    
                    if (index >= this.nodes.length || this.nodes[index] === '*') {
                        continue;
                    }

                    result.push(this.nodes[index]);

                    const left = 2 * index + 1;
                    if (left < this.nodes.length && this.nodes[left] !== '*') {
                        queue.push(left);
                    }

                    const right = 2 * index + 2;
                    if (right < this.nodes.length && this.nodes[right] !== '*') {
                        queue.push(right);
                    }
                }

                return { found: true, result };
            }

            getAdvancedStats() {
                const height = this.getHeight();
                let maxWidth = 0;
                
                for (let level = 0; level < height; level++) {
                    const levelNodes = this.getNodesByLevel(level);
                    maxWidth = Math.max(maxWidth, levelNodes.length);
                }
                
                const uniqueValues = new Set(this.nodes.filter(n => n !== '*'));
                
                return {
                    maxWidth,
                    uniqueValues: uniqueValues.size,
                    density: (this.filledNodes / this.totalNodes * 100).toFixed(1)
                };
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLOBAL INSTANCES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const bst = new BST();
        let binaryTree = null;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BST UI FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function insertValues() {
            const input = document.getElementById('insertValues').value;
            const values = input.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
            
            values.forEach(v => bst.insert(v));
            
            document.getElementById('insertValues').value = '';
            updateBSTDisplay();
        }

        function removeValues() {
            const input = document.getElementById('removeValues').value;
            const values = input.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
            
            values.forEach(v => bst.remove(v));
            
            document.getElementById('removeValues').value = '';
            updateBSTDisplay();
        }

        function searchValue() {
            const value = parseFloat(document.getElementById('searchValue').value);
            
            if (isNaN(value)) {
                alert('Zadejte platnÃ© ÄÃ­slo!');
                return;
            }

            const pathResult = bst.findPath(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            let resultHtml = '';
            if (pathResult.found) {
                searchPath = pathResult.path;
                highlightedNodes = new Set([value]);
                
                resultHtml = `
                    <div class="result-box search-result">
                        <div class="result-label">âœ… Hodnota ${value} NALEZENA!</div>
                        <div style="margin-top: 1rem;">
                            <strong>Hloubka v stromu:</strong> ${pathResult.depth}<br>
                            <strong>PoÄet krokÅ¯:</strong> ${pathResult.path.length}<br>
                            <strong>Cesta k hodnotÄ›:</strong><br>
                            <div style="margin-top: 0.5rem;">
                                ${pathResult.path.map((v, i) => 
                                    `<span class="path-info">${i === 0 ? 'ğŸŒ³' : i === pathResult.path.length - 1 ? 'ğŸ¯' : 'â¡ï¸'} ${v}</span>`
                                ).join(' ')}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                searchPath = pathResult.path;
                highlightedNodes = new Set();
                
                resultHtml = `
                    <div class="result-box">
                        <div class="result-label">âŒ Hodnota ${value} NEBYLA nalezena</div>
                        <div style="margin-top: 1rem;">
                            <strong>ProhledanÃ¡ cesta:</strong><br>
                            <div style="margin-top: 0.5rem;">
                                ${pathResult.path.map((v, i) => 
                                    `<span class="path-info">${i === 0 ? 'ğŸŒ³' : 'â¡ï¸'} ${v}</span>`
                                ).join(' ')}
                            </div>
                            <div style="margin-top: 1rem;">
                                Hodnota by mÄ›la bÃ½t ${value < pathResult.path[pathResult.path.length - 1] ? 'vlevo' : 'vpravo'} 
                                od uzlu ${pathResult.path[pathResult.path.length - 1]}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('searchResult').innerHTML = resultHtml;
            visualizeBST();
        }

        function findPath() {
            const value = parseFloat(document.getElementById('searchValue').value);
            
            if (isNaN(value)) {
                alert('Zadejte platnÃ© ÄÃ­slo!');
                return;
            }

            const pathResult = bst.findPath(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            if (pathResult.found) {
                searchPath = pathResult.path;
                highlightedNodes = new Set(pathResult.path);
                
                const directions = [];
                for (let i = 1; i < pathResult.path.length; i++) {
                    const prev = pathResult.path[i - 1];
                    const curr = pathResult.path[i];
                    directions.push(curr < prev ? 'L' : 'R');
                }
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ—ºï¸ KompletnÃ­ cesta k hodnotÄ› ${value}</div>
                        <div style="margin-top: 1rem;">
                            <strong>CelkovÃ¡ hloubka:</strong> ${pathResult.depth}<br>
                            <strong>PoÄet pÅ™echodÅ¯:</strong> ${pathResult.path.length - 1}<br>
                            <strong>SmÄ›ry:</strong> ${directions.join(' â†’ ') || 'KoÅ™en'}<br><br>
                            <strong>DetailnÃ­ cesta:</strong><br>
                            <div style="margin-top: 0.5rem; line-height: 2;">
                                ${pathResult.path.map((v, i) => {
                                    let dir = '';
                                    if (i === 0) dir = 'ğŸŒ³ ROOT';
                                    else if (i === pathResult.path.length - 1) dir = 'ğŸ¯ TARGET';
                                    else dir = directions[i - 1] === 'L' ? 'â¬…ï¸ LEFT' : 'â¡ï¸ RIGHT';
                                    return `<span class="path-info">${dir}: ${v}</span>`;
                                }).join('<br>')}
                            </div>
                        </div>
                    </div>
                `;
                
                visualizeBST();
            } else {
                alert(`âŒ Hodnota ${value} nenÃ­ ve stromu!`);
            }
        }

        function findInRange() {
            const min = parseFloat(document.getElementById('rangeMin').value);
            const max = parseFloat(document.getElementById('rangeMax').value);
            
            if (isNaN(min) || isNaN(max)) {
                alert('Zadejte platnÃ© ÄÃ­selnÃ© hodnoty!');
                return;
            }

            if (min > max) {
                alert('Minimum musÃ­ bÃ½t menÅ¡Ã­ nebo rovno maximu!');
                return;
            }

            const values = bst.findInRange(min, max);
            highlightedNodes = new Set(values);
            searchPath = [];
            
            document.getElementById('searchResultCard').classList.remove('hidden');
            document.getElementById('searchResult').innerHTML = `
                <div class="result-box search-result">
                    <div class="result-label">ğŸ“Š Hodnoty v rozsahu [${min}, ${max}]</div>
                    <div style="margin-top: 1rem;">
                        <strong>PoÄet nalezenÃ½ch hodnot:</strong> ${values.length}<br>
                        <strong>Hodnoty (seÅ™azenÃ©):</strong><br>
                        <div style="margin-top: 0.5rem;">
                            ${values.map(v => `<span class="path-info">${v}</span>`).join(' ')}
                        </div>
                        ${values.length === 0 ? '<div style="margin-top: 1rem; color: #ff9800;">âš ï¸ V tomto rozsahu nejsou Å¾Ã¡dnÃ© hodnoty</div>' : ''}
                    </div>
                </div>
            `;
            
            visualizeBST();
        }

        function showAllMethods() {
            updateBSTDisplay();
            displayBSTMethods();
            displayAdvancedStats();
        }

        function updateBSTDisplay() {
            showResults();

            // Stats
            const statsHtml = `
                <div class="stat-card">
                    <div class="stat-value">${bst.count()}</div>
                    <div class="stat-label">PoÄet uzlÅ¯</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${bst.height()}</div>
                    <div class="stat-label">VÃ½Å¡ka stromu</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${bst.findMin() ?? '-'}</div>
                    <div class="stat-label">Minimum</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${bst.findMax() ?? '-'}</div>
                    <div class="stat-label">Maximum</div>
                </div>
            `;
            document.getElementById('statsGrid').innerHTML = statsHtml;

            // Visualization
            visualizeBST();

            // Traversals
            displayTraversals(bst);

            updateTreeInsights('bst');
        }

        function visualizeBST() {
            const vizContainer = document.getElementById('treeViz');
            
            if (currentVizMode === 'text') {
                vizContainer.innerHTML = `<pre>${bst.visualize()}</pre>`;
            } else if (currentVizMode === 'levels') {
                vizContainer.innerHTML = renderLevelVisualization();
            } else if (currentVizMode === 'canvas') {
                vizContainer.innerHTML = '<canvas id="treeCanvas" width="1200" height="600"></canvas>';
                drawCanvasTree();
            }
        }

        function renderLevelVisualization() {
            if (bst.root === null) return '<p>PrÃ¡zdnÃ½ strom</p>';
            
            const height = bst.height();
            let html = '<div style="padding: 1rem;">';
            
            for (let level = 0; level < height; level++) {
                const levelNodes = bst.getLevelNodes(level);
                
                html += `<div style="margin: 1rem 0;">`;
                html += `<span class="level-label">ÃšroveÅˆ ${level} (${levelNodes.length} uzlÅ¯):</span>`;
                html += `<div class="tree-level">`;
                
                levelNodes.forEach(value => {
                    let classes = 'node-visual';
                    if (highlightedNodes.has(value)) classes += ' found';
                    else if (searchPath.includes(value)) classes += ' path';
                    
                    html += `<div class="${classes}" onclick="showNodeInfo(${value})" title="KliknÄ›te pro info">${value}</div>`;
                });
                
                html += '</div></div>';
            }
            
            html += '</div>';
            return html;
        }

        function drawCanvasTree() {
            const canvas = document.getElementById('treeCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (bst.root === null) {
                ctx.fillStyle = '#1e4d6b';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PrÃ¡zdnÃ½ strom', width / 2, height / 2);
                return;
            }
            
            const treeHeight = bst.height();
            const verticalSpacing = Math.min(80, height / (treeHeight + 1));
            
            function drawNode(node, x, y, horizontalSpacing) {
                if (node === null) return;
                
                // Draw connections first
                if (node.left !== null) {
                    const leftX = x - horizontalSpacing / 2;
                    const leftY = y + verticalSpacing;
                    
                    ctx.strokeStyle = searchPath.includes(node.value) && searchPath.includes(node.left.value) 
                        ? '#9c27b0' : '#90caf9';
                    ctx.lineWidth = searchPath.includes(node.value) && searchPath.includes(node.left.value) ? 4 : 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(leftX, leftY);
                    ctx.stroke();
                    
                    drawNode(node.left, leftX, leftY, horizontalSpacing / 2);
                }
                
                if (node.right !== null) {
                    const rightX = x + horizontalSpacing / 2;
                    const rightY = y + verticalSpacing;
                    
                    ctx.strokeStyle = searchPath.includes(node.value) && searchPath.includes(node.right.value) 
                        ? '#9c27b0' : '#90caf9';
                    ctx.lineWidth = searchPath.includes(node.value) && searchPath.includes(node.right.value) ? 4 : 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(rightX, rightY);
                    ctx.stroke();
                    
                    drawNode(node.right, rightX, rightY, horizontalSpacing / 2);
                }
                
                // Draw node
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, 2 * Math.PI);
                
                if (highlightedNodes.has(node.value)) {
                    ctx.fillStyle = '#4caf50';
                } else if (searchPath.includes(node.value)) {
                    ctx.fillStyle = '#9c27b0';
                } else {
                    ctx.fillStyle = '#2196f3';
                }
                
                ctx.fill();
                ctx.strokeStyle = '#1565c0';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw value
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.value.toString(), x, y);
            }
            
            drawNode(bst.root, width / 2, 40, width / 4);
        }

        function showNodeInfo(value) {
            const depth = bst.getDepth(value);
            const pathResult = bst.findPath(value);
            
            document.getElementById('searchResultCard').classList.remove('hidden');
            document.getElementById('searchResult').innerHTML = `
                <div class="result-box search-result">
                    <div class="result-label">â„¹ï¸ Informace o uzlu ${value}</div>
                    <div style="margin-top: 1rem; line-height: 1.8;">
                        <strong>Hodnota:</strong> ${value}<br>
                        <strong>Hloubka:</strong> ${depth}<br>
                        <strong>Je v stromu:</strong> âœ… ANO<br>
                        <strong>Cesta z koÅ™ene:</strong> ${pathResult.path.join(' â†’ ')}<br>
                    </div>
                    <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button onclick="runDfsFromNode(${value})" style="padding: 0.5rem 1rem;">ğŸ” DFS od tohoto uzlu</button>
                        <button onclick="runBfsFromNode(${value})" style="padding: 0.5rem 1rem;">ğŸ”„ BFS od tohoto uzlu</button>
                    </div>
                </div>
            `;
        }

        function runDfsFromNode(value) {
            const result = bst.dfsFrom(value);
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                searchPath = result.result;
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ” DFS (Pre-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="showNodeInfo(${value})" style="padding: 0.5rem 1rem;">â† ZpÄ›t na info uzlu</button>
                            <button onclick="runBfsFromNode(${value})" style="padding: 0.5rem 1rem;">ğŸ”„ BFS od tohoto uzlu</button>
                        </div>
                    </div>
                `;
                
                visualizeBST();
            }
        }

        function runBfsFromNode(value) {
            const result = bst.bfsFrom(value);
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                searchPath = result.result;
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ”„ BFS (Level-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="showNodeInfo(${value})" style="padding: 0.5rem 1rem;">â† ZpÄ›t na info uzlu</button>
                            <button onclick="runDfsFromNode(${value})" style="padding: 0.5rem 1rem;">ğŸ” DFS od tohoto uzlu</button>
                        </div>
                    </div>
                `;
                
                visualizeBST();
            }
        }

        function displayAdvancedStats() {
            const stats = bst.getAdvancedStats();
            if (!stats) return;
            
            document.getElementById('advancedStatsCard').classList.remove('hidden');
            
            const balanceIcon = stats.balance.balanced ? 'âœ…' : 'âš ï¸';
            const balanceText = stats.balance.balanced ? 'VyvÃ¡Å¾enÃ½' : 'NevyvÃ¡Å¾enÃ½';
            
            document.getElementById('advancedStats').innerHTML = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${stats.sum}</div>
                        <div class="stat-label">SouÄet hodnot</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.average}</div>
                        <div class="stat-label">PrÅ¯mÄ›r</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.median}</div>
                        <div class="stat-label">MediÃ¡n</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.leafCount}</div>
                        <div class="stat-label">ListovÃ© uzly</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${stats.internalCount}</div>
                        <div class="stat-label">VnitÅ™nÃ­ uzly</div>
                    </div>
                </div>
                
                <div class="result-box" style="margin-top: 1rem;">
                    <div class="result-label">${balanceIcon} VyvÃ¡Å¾enÃ­ stromu</div>
                    <div style="line-height: 1.8;">
                        <strong>Stav:</strong> ${balanceText}<br>
                        <strong>VÃ½Å¡ka levÃ©ho podstromu:</strong> ${stats.balance.leftHeight}<br>
                        <strong>VÃ½Å¡ka pravÃ©ho podstromu:</strong> ${stats.balance.rightHeight}<br>
                        <strong>Balance faktor:</strong> ${stats.balance.balanceFactor}<br>
                        <small style="color: #90caf9;">
                            (Balance faktor = vÃ½Å¡ka_levÃ©ho - vÃ½Å¡ka_pravÃ©ho. 
                            Pro AVL strom musÃ­ bÃ½t |balance faktor| â‰¤ 1)
                        </small>
                    </div>
                </div>
            `;
        }

        function displayBSTMethods() {
            document.getElementById('methodsCard').classList.remove('hidden');
            const isValid = bst.isValidBST();

            document.getElementById('methods').innerHTML = `
                <div class="result-box">
                    <div class="result-label">âœ… ValidnÃ­ BST?</div>
                    <div>${isValid ? 'âœ… ANO' : 'âŒ NE'}</div>
                </div>

                <div class="result-box">
                    <div class="result-label">ğŸ” VÅ¡echny dostupnÃ© metody BST:</div>
                    <div style="line-height: 1.8;">
                        <code>insert(value)</code> - VloÅ¾it hodnotu<br>
                        <code>remove(value)</code> - Odebrat hodnotu<br>
                        <code>search(value)</code> - Vyhledat hodnotu<br>
                        <code>levelOrder()</code> - PrÅ¯chod do Å¡Ã­Å™ky (BFS)<br>
                        <code>preOrder()</code> - Preorder (DFS)<br>
                        <code>inOrder()</code> - Inorder (DFS) - seÅ™azenÃ©!<br>
                        <code>postOrder()</code> - Postorder (DFS)<br>
                        <code>findMin()</code> - NajÃ­t minimum<br>
                        <code>findMax()</code> - NajÃ­t maximum<br>
                        <code>height()</code> - VÃ½Å¡ka stromu<br>
                        <code>count()</code> - PoÄet uzlÅ¯<br>
                        <code>isValidBST()</code> - Validace BST<br>
                        <code>visualize()</code> - TextovÃ¡ vizualizace
                    </div>
                </div>
            `;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BINARY TREE UI FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function analyzeBinaryTree() {
            const input = document.getElementById('binaryInput').value;
            
            try {
                binaryTree = new BinaryTree();
                binaryTree.parse(input);
                
                showResults();
                document.getElementById('propertiesCard').classList.remove('hidden');
                document.getElementById('advancedStatsCard').classList.remove('hidden');

                const advStats = binaryTree.getAdvancedStats();

                // Stats
                const statsHtml = `
                    <div class="stat-card">
                        <div class="stat-value">${binaryTree.totalNodes}</div>
                        <div class="stat-label">Celkem uzlÅ¯</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${binaryTree.filledNodes}</div>
                        <div class="stat-label">NeprÃ¡zdnÃ© uzly</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${binaryTree.emptyNodes}</div>
                        <div class="stat-label">PrÃ¡zdnÃ© uzly (*)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${binaryTree.getHeight()}</div>
                        <div class="stat-label">VÃ½Å¡ka stromu</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${advStats.maxWidth}</div>
                        <div class="stat-label">Max. Å¡Ã­Å™ka</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${advStats.uniqueValues}</div>
                        <div class="stat-label">UnikÃ¡tnÃ­ hodnoty</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${advStats.density}%</div>
                        <div class="stat-label">Hustota stromu</div>
                    </div>
                `;
                document.getElementById('statsGrid').innerHTML = statsHtml;

                // Visualization
                visualizeBinaryTree();

                // Traversals
                displayTraversals(binaryTree);

                // Properties
                displayBinaryProperties();

                // Advanced stats
                displayBinaryAdvancedStats();

                updateTreeInsights('binary');

            } catch (error) {
                alert('âŒ Chyba: ' + error.message);
            }
        }

        function visualizeBinaryTree() {
            const vizContainer = document.getElementById('treeViz');
            
            if (currentVizMode === 'text') {
                vizContainer.innerHTML = `<pre>${binaryTree.visualize()}</pre>`;
            } else if (currentVizMode === 'levels') {
                vizContainer.innerHTML = renderBinaryLevelVisualization();
            } else if (currentVizMode === 'canvas') {
                vizContainer.innerHTML = '<canvas id="treeCanvas" width="1200" height="600"></canvas>';
                drawBinaryCanvasTree();
            }
        }

        function renderBinaryLevelVisualization() {
            if (binaryTree.nodes.length === 0) return '<p>PrÃ¡zdnÃ½ strom</p>';
            
            const height = binaryTree.getHeight();
            let html = '<div style="padding: 1rem;">';
            
            for (let level = 0; level < height; level++) {
                const levelNodes = binaryTree.getNodesByLevel(level);
                
                html += `<div style="margin: 1rem 0;">`;
                html += `<span class="level-label">ÃšroveÅˆ ${level} (${levelNodes.length} uzlÅ¯):</span>`;
                html += `<div class="tree-level">`;
                
                levelNodes.forEach(({index, value}) => {
                    let classes = 'node-visual';
                    if (highlightedNodes.has(value)) classes += ' found';
                    
                    html += `<div class="${classes}" onclick="showBinaryNodeInfo('${value}', ${index})" title="KliknÄ›te pro info">${value}</div>`;
                });
                
                html += '</div></div>';
            }
            
            html += '</div>';
            return html;
        }

        function drawBinaryCanvasTree() {
            const canvas = document.getElementById('treeCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            if (binaryTree.nodes.length === 0) {
                ctx.fillStyle = '#1e4d6b';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PrÃ¡zdnÃ½ strom', width / 2, height / 2);
                return;
            }
            
            const treeHeight = binaryTree.getHeight();
            const verticalSpacing = Math.min(80, height / (treeHeight + 1));
            
            function drawNodeAtIndex(index, x, y, horizontalSpacing, level) {
                if (index >= binaryTree.nodes.length || binaryTree.nodes[index] === '*') return;
                
                const leftIndex = 2 * index + 1;
                const rightIndex = 2 * index + 2;
                
                // Draw connections
                if (leftIndex < binaryTree.nodes.length && binaryTree.nodes[leftIndex] !== '*') {
                    const leftX = x - horizontalSpacing / 2;
                    const leftY = y + verticalSpacing;
                    
                    ctx.strokeStyle = '#90caf9';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(leftX, leftY);
                    ctx.stroke();
                    
                    drawNodeAtIndex(leftIndex, leftX, leftY, horizontalSpacing / 2, level + 1);
                }
                
                if (rightIndex < binaryTree.nodes.length && binaryTree.nodes[rightIndex] !== '*') {
                    const rightX = x + horizontalSpacing / 2;
                    const rightY = y + verticalSpacing;
                    
                    ctx.strokeStyle = '#90caf9';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(rightX, rightY);
                    ctx.stroke();
                    
                    drawNodeAtIndex(rightIndex, rightX, rightY, horizontalSpacing / 2, level + 1);
                }
                
                // Draw node
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, 2 * Math.PI);
                
                const value = binaryTree.nodes[index];
                ctx.fillStyle = highlightedNodes.has(value) ? '#4caf50' : '#2196f3';
                ctx.fill();
                
                ctx.strokeStyle = '#1565c0';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw value
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, x, y);
            }
            
            drawNodeAtIndex(0, width / 2, 40, width / 4, 0);
        }

        function searchBinaryNode() {
            const value = document.getElementById('searchBinaryValue').value.trim();
            
            if (!value) {
                alert('Zadejte identifikÃ¡tor uzlu!');
                return;
            }

            const result = binaryTree.findNode(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            if (result.found) {
                highlightedNodes = new Set([value]);
                
                const leftChild = result.leftChild < binaryTree.nodes.length ? binaryTree.nodes[result.leftChild] : 'mimo rozsah';
                const rightChild = result.rightChild < binaryTree.nodes.length ? binaryTree.nodes[result.rightChild] : 'mimo rozsah';
                const parent = result.parent !== null ? binaryTree.nodes[result.parent] : 'Å¾Ã¡dnÃ½ (koÅ™en)';
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">âœ… Uzel "${value}" nalezen!</div>
                        <div style="margin-top: 1rem; line-height: 1.8;">
                            <strong>Index v poli:</strong> ${result.index}<br>
                            <strong>ÃšroveÅˆ:</strong> ${result.level}<br>
                            <strong>RodiÄ:</strong> ${parent}<br>
                            <strong>LevÃ½ potomek:</strong> ${leftChild}<br>
                            <strong>PravÃ½ potomek:</strong> ${rightChild}<br>
                        </div>
                    </div>
                `;
                
                visualizeBinaryTree();
            } else {
                highlightedNodes.clear();
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box">
                        <div class="result-label">âŒ Uzel "${value}" nebyl nalezen</div>
                        <div style="margin-top: 1rem;">
                            ZadanÃ½ identifikÃ¡tor nenÃ­ ve stromu.
                        </div>
                    </div>
                `;
            }
        }

        function showBinaryNodeInfo(value, index) {
            const result = binaryTree.findNode(value);
            
            if (result.found) {
                highlightedNodes = new Set([value]);
                
                const leftChild = result.leftChild < binaryTree.nodes.length ? binaryTree.nodes[result.leftChild] : 'mimo rozsah';
                const rightChild = result.rightChild < binaryTree.nodes.length ? binaryTree.nodes[result.rightChild] : 'mimo rozsah';
                const parent = result.parent !== null ? binaryTree.nodes[result.parent] : 'Å¾Ã¡dnÃ½ (koÅ™en)';
                
                document.getElementById('searchResultCard').classList.remove('hidden');
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">â„¹ï¸ Informace o uzlu "${value}"</div>
                        <div style="margin-top: 1rem; line-height: 1.8;">
                            <strong>Hodnota:</strong> ${value}<br>
                            <strong>Index:</strong> ${result.index}<br>
                            <strong>ÃšroveÅˆ:</strong> ${result.level}<br>
                            <strong>RodiÄ:</strong> ${parent}<br>
                            <strong>LevÃ½ potomek:</strong> ${leftChild}<br>
                            <strong>PravÃ½ potomek:</strong> ${rightChild}<br>
                        </div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="runBinaryDfsFromNode('${value}')" style="padding: 0.5rem 1rem;">ğŸ” DFS od tohoto uzlu</button>
                            <button onclick="runBinaryBfsFromNode('${value}')" style="padding: 0.5rem 1rem;">ğŸ”„ BFS od tohoto uzlu</button>
                        </div>
                    </div>
                `;
                
                visualizeBinaryTree();
            }
        }

        function runBinaryDfsFromNode(value) {
            const result = binaryTree.dfsFrom(value);
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ” DFS (Pre-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="showBinaryNodeInfo('${value}', 0)" style="padding: 0.5rem 1rem;">â† ZpÄ›t na info uzlu</button>
                            <button onclick="runBinaryBfsFromNode('${value}')" style="padding: 0.5rem 1rem;">ğŸ”„ BFS od tohoto uzlu</button>
                        </div>
                    </div>
                `;
                
                visualizeBinaryTree();
            }
        }

        function runBinaryBfsFromNode(value) {
            const result = binaryTree.bfsFrom(value);
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ”„ BFS (Level-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button onclick="showBinaryNodeInfo('${value}', 0)" style="padding: 0.5rem 1rem;">â† ZpÄ›t na info uzlu</button>
                            <button onclick="runBinaryDfsFromNode('${value}')" style="padding: 0.5rem 1rem;">ğŸ” DFS od tohoto uzlu</button>
                        </div>
                    </div>
                `;
                
                visualizeBinaryTree();
            }
        }

        function displayBinaryAdvancedStats() {
            const height = binaryTree.getHeight();
            let levelStats = '<div style="margin-top: 1rem;"><strong>ğŸ“Š Statistika po ÃºrovnÃ­ch:</strong><br><br>';
            
            for (let level = 0; level < height; level++) {
                const nodes = binaryTree.getNodesByLevel(level);
                const maxPossible = Math.pow(2, level);
                const fillRate = (nodes.length / maxPossible * 100).toFixed(1);
                
                levelStats += `<div class="result-box" style="margin: 0.5rem 0;">
                    <strong>ÃšroveÅˆ ${level}:</strong> ${nodes.length}/${maxPossible} uzlÅ¯ (${fillRate}% zaplnÄ›nÃ­)
                </div>`;
            }
            
            levelStats += '</div>';
            
            document.getElementById('advancedStats').innerHTML = levelStats;
        }

        function displayBinaryProperties() {
            const propertiesHtml = `
                <div class="result-box">
                    <div class="result-label">ğŸ“‹ Vlastnosti Binary Tree:</div>
                    <div style="line-height: 1.8;">
                        <strong>KompletnÃ­ strom:</strong> ${binaryTree.isComplete() ? 'âœ… ANO' : 'âŒ NE'}<br>
                        <strong>PlnÃ½ strom:</strong> ${binaryTree.isFull() ? 'âœ… ANO' : 'âŒ NE'}<br>
                        <strong>PerfektnÃ­ strom:</strong> ${binaryTree.isPerfect() ? 'âœ… ANO' : 'âŒ NE'}
                    </div>
                </div>
            `;
            document.getElementById('properties').innerHTML = propertiesHtml;
        }

        function buildBstTreeModel() {
            if (!bst.root) return null;
            const nodes = [];
            const nodeMap = {};
            let counter = 0;
            let edgeCount = 0;
            const queue = [{ treeNode: bst.root, depth: 0, parentId: null }];

            while (queue.length) {
                const { treeNode, depth, parentId } = queue.shift();
                if (!treeNode) continue;
                const id = `bst_${counter++}`;
                const label = treeNode.value !== undefined && treeNode.value !== null ? treeNode.value.toString() : `Uzel ${counter}`;
                const entry = {
                    id,
                    label,
                    displayLabel: label,
                    depth,
                    parentId,
                    parentLabel: 'â€”',
                    children: [],
                    childrenLabels: [],
                    degree: 0,
                    type: 'List'
                };
                nodes.push(entry);
                nodeMap[id] = entry;
                if (parentId && nodeMap[parentId]) {
                    nodeMap[parentId].children.push(id);
                }

                if (treeNode.left) {
                    queue.push({ treeNode: treeNode.left, depth: depth + 1, parentId: id });
                    edgeCount++;
                }
                if (treeNode.right) {
                    queue.push({ treeNode: treeNode.right, depth: depth + 1, parentId: id });
                    edgeCount++;
                }
            }

            nodes.forEach(node => {
                const childCount = node.children.length;
                node.degree = childCount + (node.parentId ? 1 : 0);
                node.type = childCount === 0 ? 'List' : 'VnitÅ™nÃ­';
                node.parentLabel = node.parentId && nodeMap[node.parentId]
                    ? nodeMap[node.parentId].label
                    : 'â€”';
                node.childrenLabels = node.children
                    .map(childId => nodeMap[childId]?.label || '')
                    .filter(label => label);
            });

            return {
                nodes,
                nodeMap,
                rootId: nodes.length ? nodes[0].id : null,
                edgeCount,
                meta: { type: 'bst', label: 'BST' }
            };
        }

        function buildBinaryTreeModel() {
            if (!binaryTree || !binaryTree.nodes.length || binaryTree.nodes[0] === '*') return null;
            const nodes = [];
            const nodeMap = {};
            const queue = [{ index: 0, depth: 0, parentId: null }];
            let edgeCount = 0;

            while (queue.length) {
                const { index, depth, parentId } = queue.shift();
                if (index >= binaryTree.nodes.length) continue;
                const value = binaryTree.nodes[index];
                if (value === '*') continue;
                const id = `bin_${index}`;
                const label = value.toString();
                const entry = {
                    id,
                    index,
                    label,
                    displayLabel: `${label} (idx ${index})`,
                    depth,
                    parentId,
                    parentLabel: 'â€”',
                    children: [],
                    childrenLabels: [],
                    degree: 0,
                    type: 'List'
                };
                nodes.push(entry);
                nodeMap[id] = entry;
                if (parentId && nodeMap[parentId]) {
                    nodeMap[parentId].children.push(id);
                }

                const leftIdx = 2 * index + 1;
                const rightIdx = 2 * index + 2;
                if (leftIdx < binaryTree.nodes.length && binaryTree.nodes[leftIdx] !== '*') {
                    queue.push({ index: leftIdx, depth: depth + 1, parentId: id });
                    edgeCount++;
                }
                if (rightIdx < binaryTree.nodes.length && binaryTree.nodes[rightIdx] !== '*') {
                    queue.push({ index: rightIdx, depth: depth + 1, parentId: id });
                    edgeCount++;
                }
            }

            nodes.forEach(node => {
                const childCount = node.children.length;
                node.degree = childCount + (node.parentId ? 1 : 0);
                node.type = childCount === 0 ? 'List' : 'VnitÅ™nÃ­';
                node.parentLabel = node.parentId && nodeMap[node.parentId]
                    ? nodeMap[node.parentId].label
                    : 'â€”';
                node.childrenLabels = node.children
                    .map(childId => nodeMap[childId]?.label || '')
                    .filter(label => label);
            });

            return {
                nodes,
                nodeMap,
                rootId: nodes.length ? 'bin_0' : null,
                edgeCount,
                meta: { type: 'binary', label: 'Binary Tree' }
            };
        }

        function renderNodeTable(model) {
            const card = document.getElementById('nodeTableCard');
            const container = document.getElementById('nodeTable');
            if (!model) {
                card.classList.add('hidden');
                container.innerHTML = '';
                return;
            }
            card.classList.remove('hidden');
            const rows = model.nodes.map((node, idx) => `
                <tr>
                    <td style="padding:0.25rem;">${idx + 1}. ${node.displayLabel}</td>
                    <td style="padding:0.25rem; text-align:right;">${node.depth}</td>
                    <td style="padding:0.25rem;">${node.parentLabel}</td>
                    <td style="padding:0.25rem;">${node.childrenLabels.length ? node.childrenLabels.join(', ') : 'â€”'}</td>
                    <td style="padding:0.25rem; text-align:center;">${node.degree}</td>
                    <td style="padding:0.25rem; text-align:center;">${node.type}</td>
                </tr>
            `).join('');
            container.innerHTML = `
                <div class="result-box">
                    <div class="result-label">${model.meta.label} â€“ uzly & hrany</div>
                    <div>Uzly: ${model.nodes.length} | Hrany: ${model.edgeCount}</div>
                </div>
                <div class="scrollable-panel">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align:left; padding:0.25rem;"># Uzel</th>
                                <th style="text-align:right; padding:0.25rem;">Hloubka</th>
                                <th style="text-align:left; padding:0.25rem;">RodiÄ</th>
                                <th style="text-align:left; padding:0.25rem;">Potomci</th>
                                <th style="text-align:center; padding:0.25rem;">StupeÅˆ</th>
                                <th style="text-align:center; padding:0.25rem;">Typ</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    </table>
                </div>
            `;
        }

        function computeDiameterFromModel(model) {
            if (!model || !model.rootId) return null;
            const nodeMap = model.nodeMap;
            let bestPath = [];

            const dfs = (nodeId) => {
                const node = nodeMap[nodeId];
                if (!node) return { depth: -1, pathDown: [] };
                if (!node.children.length) {
                    const pathDown = [nodeId];
                    if (pathDown.length > bestPath.length) bestPath = pathDown.slice();
                    return { depth: 0, pathDown };
                }

                const childResults = node.children.map(childId => dfs(childId));
                childResults.sort((a, b) => b.depth - a.depth);

                const bestChild = childResults[0];
                const pathDown = [nodeId];
                if (bestChild && bestChild.depth >= 0) {
                    pathDown.push(...bestChild.pathDown);
                }

                if (pathDown.length > bestPath.length) bestPath = pathDown.slice();

                if (childResults.length >= 2) {
                    const through = [
                        ...childResults[0].pathDown.slice().reverse(),
                        nodeId,
                        ...childResults[1].pathDown
                    ];
                    if (through.length > bestPath.length) bestPath = through.slice();
                }

                return {
                    depth: (bestChild ? bestChild.depth : -1) + 1,
                    pathDown
                };
            };

            const rootResult = dfs(model.rootId);
            if (!bestPath.length && rootResult.pathDown.length) {
                bestPath = rootResult.pathDown.slice();
            }
            return {
                length: bestPath.length ? bestPath.length - 1 : 0,
                path: bestPath
            };
        }

        function computePathInsightsFromModel(model) {
            if (!model || !model.rootId) return null;
            const nodeMap = model.nodeMap;
            const longest = { length: -Infinity, path: [] };
            const shortest = { length: Infinity, path: [] };

            const dfs = (nodeId, path) => {
                const node = nodeMap[nodeId];
                if (!node) return;
                path.push(nodeId);
                if (!node.children.length) {
                    const edges = path.length - 1;
                    if (edges > longest.length) {
                        longest.length = edges;
                        longest.path = path.slice();
                    }
                    if (edges < shortest.length) {
                        shortest.length = edges;
                        shortest.path = path.slice();
                    }
                } else {
                    node.children.forEach(childId => dfs(childId, path));
                }
                path.pop();
            };

            dfs(model.rootId, []);

            if (longest.length === -Infinity) {
                longest.length = 0;
                longest.path = model.rootId ? [model.rootId] : [];
            }
            if (shortest.length === Infinity) {
                shortest.length = 0;
                shortest.path = model.rootId ? [model.rootId] : [];
            }

            const diameter = computeDiameterFromModel(model);
            return {
                longest,
                shortest,
                diameter
            };
        }

        function renderPathInsights(model) {
            const card = document.getElementById('pathInsightsCard');
            const container = document.getElementById('pathInsights');
            if (!model) {
                card.classList.add('hidden');
                container.innerHTML = '';
                return;
            }
            const insights = computePathInsightsFromModel(model);
            if (!insights) {
                card.classList.add('hidden');
                container.innerHTML = '';
                return;
            }
            card.classList.remove('hidden');
            const toLabelPath = (ids) => (ids && ids.length)
                ? ids.map(id => model.nodeMap[id]?.label || '?').join(' â†’ ')
                : 'â€”';
            const leafCount = model.nodes.filter(node => !node.children.length).length;
            const maxDepth = model.nodes.length ? Math.max(...model.nodes.map(n => n.depth)) : 0;
            container.innerHTML = `
                <div class="result-box">
                    <div class="result-label">${model.meta.label} â€“ listy & statistiky</div>
                    <div>Listy: ${leafCount} | NejvÄ›tÅ¡Ã­ hloubka: ${maxDepth}</div>
                </div>
                <div class="result-box">
                    <div class="result-label">NejdelÅ¡Ã­ cesta od koÅ™ene</div>
                    <div>DÃ©lka (hrany): ${insights.longest.length}</div>
                    <div>Cesta: ${toLabelPath(insights.longest.path)}</div>
                </div>
                <div class="result-box">
                    <div class="result-label">NejkratÅ¡Ã­ cesta od koÅ™ene</div>
                    <div>DÃ©lka (hrany): ${insights.shortest.length}</div>
                    <div>Cesta: ${toLabelPath(insights.shortest.path)}</div>
                </div>
                <div class="result-box">
                    <div class="result-label">PrÅ¯mÄ›r stromu (nejdelÅ¡Ã­ cesta mezi uzly)</div>
                    <div>DÃ©lka (hrany): ${insights.diameter ? insights.diameter.length : 0}</div>
                    <div>Cesta: ${insights.diameter ? toLabelPath(insights.diameter.path) : 'â€”'}</div>
                </div>
            `;
        }

        function updateTreeInsights(mode) {
            const model = mode === 'binary' ? buildBinaryTreeModel() : buildBstTreeModel();
            renderNodeTable(model);
            renderPathInsights(model);
        }

        function parseDurationOverrides(text) {
            const overrides = {};
            if (!text) return overrides;
            const parts = text.split(/[,;]+/);
            parts.forEach(part => {
                const cleaned = part.trim();
                if (!cleaned) return;
                const [key, value] = cleaned.split(/[:=]/);
                if (!key || value === undefined) return;
                const duration = parseFloat(value.replace(',', '.'));
                if (!isNaN(duration)) {
                    overrides[key.trim()] = Math.max(0, Math.abs(duration));
                }
            });
            return overrides;
        }

        function inferDurationFromValue(rawValue, overrides, fallback) {
            const key = rawValue !== undefined && rawValue !== null ? rawValue.toString() : '';
            if (key && Object.prototype.hasOwnProperty.call(overrides, key)) {
                return overrides[key];
            }
            const numeric = parseFloat(key.replace(',', '.'));
            if (!isNaN(numeric)) {
                return Math.max(0, Math.abs(numeric));
            }
            return Math.max(0, fallback);
        }

        function buildBstCpmStructure(resolveDuration) {
            if (!bst.root) return null;
            const nodes = [];
            const nodeInfo = {};
            const adj = {};
            const edges = [];
            const order = [];
            const seenOrder = new Set();

            const registerNode = (node) => {
                if (!node) return null;
                const id = `bst_${node.value}`;
                if (!nodeInfo[id]) {
                    nodeInfo[id] = { label: node.value.toString() };
                    nodes.push({ id, label: nodeInfo[id].label });
                }
                if (!seenOrder.has(id)) {
                    seenOrder.add(id);
                    order.push(id);
                }
                return id;
            };

            const queue = [bst.root];
            while (queue.length) {
                const current = queue.shift();
                if (!current) continue;
                const fromId = registerNode(current);
                const children = [current.left, current.right];
                children.forEach(child => {
                    if (!child) return;
                    const toId = registerNode(child);
                    queue.push(child);
                    const duration = resolveDuration(child.value);
                    const edge = {
                        from: fromId,
                        to: toId,
                        duration,
                        fromLabel: current.value.toString(),
                        toLabel: child.value.toString()
                    };
                    edges.push(edge);
                    (adj[fromId] = adj[fromId] || []).push(edge);
                });
            }

            return {
                nodes,
                edges,
                adj,
                order,
                nodeInfo,
                rootId: `bst_${bst.root.value}`,
                meta: {
                    mode: 'bst',
                    label: 'BST',
                    totalNodes: nodes.length
                }
            };
        }

        function buildBinaryCpmStructure(resolveDuration) {
            if (!binaryTree || !binaryTree.nodes.length || binaryTree.nodes[0] === '*') return null;
            const nodes = [];
            const nodeInfo = {};
            const adj = {};
            const edges = [];
            const order = [];
            const seenOrder = new Set();

            const registerNode = (index) => {
                const value = binaryTree.nodes[index];
                const id = `bin_${index}`;
                if (!nodeInfo[id]) {
                    nodeInfo[id] = { label: value.toString(), index };
                    nodes.push({ id, label: nodeInfo[id].label, index });
                }
                if (!seenOrder.has(id)) {
                    seenOrder.add(id);
                    order.push(id);
                }
                return id;
            };

            for (let i = 0; i < binaryTree.nodes.length; i++) {
                const value = binaryTree.nodes[i];
                if (value === '*') continue;
                const fromId = registerNode(i);
                const children = [2 * i + 1, 2 * i + 2];
                children.forEach(childIdx => {
                    if (childIdx >= binaryTree.nodes.length) return;
                    const childValue = binaryTree.nodes[childIdx];
                    if (childValue === '*') return;
                    const toId = registerNode(childIdx);
                    const duration = resolveDuration(childValue);
                    const edge = {
                        from: fromId,
                        to: toId,
                        duration,
                        fromLabel: value.toString(),
                        toLabel: childValue.toString()
                    };
                    edges.push(edge);
                    (adj[fromId] = adj[fromId] || []).push(edge);
                });
            }

            if (!nodes.length) return null;

            return {
                nodes,
                edges,
                adj,
                order,
                nodeInfo,
                rootId: 'bin_0',
                meta: {
                    mode: 'binary',
                    label: 'Binary Tree',
                    totalNodes: nodes.length
                }
            };
        }

        function analyzeTreeCpm(structure) {
            const EPS = 1e-6;
            const earliest = {};
            const latest = {};

            structure.nodes.forEach(node => {
                earliest[node.id] = 0;
            });

            structure.order.forEach(nodeId => {
                const outgoing = structure.adj[nodeId] || [];
                outgoing.forEach(edge => {
                    const candidate = earliest[nodeId] + edge.duration;
                    if (candidate > earliest[edge.to]) {
                        earliest[edge.to] = candidate;
                    }
                });
            });

            const projectDuration = Math.max(0, ...Object.values(earliest));

            structure.nodes.forEach(node => {
                latest[node.id] = projectDuration;
            });

            for (let i = structure.order.length - 1; i >= 0; i--) {
                const nodeId = structure.order[i];
                const outgoing = structure.adj[nodeId] || [];
                if (!outgoing.length) continue;
                let minCandidate = Infinity;
                outgoing.forEach(edge => {
                    const candidate = latest[edge.to] - edge.duration;
                    if (candidate < minCandidate) minCandidate = candidate;
                });
                if (minCandidate < Infinity) {
                    latest[nodeId] = Math.min(latest[nodeId], minCandidate);
                }
            }

            const nodeSummaries = structure.nodes.map(node => {
                const earliestVal = earliest[node.id];
                const latestVal = latest[node.id];
                const slack = latestVal - earliestVal;
                return {
                    id: node.id,
                    label: structure.nodeInfo[node.id].label,
                    earliest: earliestVal,
                    latest: latestVal,
                    slack,
                    isCritical: Math.abs(slack) < EPS
                };
            });

            const activities = structure.edges.map(edge => {
                const earlyStart = earliest[edge.from];
                const earlyFinish = earlyStart + edge.duration;
                const lateFinish = latest[edge.to];
                const lateStart = lateFinish - edge.duration;
                const slack = lateStart - earlyStart;
                return {
                    fromId: edge.from,
                    toId: edge.to,
                    fromLabel: edge.fromLabel,
                    toLabel: edge.toLabel,
                    duration: edge.duration,
                    earlyStart,
                    earlyFinish,
                    lateStart,
                    lateFinish,
                    slack,
                    isCritical: Math.abs(slack) < EPS
                };
            });

            const criticalEdges = activities.filter(edge => edge.isCritical);
            const criticalPath = [];
            if (structure.rootId && structure.nodeInfo[structure.rootId]) {
                const visited = new Set();
                let current = structure.rootId;
                while (current && !visited.has(current)) {
                    visited.add(current);
                    criticalPath.push(structure.nodeInfo[current].label);
                    const next = criticalEdges.find(edge => edge.fromId === current);
                    if (!next) break;
                    current = next.toId;
                }
            }

            const leafNames = structure.nodes
                .filter(node => !(structure.adj[node.id] && structure.adj[node.id].length))
                .map(node => structure.nodeInfo[node.id].label);

            return {
                projectDuration,
                nodeSummaries,
                activities,
                criticalPath,
                criticalEdgeCount: criticalEdges.length,
                leaves: leafNames,
                sources: structure.rootId && structure.nodeInfo[structure.rootId]
                    ? [structure.nodeInfo[structure.rootId].label]
                    : [],
                nodeCount: structure.nodes.length,
                edgeCount: structure.edges.length
            };
        }

        function runTreeCpm() {
            const cpmDiv = document.getElementById('cpmResult');
            const durationInputEl = document.getElementById('defaultEdgeDuration');
            const rawDefault = durationInputEl ? durationInputEl.value : '1';
            const defaultInput = parseFloat((rawDefault || '1').replace(',', '.'));
            const fallback = Number.isFinite(defaultInput) && defaultInput >= 0 ? defaultInput : 1;
            const overrides = parseDurationOverrides(document.getElementById('customDurations').value);
            const resolver = (value) => inferDurationFromValue(value, overrides, fallback);
            const structure = currentMode === 'binary'
                ? buildBinaryCpmStructure(resolver)
                : buildBstCpmStructure(resolver);

            if (!structure) {
                cpmDiv.innerHTML = `
                    <div class="result-box">
                        <div class="result-label">âš ï¸ Nelze vytvoÅ™it sÃ­Å¥</div>
                        <div>NejdÅ™Ã­ve prosÃ­m vytvoÅ™te nebo naÄtÄ›te strom (BST Äi Binary Tree).</div>
                    </div>
                `;
                document.getElementById('cpmCard').classList.remove('hidden');
                return;
            }

            const analysis = analyzeTreeCpm(structure);
            const formatNumber = (value) => {
                if (!Number.isFinite(value)) return 'â€”';
                const rounded = Math.round((value + Number.EPSILON) * 100) / 100;
                return Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(2);
            };

            let html = `
                <div class="result-box">
                    <div class="result-label">ShrnutÃ­ CPM & sÃ­tÄ› (${structure.meta.label})</div>
                    <div style="line-height: 1.8;">
                        <strong>Uzly sÃ­tÄ›:</strong> ${analysis.nodeCount}<br>
                        <strong>ÄŒinnosti (hrany):</strong> ${analysis.edgeCount}<br>
                        <strong>Listy (cÃ­le):</strong> ${analysis.leaves.length ? analysis.leaves.join(', ') : 'â€”'}<br>
                        <strong>KritickÃ¡ cesta:</strong> ${analysis.criticalPath.length ? analysis.criticalPath.join(' â†’ ') : 'Nenalezena'}<br>
                        <strong>DÃ©lka projektu:</strong> ${formatNumber(analysis.projectDuration)}<br>
                        <strong>PoÄet kritickÃ½ch ÄinnostÃ­:</strong> ${analysis.criticalEdgeCount}
                    </div>
                </div>
            `;

            html += `
                <div class="scrollable-panel">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="text-align:left; padding:0.25rem;">Uzel</th>
                                <th style="text-align:right; padding:0.25rem;">ES</th>
                                <th style="text-align:right; padding:0.25rem;">LS</th>
                                <th style="text-align:right; padding:0.25rem;">Rezerva</th>
                                <th style="text-align:center; padding:0.25rem;">KritickÃ½?</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${analysis.nodeSummaries.map(node => `
                                <tr>
                                    <td style="padding:0.25rem;">${node.label}</td>
                                    <td style="padding:0.25rem; text-align:right;">${formatNumber(node.earliest)}</td>
                                    <td style="padding:0.25rem; text-align:right;">${formatNumber(node.latest)}</td>
                                    <td style="padding:0.25rem; text-align:right;">${formatNumber(node.slack)}</td>
                                    <td style="padding:0.25rem; text-align:center;">${node.isCritical ? 'âœ…' : 'â€”'}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;

            if (analysis.activities.length) {
                html += `
                    <div class="scrollable-panel">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr>
                                    <th style="text-align:left; padding:0.25rem;">Aktivita</th>
                                    <th style="text-align:right; padding:0.25rem;">DÃ©lka</th>
                                    <th style="text-align:right; padding:0.25rem;">ES</th>
                                    <th style="text-align:right; padding:0.25rem;">EF</th>
                                    <th style="text-align:right; padding:0.25rem;">LS</th>
                                    <th style="text-align:right; padding:0.25rem;">LF</th>
                                    <th style="text-align:right; padding:0.25rem;">Rezerva</th>
                                    <th style="text-align:center; padding:0.25rem;">KritickÃ¡?</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${analysis.activities.map(act => `
                                    <tr>
                                        <td style="padding:0.25rem;">${act.fromLabel} â†’ ${act.toLabel}</td>
                                        <td style="padding:0.25rem; text-align:right;">${formatNumber(act.duration)}</td>
                                        <td style="padding:0.25rem; text-align:right;">${formatNumber(act.earlyStart)}</td>
                                        <td style="padding:0.25rem; text-align:right;">${formatNumber(act.earlyFinish)}</td>
                                        <td style="padding:0.25rem; text-align:right;">${formatNumber(act.lateStart)}</td>
                                        <td style="padding:0.25rem; text-align:right;">${formatNumber(act.lateFinish)}</td>
                                        <td style="padding:0.25rem; text-align:right;">${formatNumber(act.slack)}</td>
                                        <td style="padding:0.25rem; text-align:center;">${act.isCritical ? 'ğŸ”¥' : 'â€”'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            } else {
                html += `
                    <div class="result-box" style="margin-top: 1rem;">
                        Strom obsahuje pouze koÅ™en â€“ sÃ­Å¥ proto neobsahuje Å¾Ã¡dnÃ© Äinnosti.
                    </div>
                `;
            }

            html += `
                <p style="color:#bbdefb; font-size:0.9rem; margin-top:0.5rem;">
                    Tip: kritickÃ¡ cesta je zvÃ½raznÄ›na i ve vizualizaci stromu. VlastnÃ­ dÃ©lky zadÃ¡vejte podle identifikÃ¡toru uzlu.
                </p>
            `;

            cpmDiv.innerHTML = html;

            if (analysis.criticalPath.length) {
                highlightedNodes = new Set(analysis.criticalPath);
                if (currentMode === 'bst') {
                    visualizeBST();
                } else if (binaryTree) {
                    visualizeBinaryTree();
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DFS/BFS FROM VALUE FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        function runDfsFromValue() {
            const value = parseFloat(document.getElementById('dfsStartValue').value);
            
            if (isNaN(value)) {
                alert('Zadejte platnÃ© ÄÃ­slo!');
                return;
            }

            const result = bst.dfsFrom(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                searchPath = result.result;
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ” DFS (Pre-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                    </div>
                `;
                
                visualizeBST();
            } else {
                highlightedNodes.clear();
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box" style="border-left-color: #f44336;">
                        <div class="result-label">âŒ Uzel ${value} nebyl nalezen</div>
                        <div>ZadanÃ¡ hodnota neexistuje ve stromu.</div>
                    </div>
                `;
            }
        }

        function runBfsFromValue() {
            const value = parseFloat(document.getElementById('dfsStartValue').value);
            
            if (isNaN(value)) {
                alert('Zadejte platnÃ© ÄÃ­slo!');
                return;
            }

            const result = bst.bfsFrom(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                searchPath = result.result;
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ”„ BFS (Level-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                    </div>
                `;
                
                visualizeBST();
            } else {
                highlightedNodes.clear();
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box" style="border-left-color: #f44336;">
                        <div class="result-label">âŒ Uzel ${value} nebyl nalezen</div>
                        <div>ZadanÃ¡ hodnota neexistuje ve stromu.</div>
                    </div>
                `;
            }
        }

        function runBinaryDfsFromValue() {
            const value = document.getElementById('dfsStartBinaryValue').value.trim();
            
            if (!value) {
                alert('Zadejte identifikÃ¡tor uzlu!');
                return;
            }

            if (!binaryTree) {
                alert('Nejprve analyzujte Binary Tree!');
                return;
            }

            const result = binaryTree.dfsFrom(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ” DFS (Pre-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                    </div>
                `;
                
                visualizeBinaryTree();
            } else {
                highlightedNodes.clear();
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box" style="border-left-color: #f44336;">
                        <div class="result-label">âŒ Uzel "${value}" nebyl nalezen</div>
                        <div>ZadanÃ½ identifikÃ¡tor neexistuje ve stromu.</div>
                    </div>
                `;
            }
        }

        function runBinaryBfsFromValue() {
            const value = document.getElementById('dfsStartBinaryValue').value.trim();
            
            if (!value) {
                alert('Zadejte identifikÃ¡tor uzlu!');
                return;
            }

            if (!binaryTree) {
                alert('Nejprve analyzujte Binary Tree!');
                return;
            }

            const result = binaryTree.bfsFrom(value);
            document.getElementById('searchResultCard').classList.remove('hidden');
            
            if (result.found) {
                highlightedNodes = new Set(result.result);
                
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box search-result">
                        <div class="result-label">ğŸ”„ BFS (Level-Order) od uzlu ${value}</div>
                        <div><strong>PoÅ™adÃ­ prÅ¯chodu:</strong> ${result.result.join(' â†’ ')}</div>
                        <div style="margin-top: 0.5rem;"><strong>PoÄet navÅ¡tÃ­venÃ½ch uzlÅ¯:</strong> ${result.result.length}</div>
                    </div>
                `;
                
                visualizeBinaryTree();
            } else {
                highlightedNodes.clear();
                document.getElementById('searchResult').innerHTML = `
                    <div class="result-box" style="border-left-color: #f44336;">
                        <div class="result-label">âŒ Uzel "${value}" nebyl nalezen</div>
                        <div>ZadanÃ½ identifikÃ¡tor neexistuje ve stromu.</div>
                    </div>
                `;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SHARED FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function displayTraversals(tree) {
            const traversals = [
                { label: 'ğŸ”„ Level-Order (Do Å¡Ã­Å™ky - BFS)', result: tree.levelOrder() },
                { label: 'â¬‡ï¸ Pre-Order (koÅ™enâ†’Lâ†’R)', result: tree.preOrder() },
                { label: 'ğŸ“Š In-Order (Lâ†’koÅ™enâ†’R)', result: tree.inOrder() },
                { label: 'â¬†ï¸ Post-Order (Lâ†’Râ†’koÅ™en)', result: tree.postOrder() }
            ];

            let html = '';
            traversals.forEach(trav => {
                html += `
                    <div class="result-box">
                        <div class="result-label">${trav.label}</div>
                        <div>${trav.result.join(' â†’ ')}</div>
                    </div>
                `;
            });

            document.getElementById('traversals').innerHTML = html;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VÃNOÄŒNÃ SVÄšTÃLKA - CHRISTMAS LIGHTS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function generateChristmasLights() {
            const container = document.getElementById('lightsContainer');
            const colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
            const screenWidth = window.innerWidth;
            const lightSpacing = 45; // rozestup mezi svÄ›tÃ½lky
            const numberOfLights = Math.floor(screenWidth / lightSpacing);
            
            container.innerHTML = '';
            
            for (let i = 0; i < numberOfLights; i++) {
                const light = document.createElement('div');
                light.className = 'light ' + colors[i % colors.length];
                // NÃ¡hodnÃ© zpoÅ¾dÄ›nÃ­ animace pro pÅ™irozenÄ›jÅ¡Ã­ efekt
                light.style.animationDelay = (Math.random() * 2) + 's, ' + (Math.random() * 2) + 's';
                container.appendChild(light);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.onload = function() {
            // Generovat vÃ¡noÄnÃ­ svÄ›tÃ½lka
            generateChristmasLights();
            window.addEventListener('resize', generateChristmasLights);
            
            // PÅ™edvyplnÄ›nÃ© hodnoty z Ãºkolu
            document.getElementById('insertValues').value = '50, 25, 41, 77, 12, 90, 63, 56, 53, 6, 95, 84, 99, 94';
            document.getElementById('removeValues').value = '53, 12, 77';
        };
    </script>
</body>
</html>
