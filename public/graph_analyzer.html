<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="utf-8">
    <title>Graph Analyzer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background-color: #f8f9fa;
            color: #212529;
        }
        h1, h2, h3 {
            color: #0d6efd;
        }
        textarea {
            width: 100%;
            max-width: 100%;
            min-height: 160px;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            font-family: monospace;
            margin-bottom: 1rem;
        }
        button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background-color: #0d6efd;
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            margin-bottom: 1rem;
            margin-right: 0.5rem;
        }
        button:hover {
            background-color: #0b5ed7;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 0.25rem 0.5rem;
            text-align: center;
        }
        th {
            background-color: #e9ecef;
        }
        .matrix {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        .section {
            margin-bottom: 2rem;
        }
        .properties span {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            padding: 0.25rem 0.5rem;
            background-color: #e2e3e5;
            border-radius: 0.25rem;
        }
        .query-section {
            background-color: #fff;
            padding: 1rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
        }
        .query-inputs {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .query-inputs select {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
        }
        .query-result {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: #e7f3ff;
            border-radius: 0.25rem;
            font-weight: bold;
        }
        .scrollable-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            padding: 0.5rem;
            background-color: #fff;
        }
        .degree-info {
            display: inline-block;
            margin-left: 0.5rem;
            color: #6c757d;
            font-size: 0.9em;
        }
        .optimal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1rem;
        }
        .result-box {
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            padding: 0.75rem;
            box-shadow: inset 0 0 0 rgba(0,0,0,0);
        }
        .result-label {
            font-weight: bold;
            color: #0d6efd;
            margin-bottom: 0.5rem;
        }

        /* V√°noƒçn√≠ svƒõt√Ωlka - Christmas Lights */
        .christmas-lights {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 1000;
            overflow: hidden;
            pointer-events: none;
        }

        .wire {
            position: absolute;
            top: 8px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                #2a2a2a 0%, #3a3a3a 50%, #2a2a2a 100%);
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .lights-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 10px;
        }

        .light {
            position: relative;
            width: 12px;
            height: 20px;
            margin-top: 8px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            animation: swing 2s ease-in-out infinite;
        }

        .light::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 8px;
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            border-radius: 2px 2px 0 0;
        }

        .light::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 8px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(1px);
        }

        .light.red {
            background: radial-gradient(ellipse at 30% 20%, #ff6b6b, #e63946);
            box-shadow: 0 0 15px 5px rgba(230, 57, 70, 0.6),
                        0 0 30px 10px rgba(230, 57, 70, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite, glow-red 1.5s ease-in-out infinite alternate;
        }

        .light.green {
            background: radial-gradient(ellipse at 30% 20%, #51cf66, #2d9e42);
            box-shadow: 0 0 15px 5px rgba(45, 158, 66, 0.6),
                        0 0 30px 10px rgba(45, 158, 66, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.3s, glow-green 1.5s ease-in-out infinite alternate 0.5s;
        }

        .light.blue {
            background: radial-gradient(ellipse at 30% 20%, #74c0fc, #339af0);
            box-shadow: 0 0 15px 5px rgba(51, 154, 240, 0.6),
                        0 0 30px 10px rgba(51, 154, 240, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.6s, glow-blue 1.5s ease-in-out infinite alternate 1s;
        }

        .light.yellow {
            background: radial-gradient(ellipse at 30% 20%, #ffe066, #fab005);
            box-shadow: 0 0 15px 5px rgba(250, 176, 5, 0.6),
                        0 0 30px 10px rgba(250, 176, 5, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.9s, glow-yellow 1.5s ease-in-out infinite alternate 1.5s;
        }

        .light.purple {
            background: radial-gradient(ellipse at 30% 20%, #da77f2, #be4bdb);
            box-shadow: 0 0 15px 5px rgba(190, 75, 219, 0.6),
                        0 0 30px 10px rgba(190, 75, 219, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 1.2s, glow-purple 1.5s ease-in-out infinite alternate 2s;
        }

        .light.orange {
            background: radial-gradient(ellipse at 30% 20%, #ffa94d, #fd7e14);
            box-shadow: 0 0 15px 5px rgba(253, 126, 20, 0.6),
                        0 0 30px 10px rgba(253, 126, 20, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.15s, glow-orange 1.5s ease-in-out infinite alternate 0.75s;
        }

        @keyframes swing {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        @keyframes glow-red {
            0% { box-shadow: 0 0 10px 3px rgba(230, 57, 70, 0.4), 0 0 20px 6px rgba(230, 57, 70, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(230, 57, 70, 0.8), 0 0 40px 15px rgba(230, 57, 70, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-green {
            0% { box-shadow: 0 0 10px 3px rgba(45, 158, 66, 0.4), 0 0 20px 6px rgba(45, 158, 66, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(45, 158, 66, 0.8), 0 0 40px 15px rgba(45, 158, 66, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-blue {
            0% { box-shadow: 0 0 10px 3px rgba(51, 154, 240, 0.4), 0 0 20px 6px rgba(51, 154, 240, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(51, 154, 240, 0.8), 0 0 40px 15px rgba(51, 154, 240, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-yellow {
            0% { box-shadow: 0 0 10px 3px rgba(250, 176, 5, 0.4), 0 0 20px 6px rgba(250, 176, 5, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(250, 176, 5, 0.8), 0 0 40px 15px rgba(250, 176, 5, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-purple {
            0% { box-shadow: 0 0 10px 3px rgba(190, 75, 219, 0.4), 0 0 20px 6px rgba(190, 75, 219, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(190, 75, 219, 0.8), 0 0 40px 15px rgba(190, 75, 219, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-orange {
            0% { box-shadow: 0 0 10px 3px rgba(253, 126, 20, 0.4), 0 0 20px 6px rgba(253, 126, 20, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(253, 126, 20, 0.8), 0 0 40px 15px rgba(253, 126, 20, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }
    </style>
</head>
<body>
<!-- V√°noƒçn√≠ svƒõt√Ωlka -->
<div class="christmas-lights">
    <div class="wire"></div>
    <div class="lights-container" id="lightsContainer"></div>
</div>
<div id="matrix-stats-tooltip" style="position: absolute; display: none; background-color: rgba(0,0,0,0.8); color: white; padding: 8px 12px; border-radius: 5px; pointer-events: none; z-index: 1000; font-size: 0.9em; line-height: 1.5;"></div>
<h1>Graph Analyzer</h1>
<p>Zadejte definici grafu ve form√°tu uveden√©m v zad√°n√≠. Ka≈æd√Ω uzel se definuje
pomoc√≠ ≈ô√°dku zaƒç√≠naj√≠c√≠ho <code>u</code> a ka≈æd√° hrana pomoc√≠ ≈ô√°dku zaƒç√≠naj√≠c√≠ho
<code>h</code>. Orientace hrany se urƒçuje ≈°ipkami <code>&lt;</code>, <code>&gt;</code> nebo
pomlƒçkou <code>-</code>. Ohodnocen√≠ je voliteln√©.</p>
<textarea id="graphInput">u A;
u B;
h A &gt; B 1 :h1;
u C;
h B &gt; C 1 :h2;
u D;
h A &gt; D 2 :h3;
u E;
h A &lt; E 2 :h4;
h B &lt; E 3 :h5;
h C &gt; E 3 :h6;
h D &gt; E 4 :h8;
u F;
h C &gt; F 4 :h7;
h E &gt; F 5 :h9;
u G;
h D &lt; G 5 :h10;
h E &gt; G 6 :h11;
u H;
h H &gt; E 6 :h12;
h F &gt; H 7 :h13;
h G &lt; H 7 :h14;</textarea>
<button id="parseBtn">Analyzovat graf</button>

<div id="counters" style="margin: 1rem 0; padding: 1rem; background-color: #e7f3ff; border: 1px solid #0d6efd; border-radius: 0.25rem; display: none;">
    <h3 style="margin-top: 0; color: #0d6efd;">üìä Z√°kladn√≠ statistiky</h3>
    <div style="display: flex; gap: 2rem; font-size: 1.1rem; flex-wrap: wrap;">
        <div><strong>Poƒçet uzl≈Ø:</strong> <span id="nodeCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
        <div><strong>Poƒçet hran:</strong> <span id="edgeCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
        <div><strong>Poƒçet komponent:</strong> <span id="componentCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
    </div>
    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #b6d4fe; font-size: 0.9rem; color: #084298;">
        üí° <strong>Komponenta</strong> = oddƒõlen√° ƒç√°st grafu (1 komponenta = graf je souvisl√Ω)
    </div>
</div>

<div id="output"></div>

<script>
// Graph analyzer with optimizations for large graphs
class Graph {
    constructor() {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        this._cachedProperties = null; // ‚ö° CACHE pro properties()
    }

    parse(text) {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        this._cachedProperties = null; // Invalidate cache on change

        const lines = text.split(/[;\r\n]+/);
        const nodePattern = /^u\s+([^\s;]+)(?:\s+([-+]?[0-9]*\.?[0-9]+))?/;
        const edgePattern = /^h\s+([^\s<>-]+)\s*([<>-])\s*([^\s<>-]+)\s*(?:([-+]?[0-9]*\.?[0-9]+))?\s*(?::([^;]+))?/;

        // First pass: add all nodes
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            let m;
            if ((m = nodePattern.exec(trimmed))) {
                const id = m[1];
                if (id === '*') continue;
                if (!this.nodes.includes(id)) {
                    this.nodes.push(id);
                    const weight = m[2] !== undefined ? parseFloat(m[2]) : null;
                    this.nodeWeights[id] = weight;
                }
            }
        }

        // Second pass: add all edges
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            let m;
            if ((m = edgePattern.exec(trimmed))) {
                const u = m[1];
                const direction = m[2];
                const v = m[3];
                // Ensure nodes exist before adding an edge
                if (this.nodes.includes(u) && this.nodes.includes(v)) {
                    const weight = m[4] !== undefined ? parseFloat(m[4]) : 1; // Default weight to 1
                    const label = m[5] ? m[5].trim() : null;
                    this.edges.push({ u, v, direction, weight, label });
                }
            }
        }
    }

    adjacencyMatrix(binary = false) {
        if (!binary && this._cachedAdjMatrix) return this._cachedAdjMatrix;
        
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const mat = Array.from({ length: n }, () => Array(n).fill(0));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                mat[i][j] += 1;
            } else if (e.direction === '<') {
                mat[j][i] += 1;
            } else {
                mat[i][j] += 1;
                mat[j][i] += 1;
            }
        }
        
        if (binary) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    mat[i][j] = mat[i][j] > 0 ? 1 : 0;
                }
            }
        } else {
            this._cachedAdjMatrix = mat;
        }
        
        return mat;
    }

    // Optimized: query single cell instead of computing full matrix
    adjacencyValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) count++;
            else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) count++;
            else if (e.direction === '-' && 
                     ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) count++;
        }
        return count;
    }

    lengthMatrix() {
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const INF = Infinity;
        const mat = Array.from({ length: n }, (_, i) => 
            Array.from({ length: n }, (__, j) => i === j ? 0 : INF));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                if (w < mat[i][j]) mat[i][j] = w;
            } else if (e.direction === '<') {
                if (w < mat[j][i]) mat[j][i] = w;
            } else {
                if (w < mat[i][j]) mat[i][j] = w;
                if (w < mat[j][i]) mat[j][i] = w;
            }
        }
        return mat;
    }

    // Optimized: query single cell
    lengthValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        if (nodeU === nodeV) return 0;
        
        let minWeight = Infinity;
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '-' && 
                       ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) {
                minWeight = Math.min(minWeight, w);
            }
        }
        return minWeight;
    }

    signMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const S = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                S[i][j] = A[i][j] - A[j][i];
            }
        }
        return S;
    }

    signValue(nodeU, nodeV) {
        const adjUV = this.adjacencyValue(nodeU, nodeV);
        const adjVU = this.adjacencyValue(nodeV, nodeU);
        if (adjUV === null || adjVU === null) return null;
        return adjUV - adjVU;
    }

    static multiplyMatrices(X, Y) {
        const n = X.length;
        const result = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let k = 0; k < n; k++) {
                if (X[i][k] === 0) continue;
                for (let j = 0; j < n; j++) {
                    if (Y[k][j] === 0) continue;
                    result[i][j] += X[i][k] * Y[k][j];
                }
            }
        }
        return result;
    }

    adjacencyPower(k) {
        let A = this.adjacencyMatrix();
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result;
    }

    // Optimized: compute power for specific cell
    adjacencyPowerValue(nodeU, nodeV, k) {
        const A = this.adjacencyMatrix();
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result[uIdx][vIdx];
    }

    // Laplacian matrix L = D - A
    laplacianMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const L = Array.from({ length: n }, () => Array(n).fill(0));
        
        // ‚ö° OPRAVA: Pro orientovan√© grafy pou≈æij OUT-degree!
        const props = this.properties();
        const isDirected = props.oriented === 'orientovan√Ω';
        
        // Compute degree for each node
        for (let i = 0; i < n; i++) {
            let degree = 0;
            
            if (isDirected) {
                // ‚úÖ OUT-degree pro orientovan√© (jen hrany ven)
                for (let j = 0; j < n; j++) {
                    degree += A[i][j]; // Souƒçet ≈ô√°dku = out-degree
                }
            } else {
                // ‚úÖ Celkov√Ω stupe≈à pro neorientovan√©
                for (let j = 0; j < n; j++) {
                    degree += A[i][j];
                }
            }
            
            L[i][i] = degree; // Diagonal: degree
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    L[i][j] = -A[i][j]; // Off-diagonal: -A[i][j]
                }
            }
        }
        return L;
    }

    // Get single value from Laplacian matrix
    laplacianValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        if (uIdx === vIdx) {
            // ‚ö° OPRAVA: Diagonal = out-degree pro orientovan√© grafy
            const props = this.properties();
            const isDirected = props.oriented === 'orientovan√Ω';
            
            let degree = 0;
            for (const e of this.edges) {
                if (isDirected) {
                    // ‚úÖ Poƒç√≠tej jen hrany VYCH√ÅZEJ√çC√ç z nodeU
                    if (e.direction === '>' && e.u === nodeU) degree++;
                    else if (e.direction === '<' && e.v === nodeU) degree++;
                    // Smyƒçka v orientovan√©m grafu
                    else if (e.direction === '-' && e.u === nodeU && e.v === nodeU) degree += 2;
                    else if (e.direction === '-' && (e.u === nodeU || e.v === nodeU)) degree++;
                } else {
                    // ‚úÖ Pro neorientovan√© poƒç√≠tej v≈°echny dot√Ωkaj√≠c√≠ se hrany
                    if (e.u === nodeU || e.v === nodeU) {
                        if (e.u === e.v) degree += 2; // Loop counts twice
                        else degree += 1;
                    }
                }
            }
            return degree;
        } else {
            // Off-diagonal: -A[i][j]
            return -this.adjacencyValue(nodeU, nodeV);
        }
    }

    // Sum of all walks from length 1 to k
    sumWalksValue(nodeU, nodeV, k) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        const A = this.adjacencyMatrix();
        let sum = 0;
        let currentPower = A;
        
        for (let i = 1; i <= k; i++) {
            sum += currentPower[uIdx][vIdx];
            if (i < k) {
                currentPower = Graph.multiplyMatrices(currentPower, A);
            }
        }
        return sum;
    }

    // Multiplicity: count all edges between U and V (regardless of direction for undirected)
    multiplicityValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            // Count all edges connecting these two nodes
            if ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU)) {
                count++;
            }
        }
        return count;
    }

    // Reachability matrix (transitive closure)
    reachability() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const R = A.map(row => row.map(v => v > 0 ? 1 : 0));
        
        // Floyd-Warshall on binary matrix
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                if (R[i][k] === 1) {
                    for (let j = 0; j < n; j++) {
                        if (R[k][j] === 1) R[i][j] = 1;
                    }
                }
            }
        }
        return R;
    }

    // BFS Layers from start node
    bfsLayers(startNode) {
        const idx = this.nodes.indexOf(startNode);
        if (idx === -1) return {};
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const layers = { 0: [startNode] };
        const seen = new Set([idx]);
        let frontier = [idx];
        let k = 0;
        
        while (frontier.length) {
            const next = [];
            for (const u of frontier) {
                for (const v of adjList[u]) {
                    if (!seen.has(v)) {
                        seen.add(v);
                        next.push(v);
                    }
                }
            }
            if (!next.length) break;
            k++;
            layers[k] = next.map(i => this.nodes[i]).sort();
            frontier = next;
        }
        return layers;
    }

    // All shortest paths (unweighted BFS)
    allShortestPathsUnweighted(src, dst) {
        const srcIdx = this.nodes.indexOf(src);
        const dstIdx = this.nodes.indexOf(dst);
        if (srcIdx === -1 || dstIdx === -1) return [];
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list (outgoing edges)
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const dist = Array(n).fill(Infinity);
        dist[srcIdx] = 0;
        const parents = Array.from({ length: n }, () => []);
        const queue = [srcIdx];
        
        while (queue.length) {
            const u = queue.shift();
            for (const v of adjList[u]) {
                if (dist[v] === Infinity) {
                    dist[v] = dist[u] + 1;
                    parents[v].push(u);
                    queue.push(v);
                } else if (dist[v] === dist[u] + 1) {
                    parents[v].push(u);
                }
            }
        }
        
        if (dist[dstIdx] === Infinity) return [];
        
        // Reconstruct all paths
        const paths = [];
        const stack = [dstIdx];
        
        const reconstruct = (v) => {
            if (v === srcIdx) {
                paths.push(stack.slice().reverse().map(i => this.nodes[i]));
                return;
            }
            for (const p of parents[v]) {
                stack.push(p);
                reconstruct(p);
                stack.pop();
            }
        };
        
        reconstruct(dstIdx);
        return paths;
    }

    // Simple paths up to length K (no repeated nodes)
    simplePathsUpTo(srcNode, dstNode, K = null, cap = 10000) {
        const srcIdx = this.nodes.indexOf(srcNode);
        const dstIdx = this.nodes.indexOf(dstNode);
        if (srcIdx === -1 || dstIdx === -1) return { count: 0, paths: [] };
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const maxLen = (K === null) ? (n - 1) : K;
        const paths = [];
        let count = 0;
        const visited = new Set();
        
        const dfs = (u, depth, acc) => {
            if (count >= cap) return;
            if (u === dstIdx) {
                paths.push(acc.map(i => this.nodes[i]));
                count++;
                return;
            }
            if (depth === 0) return;
            
            for (const w of adjList[u]) {
                if (visited.has(w)) continue;
                visited.add(w);
                acc.push(w);
                dfs(w, depth - 1, acc);
                acc.pop();
                visited.delete(w);
            }
        };
        
        visited.add(srcIdx);
        dfs(srcIdx, maxLen, [srcIdx]);
        visited.delete(srcIdx);
        
        return { count, paths };
    }

    // Neighbor sets by direction
    neighborSets(nodeU) {
        const out = new Set();
        const inn = new Set();
        const und = new Set();
        
        for (const e of this.edges) {
            if (e.direction === '>') {
                if (e.u === nodeU) out.add(e.v);
                if (e.v === nodeU) inn.add(e.u);
            } else if (e.direction === '<') {
                if (e.v === nodeU) out.add(e.u);
                if (e.u === nodeU) inn.add(e.v);
            } else {
                if (e.u === nodeU) und.add(e.v);
                if (e.v === nodeU) und.add(e.u);
            }
        }
        
        return {
            out: [...out].sort(),
            inn: [...inn].sort(),
            und: [...und].sort()
        };
    }

    incidenceMatrix(signed = true) {
        const n = this.nodes.length;
        const m = this.edges.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const inc = Array.from({ length: n }, () => Array(m).fill(0));
        
        this.edges.forEach((e, ci) => {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                if (signed) {
                    inc[i][ci] = -1;
                    inc[j][ci] = 1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else if (e.direction === '<') {
                if (signed) {
                    inc[j][ci] = 1;
                    inc[i][ci] = -1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else {
                inc[i][ci] = 1;
                inc[j][ci] = 1;
            }
        });
        return inc;
    }

    floydWarshall() {
        const n = this.nodes.length;
        const dist = this.lengthMatrix().map(row => row.slice());
        const pred = Array.from({ length: n }, () => Array(n).fill(null));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    pred[i][j] = i;
                }
            }
        }
        
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const alt = dist[i][k] + dist[k][j];
                    if (alt < dist[i][j]) {
                        dist[i][j] = alt;
                        pred[i][j] = pred[k][j];
                    }
                }
            }
        }
        return { dist, pred };
    }

    // Optimized: compute shortest path for specific pair
    shortestPath(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        // Simple Dijkstra for single source-target
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const visited = Array(n).fill(false);
        const pred = Array(n).fill(null);
        dist[uIdx] = 0;
        
        for (let count = 0; count < n; count++) {
            let minDist = Infinity;
            let u = -1;
            for (let i = 0; i < n; i++) {
                if (!visited[i] && dist[i] < minDist) {
                    minDist = dist[i];
                    u = i;
                }
            }
            if (u === -1 || u === vIdx) break;
            visited[u] = true;
            
            for (const e of this.edges) {
                const w = e.weight !== null ? e.weight : 1;
                let vNeighbor = -1;
                if (e.direction === '>' && e.u === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.v);
                } else if (e.direction === '<' && e.v === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.u);
                } else if (e.direction === '-') {
                    if (e.u === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.v);
                    else if (e.v === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.u);
                }
                
                if (vNeighbor !== -1 && !visited[vNeighbor]) {
                    const alt = dist[u] + w;
                    if (alt < dist[vNeighbor]) {
                        dist[vNeighbor] = alt;
                        pred[vNeighbor] = u;
                    }
                }
            }
        }
        
        // Reconstruct path
        const path = [];
        if (dist[vIdx] < Infinity) {
            let current = vIdx;
            while (current !== null) {
                path.unshift(this.nodes[current]);
                current = pred[current];
            }
        }
        
        return {
            distance: dist[vIdx],
            predecessor: pred[vIdx] !== null ? this.nodes[pred[vIdx]] : null,
            path: path
        };
    }

    incidentEdges() {
        const map = {};
        this.nodes.forEach(id => { map[id] = []; });
        this.edges.forEach(e => {
            const desc = e.label ? e.label : `${e.u}${e.direction}${e.v}`;
            map[e.u].push(desc);
            map[e.v].push(desc);
        });
        return map;
    }

    neighbours() {
        const map = {};
        this.nodes.forEach(id => { map[id] = new Set(); });
        this.edges.forEach(e => {
            map[e.u].add(e.v);
            map[e.v].add(e.u);
        });
        const result = {};
        for (const id of this.nodes) {
            result[id] = Array.from(map[id]);
        }
        return result;
    }

    // Compute and cache degrees
    degrees() {
        if (this._cachedDegrees) return this._cachedDegrees;
        
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            if (e.u === e.v) {
                degrees[e.u] += 2;
            } else {
                degrees[e.u] += 1;
                degrees[e.v] += 1;
            }
        }
        this._cachedDegrees = degrees;
        return degrees;
    }

    // Check if directed graph is strongly connected using Kosaraju's algorithm
    // ‚ö° VYLEP≈†EN√ç 12: Optimalizovan√° strongly connected detection
    isStronglyConnected() {
        const n = this.nodes.length;
        if (n === 0) return true;
        if (n === 1) return true; // ‚ö° Single node is trivially strongly connected
        
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        
        // ‚ö° Build adjacency list AND reverse graph v jednom pr≈Øchodu!
        const adjList = Array.from({ length: n }, () => []);
        const reverseAdj = Array.from({ length: n }, () => []);
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                adjList[i].push(j);
                reverseAdj[j].push(i); // ‚ö° Build reverse souƒçasnƒõ
            } else if (e.direction === '<') {
                adjList[j].push(i);
                reverseAdj[i].push(j);
            } else {
                // Undirected edge - add both directions
                adjList[i].push(j);
                adjList[j].push(i);
                reverseAdj[i].push(j);
                reverseAdj[j].push(i);
            }
        }
        
        // DFS from first node - inline pro rychlost
        const visited = new Array(n).fill(false);
        const stack = [0];
        visited[0] = true;
        let count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of adjList[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        if (count !== n) return false; // ‚ö° Early exit
        
        // DFS on reverse graph - ji≈æ m√°me reverseAdj!
        visited.fill(false);
        stack.length = 0; // ‚ö° Reuse array
        stack.push(0);
        visited[0] = true;
        count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of reverseAdj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        return count === n;
    }

    // ‚ö° VYLEP≈†EN√ç 14: Poƒç√≠t√°n√≠ komponent grafu (slab√© komponenty)
    countComponents() {
        const n = this.nodes.length;
        if (n === 0) return 0;
        
        const visited = new Set();
        let components = 0;
        
        // Build adjacency list (ignoruj orientaci hran)
        const adj = {};
        this.nodes.forEach(id => adj[id] = new Set());
        for (const e of this.edges) {
            adj[e.u].add(e.v);
            adj[e.v].add(e.u); // Obousmƒõrnƒõ pro slab√© komponenty
        }
        
        // BFS pro ka≈ædou komponentu
        for (const start of this.nodes) {
            if (visited.has(start)) continue;
            
            components++;
            const queue = [start];
            visited.add(start);
            
            while (queue.length) {
                const u = queue.shift();
                for (const v of adj[u]) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                    }
                }
            }
        }
        
        return components;
    }
    
    // Vrac√≠ detailn√≠ informace o komponent√°ch (reprezentant + seznam uzl≈Ø)
    getComponents() {
        const n = this.nodes.length;
        if (n === 0) return [];
        
        const visited = new Set();
        const components = [];
        
        // Build adjacency list (ignoruj orientaci hran)
        const adj = {};
        this.nodes.forEach(id => adj[id] = new Set());
        for (const e of this.edges) {
            adj[e.u].add(e.v);
            adj[e.v].add(e.u); // Obousmƒõrnƒõ pro slab√© komponenty
        }
        
        // BFS pro ka≈ædou komponentu
        for (const start of this.nodes) {
            if (visited.has(start)) continue;
            
            const componentNodes = [];
            const queue = [start];
            visited.add(start);
            componentNodes.push(start);
            
            while (queue.length) {
                const u = queue.shift();
                for (const v of adj[u]) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                        componentNodes.push(v);
                    }
                }
            }
            
            components.push({
                root: start,  // Prvn√≠ nalezen√Ω uzel (reprezentant)
                nodes: componentNodes.sort(),
                size: componentNodes.length
            });
        }
        
        return components.sort((a, b) => b.size - a.size); // Se≈ôaƒè podle velikosti
    }

    // Find all multiple edges in the graph
    findMultipleEdges() {
        const edgeMap = new Map();
        const multipleEdges = [];
        
        for (const e of this.edges) {
            // Create key based on nodes and direction
            let key;
            if (e.direction === '>') {
                key = `${e.u}>${e.v}`;
            } else if (e.direction === '<') {
                key = `${e.v}>${e.u}`;
            } else {
                // For undirected edges, normalize the key
                key = e.u <= e.v ? `${e.u}-${e.v}` : `${e.v}-${e.u}`;
            }
            
            if (!edgeMap.has(key)) {
                edgeMap.set(key, []);
            }
            edgeMap.get(key).push(e);
        }
        
        // Find groups with multiple edges
        for (const [key, edges] of edgeMap.entries()) {
            if (edges.length > 1) {
                multipleEdges.push({
                    key: key,
                    count: edges.length,
                    edges: edges
                });
            }
        }
        
        return multipleEdges;
    }

    
    properties() {
        // ‚ö° VYLEP≈†EN√ç 10: Memoizace properties() - obrovsk√Ω speedup!
        if (this._cachedProperties) return this._cachedProperties;
        
        const props = {};
        const n = this.nodes.length;
        
        // Weighted: any edge weight specified and different from 1, or any node has weight
        let weightedEdge = false;
        for (const e of this.edges) {
            if (e.weight !== null && e.weight !== undefined && e.weight !== 1) {
                weightedEdge = true;
                break;
            }
        }
        let weightedNode = false;
        for (const id of this.nodes) {
            const w = this.nodeWeights[id];
            if (w !== null && w !== undefined) {
                weightedNode = true;
                break;
            }
        }
        props.weighted = weightedEdge || weightedNode;
        
        // Orientation: determine if graph is directed, undirected or mixed
        let hasDirected = false;
        let hasUndirected = false;
        for (const e of this.edges) {
            if (e.direction === '-' || e.direction === '‚Äì') hasUndirected = true;
            else hasDirected = true;
        }
        if (hasDirected && !hasUndirected) props.oriented = 'orientovan√Ω';
        else if (!hasDirected && hasUndirected) props.oriented = 'neorientovan√Ω';
        else props.oriented = 'sm√≠≈°en√Ω';
        
        // Connectivity: BFS on underlying undirected graph
        const visited = new Array(n).fill(false);
        if (n > 0) {
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            const neighbours = this.neighbours();
            const queue = [0];
            visited[0] = true;
            while (queue.length > 0) {
                const i = queue.shift();
                const u = this.nodes[i];
                for (const v of neighbours[u]) {
                    const j = idx[v];
                    if (!visited[j]) {
                        visited[j] = true;
                        queue.push(j);
                    }
                }
            }
        }
        props.connected = visited.every(v => v);
        
        // ‚ö° OPRAVA: Strong a weak connectivity pro orientovan√© grafy
        // Pokud je silnƒõ souvisl√Ω ‚Üí automaticky slabƒõ souvisl√Ω (zobraz√≠me jen "silnƒõ")
        // Pokud nen√≠ silnƒõ, ale je weakly ‚Üí zobraz√≠me "slabƒõ"
        if (props.oriented === 'orientovan√Ω') {
            props.stronglyConnected = this.isStronglyConnected();
            // Weakly connected = connected v podkladov√©m neorientovan√©m grafu
            // ALE zobraz√≠me jen pokud nen√≠ strongly connected
            props.weaklyConnected = !props.stronglyConnected && props.connected;
        }
        
        // Finite: always true for parsed input
        props.finite = true;
        
        // ‚ö° VYLEP≈†EN√ç 11: Loops + multiple edges + degrees v JEDNOM pr≈Øchodu
        let loops = 0;
        const edgeSet = new Set();
        let multiEdges = false;
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            // Poƒç√≠tej stupnƒõ souƒçasnƒõ
            if (e.u === e.v) {
                loops++;
                degrees[e.u] += 2; // Smyƒçka p≈ôid√° stupe≈à 2
                continue;
            }
            
            degrees[e.u] += 1;
            degrees[e.v] += 1;
            
            // Check multiple edges
            const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
            if (edgeSet.has(key)) {
                multiEdges = true;
                // Nekonƒç√≠me - mus√≠me dopoƒç√≠tat degrees!
            } else {
                edgeSet.add(key);
            }
        }
        
        props.prosty = !multiEdges;
        props.jednoduchy = !multiEdges && loops === 0;
        
        // ‚ö° NOV√â: Multigraf (existuj√≠ n√°sobn√© hrany)
        props.multigraph = multiEdges;
        
        // ‚ö° NOV√â: Diskr√©tn√≠ graf (≈æ√°dn√© hrany)
        props.discrete = this.edges.length === 0;
        
        // ‚ö° VYLEP≈†EN√ç 13: Complete graph - vyu≈æij u≈æ existuj√≠c√≠ edgeSet!
        if (n > 50) {
            props.complete = false;
        } else {
            // edgeSet u≈æ m√°me z v√Ωpoƒçtu multiple edges v√Ω≈°e!
            const expectedEdges = (n * (n - 1)) / 2;
            props.complete = (edgeSet.size === expectedEdges) && !multiEdges && loops === 0;
        }
        
        // ‚ö° Regular: degrees u≈æ m√°me spoƒç√≠tan√© v√Ω≈°e!
        const degValues = Object.values(degrees);
        const firstDeg = degValues[0];
        props.regular = degValues.every(d => d === firstDeg);
        
        // Bipartite: OPTIMIZED - early exit on odd cycle
        props.bipartite = (() => {
            if (n === 0) return true;
            const colours = new Array(n).fill(-1);
            const neighbours = this.neighbours();
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            
            for (let start = 0; start < n; start++) {
                if (colours[start] !== -1) continue;
                const queue = [start];
                colours[start] = 0;
                
                while (queue.length > 0) {
                    const uIdx = queue.shift();
                    const u = this.nodes[uIdx];
                    const currentColour = colours[uIdx];
                    
                    for (const v of neighbours[u]) {
                        const vIdx = idx[v];
                        if (colours[vIdx] === -1) {
                            colours[vIdx] = 1 - currentColour;
                            queue.push(vIdx);
                        } else if (colours[vIdx] === currentColour) {
                            return false;
                        }
                    }
                }
            }
            return true;
        })();
        
        // Planar: OPTIMIZED for ALL graph sizes using fast heuristics
        props.planar = (() => {
            // Count unique undirected edges efficiently
            const uniqueEdges = new Set();
            for (const e of this.edges) {
                const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
                uniqueEdges.add(key);
            }
            const m = uniqueEdges.size;
            
            // Trivial cases
            if (n <= 4) return true;
            if (m === 0) return true;
            if (m <= 1) return true; // ‚ö° Single edge is always planar
            
            // ‚ö° VYLEP≈†EN√ç 1: P≈ôesnƒõj≈°√≠ Eulerova formule pro nesouvisl√© grafy
            // Pro nesouvisl√Ω graf: m ‚â§ 3n - 6k, kde k = poƒçet komponent
            if (props.prosty) {
                // Poƒçet komponent pomoc√≠ BFS
                const visited = new Set();
                let components = 0;
                const adj = {};
                this.nodes.forEach(id => adj[id] = new Set());
                for (const e of this.edges) {
                    adj[e.u].add(e.v);
                    adj[e.v].add(e.u);
                }
                
                for (const start of this.nodes) {
                    if (visited.has(start)) continue;
                    components++;
                    const queue = [start];
                    visited.add(start);
                    while (queue.length) {
                        const u = queue.shift();
                        for (const v of adj[u]) {
                            if (!visited.has(v)) {
                                visited.add(v);
                                queue.push(v);
                            }
                        }
                    }
                }
                
                // Eulerova formule: m ‚â§ 3n - 6k (pro k komponent)
                if (m > 3 * n - 6 * components) {
                    return false;
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 2: Zp≈ôesnƒõn√≠ pro bipartitn√≠ grafy
            if (props.bipartite) {
                // Pro bipartitn√≠ graf: m ‚â§ 2n - 4 (pokud souvisl√Ω)
                // Pro nesouvisl√Ω: pou≈æij podobnou formuli jako v√Ω≈°e
                if (props.connected && m > 2 * n - 4) {
                    return false;
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 3: Kontrola pr≈Ømƒõrn√©ho stupnƒõ (zp≈ôesnƒõn√≠)
            const avgDegree = (2 * m) / n;
            if (avgDegree > 6) { // Zmƒõna z >= na > (6.0 je je≈°tƒõ mo≈æn√©)
                return false;
            }
            
            // ‚ö° VYLEP≈†EN√ç 4: Kontrola maxim√°ln√≠ho stupnƒõ
            // Rovinn√Ω graf nem≈Ø≈æe m√≠t uzel se stupnƒõm > 5 u mal√Ωch graf≈Ø
            const maxDegree = Math.max(...Object.values(degrees));
            if (n <= 10 && maxDegree > n - 1) {
                // Pokud m√° uzel stupe≈à n-1, je to hvƒõzda ‚Üí rovinn√©
                // Jinak pokraƒçuj v kontrol√°ch
            }
            
            // ‚ö° VYLEP≈†EN√ç 5: Speci√°ln√≠ p≈ô√≠pady - stromy a lesy
            if (m === n - 1 && props.connected) {
                return true; // Strom je v≈ædy rovinn√Ω!
            }
            if (m < n) {
                return true; // Les (m < n) je v≈ædy rovinn√Ω!
            }
            
            // ‚ö° VYLEP≈†EN√ç 6: Optimalizovan√° detekce K5 s lep≈°√≠m targeting
            if (n >= 5 && m >= 10) {
                // K5 pot≈ôebuje 10 hran mezi 5 uzly
                // Nejprve najdi uzly s vysok√Ωm stupnƒõm (‚â•4)
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 4) { // K5 m√° v≈°echny uzly se stupnƒõm 4
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                // Zkontroluj jen high-degree uzly (v√Ωraznƒõ rychlej≈°√≠!)
                if (highDegreeNodes.length >= 5) {
                    const maxSamples = Math.min(50, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        // Random sampling z high-degree uzl≈Ø
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 5);
                        
                        let isK5 = true;
                        let edgeCount = 0;
                        
                        // Check if these 5 nodes form K5
                        for (let i = 0; i < 5 && isK5; i++) {
                            for (let j = i + 1; j < 5; j++) {
                                const u = candidateNodes[i];
                                const v = candidateNodes[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgeCount++;
                                } else {
                                    isK5 = false;
                                    break;
                                }
                            }
                        }
                        
                        // K5 m√° p≈ôesnƒõ 10 hran
                        if (isK5 && edgeCount === 10) return false;
                    }
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 7: Optimalizovan√° detekce K3,3 s bipartitn√≠ anal√Ωzou
            if (n >= 6 && m >= 9) {
                // K3,3 pot≈ôebuje 9 hran a je bipartitn√≠
                // Pokud graf nen√≠ bipartitn√≠, zkontroluj subgrafy
                
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 3) { // K3,3 m√° v≈°echny uzly se stupnƒõm p≈ôesnƒõ 3
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                if (highDegreeNodes.length >= 6) {
                    const maxSamples = Math.min(30, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 6);
                        
                        // ‚ö° Optimalizace: Zkus jen logick√© partitiony
                        // Nam√≠sto v≈°ech 2^6 = 64 kombinac√≠, zkus jen validn√≠
                        const partitions = [
                            [[0,1,2], [3,4,5]],
                            [[0,1,3], [2,4,5]],
                            [[0,1,4], [2,3,5]],
                            [[0,1,5], [2,3,4]],
                            [[0,2,3], [1,4,5]],
                            [[0,2,4], [1,3,5]],
                            [[0,2,5], [1,3,4]],
                            [[0,3,4], [1,2,5]],
                            [[0,3,5], [1,2,4]],
                            [[0,4,5], [1,2,3]]
                        ];
                        
                        for (const [setAIdx, setBIdx] of partitions) {
                            const setA = setAIdx.map(i => candidateNodes[i]);
                            const setB = setBIdx.map(i => candidateNodes[i]);
                            
                            // Check if complete bipartite
                            let isK33 = true;
                            let edgeCount = 0;
                            
                            // Kontroluj jen hrany mezi mno≈æinami (ne uvnit≈ô!)
                            for (const ua of setA) {
                                for (const vb of setB) {
                                    const key = ua <= vb ? `${ua}|${vb}` : `${vb}|${ua}`;
                                    if (uniqueEdges.has(key)) {
                                        edgeCount++;
                                    } else {
                                        isK33 = false;
                                        break;
                                    }
                                }
                                if (!isK33) break;
                            }
                            
                            // K3,3 m√° p≈ôesnƒõ 9 hran a ≈æ√°dn√© hrany uvnit≈ô mno≈æin
                            if (isK33 && edgeCount === 9) {
                                // Ovƒõ≈ô, ≈æe nejsou hrany uvnit≈ô setA a setB
                                let hasInternalEdge = false;
                                for (let i = 0; i < 3; i++) {
                                    for (let j = i + 1; j < 3; j++) {
                                        const keyA = setA[i] <= setA[j] ? `${setA[i]}|${setA[j]}` : `${setA[j]}|${setA[i]}`;
                                        const keyB = setB[i] <= setB[j] ? `${setB[i]}|${setB[j]}` : `${setB[j]}|${setB[i]}`;
                                        if (uniqueEdges.has(keyA) || uniqueEdges.has(keyB)) {
                                            hasInternalEdge = true;
                                            break;
                                        }
                                    }
                                    if (hasInternalEdge) break;
                                }
                                
                                if (!hasInternalEdge) return false; // K3,3 found!
                            }
                        }
                    }
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 8: Kontrola hustoty subgraf≈Ø
            // Rovinn√Ω graf nem≈Ø≈æe obsahovat "lok√°lnƒõ hust√Ω" subgraf
            if (n >= 10 && m >= 20) {
                // Vyber n√°hodn√© uzly a kontroluj jejich okol√≠
                const samples = Math.min(10, n);
                for (let s = 0; s < samples; s++) {
                    const centerIdx = Math.floor(Math.random() * n);
                    const center = this.nodes[centerIdx];
                    
                    // Najdi sousedy centra
                    const neighbors = new Set();
                    for (const e of this.edges) {
                        if (e.u === center) neighbors.add(e.v);
                        if (e.v === center) neighbors.add(e.u);
                    }
                    
                    if (neighbors.size >= 6) {
                        // Spoƒç√≠tej hrany mezi sousedy
                        const neighborsList = Array.from(neighbors);
                        let edgesInNeighborhood = 0;
                        for (let i = 0; i < neighborsList.length; i++) {
                            for (let j = i + 1; j < neighborsList.length; j++) {
                                const u = neighborsList[i];
                                const v = neighborsList[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgesInNeighborhood++;
                                }
                            }
                        }
                        
                        // Pokud m√° okol√≠ p≈ô√≠li≈° mnoho hran, nen√≠ rovinn√Ω
                        const k = neighbors.size;
                        const maxEdgesInNeighborhood = 3 * k - 6;
                        if (edgesInNeighborhood > maxEdgesInNeighborhood) {
                            return false;
                        }
                    }
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 9: Zp≈ôesnƒõn√≠ odpovƒõdi podle jistoty
            if (n > 100) {
                // Pro velmi velk√© grafy pou≈æij disclaimer
                return 'pravdƒõpodobnƒõ ano (heuristika)';
            } else if (n > 50 && (m > 2.5 * n)) {
                // Pro st≈ôednƒõ velk√© hust≈°√≠ grafy buƒè opatrnƒõj≈°√≠
                return 'pravdƒõpodobnƒõ ano (heuristika)';
            } else if (m <= n + 3) {
                // ≈ò√≠dk√© grafy (m ‚â§ n+3) jsou t√©mƒõ≈ô jistƒõ rovinn√©
                return true;
            }
            
            return true;
        })();
        
        // ‚ö° NOV√â: Symetrizace (v≈°echny orientovan√© hrany maj√≠ i opaƒçnou hranu)
        props.symmetric = (() => {
            if (!props.oriented) return true; // Neorientovan√Ω graf je v≈ædy symetrick√Ω
            
            // Pro orientovan√© grafy: kontrola, ≈æe ka≈æd√° hrana m√° protƒõj≈°ek
            for (const e of this.edges) {
                if (e.direction === '-') continue; // Neorientovan√© hrany ignoruj
                
                // Hledej opaƒçnou hranu
                const oppositeExists = this.edges.some(e2 => 
                    e2.u === e.v && e2.v === e.u && (e2.direction === '<' || e2.direction === '>' || e2.direction === '-')
                );
                
                if (!oppositeExists) {
                    return false; // Na≈°li jsme hranu bez protƒõj≈°ku
                }
            }
            return true;
        })();
        
        // ‚ö° Cachuj v√Ωsledek pro budouc√≠ vol√°n√≠
        this._cachedProperties = props;
        return props;
    }

    // üìä Kompletn√≠ statistick√Ω p≈ôehled grafu
    getStatistics() {
        const stats = {};
        const n = this.nodes.length;
        const m = this.edges.length;
        
        // Z√°kladn√≠ poƒçty
        stats.nodeCount = n;
        stats.edgeCount = m;
        stats.componentCount = this.countComponents();
        
        // Stupnƒõ uzl≈Ø
        const degrees = this.degrees();
        const degreeValues = Object.values(degrees);
        stats.degrees = {
            min: Math.min(...degreeValues),
            max: Math.max(...degreeValues),
            avg: degreeValues.reduce((a, b) => a + b, 0) / n,
            median: this._median(degreeValues),
            distribution: this._degreeDistribution(degreeValues)
        };
        
        // ‚ö° NOV√â: Pro orientovan√© grafy p≈ôidej IN/OUT stupnƒõ
        const props = this.properties();
        if (props.oriented === 'orientovan√Ω') {
            const inDegrees = {};
            const outDegrees = {};
            this.nodes.forEach(id => { inDegrees[id] = 0; outDegrees[id] = 0; });
            
            for (const e of this.edges) {
                if (e.direction === '>') {
                    outDegrees[e.u]++;
                    inDegrees[e.v]++;
                } else if (e.direction === '<') {
                    inDegrees[e.u]++;
                    outDegrees[e.v]++;
                }
            }
            
            const inValues = Object.values(inDegrees);
            const outValues = Object.values(outDegrees);
            
            stats.inDegrees = {
                min: Math.min(...inValues),
                max: Math.max(...inValues),
                avg: inValues.reduce((a, b) => a + b, 0) / n
            };
            
            stats.outDegrees = {
                min: Math.min(...outValues),
                max: Math.max(...outValues),
                avg: outValues.reduce((a, b) => a + b, 0) / n
            };
        }
        
        // Izolovan√© uzly (stupe≈à 0)
        stats.isolatedNodes = this.nodes.filter(id => degrees[id] === 0);

        // Rozklad hran podle typu (orientovan√© / neorientovan√© / smyƒçky)
        const edgeBreakdown = this.edges.reduce((acc, edge) => {
            const isLoop = edge.u === edge.v;
            if (isLoop) {
                acc.loops++;
            } else if (edge.direction === '-') {
                acc.undirected++;
            } else {
                acc.directed++;
            }
            return acc;
        }, { directed: 0, undirected: 0, loops: 0 });

        // Smyƒçky (self-loops)
        stats.loops = edgeBreakdown.loops;
        
        // N√°sobn√© hrany
        const multipleEdges = this.findMultipleEdges();
        stats.multipleEdgeGroups = multipleEdges.length;
        stats.totalMultipleEdges = multipleEdges.reduce((sum, g) => sum + g.count, 0);
        
        // Hustota grafu (0 = ≈ô√≠dk√Ω, 1 = √∫pln√Ω) s ohledem na orientovan√©/mixovan√© hrany a smyƒçky
        const pairCount = n > 1 ? n * (n - 1) : 0;
        let maxDirectedCapacity = 0;
        let maxUndirectedCapacity = 0;

        // Pokud graf obsahuje nebo umo≈æ≈àuje orientovan√© hrany, uva≈æuj n*(n-1) mo≈ænost√≠
        if ((props.oriented === 'orientovan√Ω' || props.oriented === 'sm√≠≈°en√Ω') && pairCount > 0) {
            maxDirectedCapacity = pairCount;
        } else if (edgeBreakdown.directed > 0 && pairCount > 0) {
            maxDirectedCapacity = pairCount;
        }

        // Pokud graf obsahuje nebo umo≈æ≈àuje neorientovan√© hrany, uva≈æuj n*(n-1)/2 mo≈ænost√≠
        if ((props.oriented === 'neorientovan√Ω' || props.oriented === 'sm√≠≈°en√Ω') && pairCount > 0) {
            maxUndirectedCapacity = pairCount / 2;
        } else if (edgeBreakdown.undirected > 0 && pairCount > 0) {
            maxUndirectedCapacity = pairCount / 2;
        }

        // Smyƒçky ‚Äì maxim√°lnƒõ jedna smyƒçka na uzel pro normalizaci
        const maxLoopCapacity = edgeBreakdown.loops > 0 ? n : 0;

        const densityDenominator = maxDirectedCapacity + maxUndirectedCapacity + maxLoopCapacity;
        stats.density = densityDenominator > 0 ? Math.min(1, m / densityDenominator) : 0;
        stats.densityModel = {
            directedSlots: maxDirectedCapacity,
            undirectedSlots: maxUndirectedCapacity,
            loopSlots: maxLoopCapacity,
            usedDirected: edgeBreakdown.directed,
            usedUndirected: edgeBreakdown.undirected,
            usedLoops: edgeBreakdown.loops
        };
        
        // Pr≈Ømƒõr a polomƒõr grafu (pokud je souvisl√Ω a ne moc velk√Ω)
        if (n > 0 && n <= 100 && this.properties().connected) {
            const diameterInfo = this._computeDiameterAndRadius();
            stats.diameter = diameterInfo.diameter;
            stats.radius = diameterInfo.radius;
            stats.centerNodes = diameterInfo.centerNodes;
            stats.peripheralNodes = diameterInfo.peripheralNodes;
        } else {
            stats.diameter = null;
            stats.radius = null;
        }
        
        // Komponenty
        const components = this.getComponents();
        if (components.length > 0) {
            stats.largestComponent = Math.max(...components.map(c => c.size));
            stats.smallestComponent = Math.min(...components.map(c => c.size));
            stats.componentSizes = components.map(c => c.size).sort((a, b) => b - a);
        }
        
        // Orientace hran
        let directedCount = 0;
        let undirectedCount = 0;
        for (const e of this.edges) {
            if (e.direction === '-') undirectedCount++;
            else directedCount++;
        }
        stats.directedEdges = directedCount;
        stats.undirectedEdges = undirectedCount;
        
        // Ohodnocen√≠
        stats.weightedEdges = this.edges.filter(e => e.weight !== null && e.weight !== undefined).length;
        stats.weightedNodes = this.nodes.filter(id => this.nodeWeights[id] !== null && this.nodeWeights[id] !== undefined).length;

        // Edge weight stats
        if (stats.weightedEdges > 0) {
            const weights = this.edges.map(e => e.weight).filter(w => w !== null && w !== undefined);
            stats.edgeWeights = {
                min: Math.min(...weights),
                max: Math.max(...weights),
                avg: weights.reduce((a, b) => a + b, 0) / weights.length,
                distribution: weights.reduce((acc, val) => {
                    acc[val] = (acc[val] || 0) + 1;
                    return acc;
                }, {})
            };
        }

        // ‚ö° NOV√â: Statistiky nejdel≈°√≠ch a nejkrat≈°√≠ch hran
        if (this.edges.length > 0) {
            let shortestEdge = null;
            let longestEdge = null;
            let minWeight = Infinity;
            let maxWeight = -Infinity;

            for (const edge of this.edges) {
                const weight = edge.weight !== null && edge.weight !== undefined ? edge.weight : 1;
                if (weight < minWeight) {
                    minWeight = weight;
                    shortestEdge = edge;
                }
                if (weight > maxWeight) {
                    maxWeight = weight;
                    longestEdge = edge;
                }
            }
            stats.shortestEdge = shortestEdge;
            stats.longestEdge = longestEdge;
        }
        
        return stats;
    }

    _median(arr) {
        if (arr.length === 0) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    _degreeDistribution(degreeValues) {
        const dist = {};
        for (const deg of degreeValues) {
            dist[deg] = (dist[deg] || 0) + 1;
        }
        return dist;
    }

    _computeDiameterAndRadius() {
        const n = this.nodes.length;
        const fw = this.floydWarshall();
        const dist = fw.dist;
        
        // Excentricita ka≈æd√©ho uzlu = max vzd√°lenost k ostatn√≠m
        const eccentricities = [];
        for (let i = 0; i < n; i++) {
            let maxDist = 0;
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    maxDist = Math.max(maxDist, dist[i][j]);
                }
            }
            eccentricities.push(maxDist);
        }
        
        const diameter = Math.max(...eccentricities); // max excentricita
        const radius = Math.min(...eccentricities);   // min excentricita
        
        // Centr√°ln√≠ uzly (excentricita = polomƒõr)
        const centerNodes = [];
        const peripheralNodes = [];
        for (let i = 0; i < n; i++) {
            if (eccentricities[i] === radius) centerNodes.push(this.nodes[i]);
            if (eccentricities[i] === diameter) peripheralNodes.push(this.nodes[i]);
        }
        
        return { diameter, radius, centerNodes, peripheralNodes };
    }

    countSpanningTrees() {
        const n = this.nodes.length;
        if (n === 0) return 0;
        if (n === 1) return 1;

        // Pokud graf nen√≠ souvisl√Ω, neexistuje ≈æ√°dn√° spanning tree
        if (this.countComponents() !== 1) {
            return 0;
        }

        const L = this.laplacianMatrix();
        const cofactor = [];
        for (let i = 1; i < n; i++) {
            const row = [];
            for (let j = 1; j < n; j++) {
                row.push(L[i][j]);
            }
            cofactor.push(row);
        }

        const det = this._determinantGaussian(cofactor);
        if (!Number.isFinite(det)) {
            return det;
        }
        return Math.max(0, Math.round(det));
    }

    // Poƒçet spanning forests (souƒçin poƒçtu koster v≈°ech komponent)
    countSpanningForests() {
        const components = this.getComponents();
        if (components.length === 0) return { total: 0, perComponent: [], componentCount: 0 };
        if (components.length === 1) {
            const count = this.countSpanningTrees();
            return { total: count, perComponent: [{ nodes: components[0].nodes, count }], componentCount: 1 };
        }

        // Pro ka≈ædou komponentu vytvo≈ô√≠me subgraf a spoƒç√≠t√°me kostry
        const perComponent = [];
        let totalProduct = 1;
        let overflow = false;

        for (const comp of components) {
            if (comp.nodes.length === 1) {
                // Izolovan√Ω uzel m√° 1 kostru (pr√°zdnou)
                perComponent.push({ nodes: comp.nodes, count: 1 });
                continue;
            }

            // Vytvo≈ô subgraf pro tuto komponentu
            const subGraph = new Graph();
            subGraph.nodes = [...comp.nodes];
            subGraph.nodeIndex = {};
            comp.nodes.forEach((node, idx) => subGraph.nodeIndex[node] = idx);
            
            // P≈ôidej hrany, kter√© jsou uvnit≈ô t√©to komponenty
            const nodeSet = new Set(comp.nodes);
            subGraph.edges = this.edges.filter(e => nodeSet.has(e.u) && nodeSet.has(e.v));

            const count = subGraph.countSpanningTrees();
            perComponent.push({ nodes: comp.nodes, count });

            if (!Number.isFinite(count)) {
                overflow = true;
            } else {
                totalProduct *= count;
                if (!Number.isFinite(totalProduct)) {
                    overflow = true;
                }
            }
        }

        return {
            total: overflow ? Infinity : totalProduct,
            perComponent,
            componentCount: components.length
        };
    }

    _determinantGaussian(matrix) {
        const n = matrix.length;
        if (n === 0) return 1;
        const mat = matrix.map(row => row.map(value => {
            const num = typeof value === 'number' ? value : Number(value);
            return Number.isFinite(num) ? num : 0;
        }));
        const EPS = 1e-9;
        let swapCount = 0;
        for (let i = 0; i < n; i++) {
            let pivot = i;
            for (let j = i + 1; j < n; j++) {
                if (Math.abs(mat[j][i]) > Math.abs(mat[pivot][i])) {
                    pivot = j;
                }
            }
            if (Math.abs(mat[pivot][i]) < EPS) {
                return 0;
            }
            if (pivot !== i) {
                [mat[i], mat[pivot]] = [mat[pivot], mat[i]];
                swapCount++;
            }
            for (let j = i + 1; j < n; j++) {
                const factor = mat[j][i] / mat[i][i];
                if (Math.abs(factor) < EPS) continue;
                for (let k = i; k < n; k++) {
                    mat[j][k] -= factor * mat[i][k];
                }
            }
        }
        let det = swapCount % 2 === 0 ? 1 : -1;
        for (let i = 0; i < n; i++) {
            det *= mat[i][i];
        }
        return det;
    }

    _spanningForest(order = 'asc') {
        const n = this.nodes.length;
        if (n === 0) {
            return { tree: [], totalWeight: 0, componentTrees: [], componentCount: 0 };
        }

        const parent = {};
        const rank = {};
        this.nodes.forEach(node => {
            parent[node] = node;
            rank[node] = 0;
        });

        const find = (node) => {
            if (parent[node] !== node) {
                parent[node] = find(parent[node]);
            }
            return parent[node];
        };

        const union = (a, b) => {
            const rootA = find(a);
            const rootB = find(b);
            if (rootA === rootB) return false;
            if (rank[rootA] < rank[rootB]) {
                parent[rootA] = rootB;
            } else if (rank[rootA] > rank[rootB]) {
                parent[rootB] = rootA;
            } else {
                parent[rootB] = rootA;
                rank[rootA]++;
            }
            return true;
        };

        const edges = this.edges
            .filter(e => e.u !== e.v)
            .map((edge, index) => {
                const weight = (edge.weight !== null && edge.weight !== undefined && !Number.isNaN(edge.weight)) ? edge.weight : 1;
                return {
                    index,
                    u: edge.u,
                    v: edge.v,
                    weight,
                    ref: edge,
                };
            });

        edges.sort((a, b) => order === 'asc' ? a.weight - b.weight : b.weight - a.weight);

        const selectedEdges = [];
        let totalWeight = 0;
        for (const edge of edges) {
            if (union(edge.u, edge.v)) {
                selectedEdges.push(edge);
                totalWeight += edge.weight;
            }
        }

        const components = {};
        this.nodes.forEach(node => {
            const root = find(node);
            if (!components[root]) {
                components[root] = { nodes: [], edges: [], totalWeight: 0 };
            }
            components[root].nodes.push(node);
        });

        selectedEdges.forEach(edge => {
            const root = find(edge.u);
            components[root].edges.push(edge.ref);
            components[root].totalWeight += edge.weight;
        });

        const componentTrees = Object.values(components).map(component => ({
            nodes: [...component.nodes],
            edges: [...component.edges],
            totalWeight: component.totalWeight,
        })).sort((a, b) => b.nodes.length - a.nodes.length);

        return {
            tree: selectedEdges.map(edge => edge.ref),
            totalWeight,
            componentTrees,
            componentCount: componentTrees.length,
        };
    }

    minimumSpanningTree() {
        return this._spanningForest('asc');
    }

    maximumSpanningTree() {
        return this._spanningForest('desc');
    }

    edgeWeightStats() {
        if (this.edges.length === 0) return null;
        let min = Infinity;
        let max = -Infinity;
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (w < min) min = w;
            if (w > max) max = w;
        }
        return { min, max };
    }

    edgeWeightsBetween(nodeU, nodeV) {
        const weights = [];
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                if (e.u === nodeU && e.v === nodeV) weights.push(w);
            } else if (e.direction === '<') {
                if (e.v === nodeU && e.u === nodeV) weights.push(w);
            } else if ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU)) {
                weights.push(w);
            }
        }
        return weights;
    }

    pathWeightFromNodes(nodePath, strategy = 'min') {
        if (!nodePath || nodePath.length < 2) return 0;
        let total = 0;
        for (let i = 0; i < nodePath.length - 1; i++) {
            const weights = this.edgeWeightsBetween(nodePath[i], nodePath[i + 1]);
            if (!weights.length) return null;
            const value = strategy === 'max' ? Math.max(...weights) : Math.min(...weights);
            total += value;
        }
        return total;
    }

    _buildDirectedGraph(includeUndirected = true) {
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const edges = [];
        const addEdge = (from, to, weight, rawEdge, rawIndex) => {
            if (!(from in idx) || !(to in idx)) return;
            edges.push({
                from: idx[from],
                to: idx[to],
                weight,
                fromId: from,
                toId: to,
                label: rawEdge && rawEdge.label ? rawEdge.label : `${from}‚Üí${to}`,
                rawIndex,
            });
        };
        for (let rawIndex = 0; rawIndex < this.edges.length; rawIndex++) {
            const e = this.edges[rawIndex];
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                addEdge(e.u, e.v, w, e, rawIndex);
            } else if (e.direction === '<') {
                addEdge(e.v, e.u, w, e, rawIndex);
            } else if (includeUndirected) {
                addEdge(e.u, e.v, w, e, rawIndex);
                addEdge(e.v, e.u, w, e, rawIndex);
            }
        }
        const adj = Array.from({ length: this.nodes.length }, () => []);
        edges.forEach((edge, idxEdge) => {
            adj[edge.from].push({ to: edge.to, weight: edge.weight, edgeIndex: idxEdge });
        });
        return { idx, edges, adj };
    }

    topologicalSort(includeUndirected = true, graphData = null) {
        const data = graphData || this._buildDirectedGraph(includeUndirected);
        const n = this.nodes.length;
        const indegree = Array(n).fill(0);
        for (const edge of data.edges) {
            indegree[edge.to]++;
        }
        const queue = [];
        for (let i = 0; i < n; i++) {
            if (indegree[i] === 0) queue.push(i);
        }
        const order = [];
        while (queue.length) {
            const u = queue.shift();
            order.push(u);
            for (const edge of data.adj[u]) {
                indegree[edge.to]--;
                if (indegree[edge.to] === 0) queue.push(edge.to);
            }
        }
        return { order, isDAG: order.length === n, data };
    }

    _reconstructPath(startIdx, endIdx, predecessors) {
        if (startIdx === undefined || startIdx === null || endIdx === undefined || endIdx === null) return [];
        const path = [];
        let current = endIdx;
        while (current !== null && current !== undefined && current !== -1) {
            path.unshift(this.nodes[current]);
            if (current === startIdx) break;
            current = predecessors[current];
        }
        if (!path.length || path[0] !== this.nodes[startIdx]) return [];
        return path;
    }

    mooreShortestPath(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const pred = Array(n).fill(null);
        const queue = [];
        dist[startIdx] = 0;
        queue.push(startIdx);
        while (queue.length) {
            const u = queue.shift();
            if (u === endIdx) break;
            for (const edge of graphData.adj[u]) {
                if (dist[edge.to] === Infinity) {
                    dist[edge.to] = dist[u] + 1;
                    pred[edge.to] = u;
                    queue.push(edge.to);
                }
            }
        }
        if (dist[endIdx] === Infinity) {
            return { distance: Infinity, path: [] };
        }
        return { distance: dist[endIdx], path: this._reconstructPath(startIdx, endIdx, pred) };
    }

    bellmanFordAll(startNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const pred = Array(n).fill(null);
        dist[startIdx] = 0;
        for (let i = 0; i < n - 1; i++) {
            let updated = false;
            for (const edge of graphData.edges) {
                if (dist[edge.from] === Infinity) continue;
                const candidate = dist[edge.from] + edge.weight;
                if (candidate < dist[edge.to]) {
                    dist[edge.to] = candidate;
                    pred[edge.to] = edge.from;
                    updated = true;
                }
            }
            if (!updated) break;
        }
        let negativeCycle = false;
        for (const edge of graphData.edges) {
            if (dist[edge.from] !== Infinity && dist[edge.from] + edge.weight < dist[edge.to]) {
                negativeCycle = true;
                break;
            }
        }
        return { dist, pred, negativeCycle, startIdx };
    }

    bellmanFordPath(startNode, endNode) {
        const result = this.bellmanFordAll(startNode);
        if (!result) return null;
        const endIdx = this.nodes.indexOf(endNode);
        if (endIdx === -1) return null;
        const path = this._reconstructPath(result.startIdx, endIdx, result.pred);
        return { distance: result.dist[endIdx], path, negativeCycle: result.negativeCycle };
    }

    widestPath(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        
        // ‚ö° Kontrola z√°porn√Ωch kapacit - nej≈°ir≈°√≠ cesta vy≈æaduje nez√°porn√© kapacity
        let hasNegativeCapacity = false;
        for (const edge of graphData.edges) {
            if (edge.weight < 0) {
                hasNegativeCapacity = true;
                break;
            }
        }
        if (hasNegativeCapacity) {
            return { path: [], width: null, error: 'Graf obsahuje z√°porn√© kapacity ‚Äì nej≈°ir≈°√≠ cesta nen√≠ definov√°na.' };
        }
        
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        if (startIdx === endIdx) return { path: [startNode], width: Infinity };
        const n = this.nodes.length;
        const width = Array(n).fill(0);
        const visited = Array(n).fill(false);
        const pred = Array(n).fill(null);
        width[startIdx] = Infinity;
        for (let count = 0; count < n; count++) {
            let u = -1;
            let best = 0;
            for (let i = 0; i < n; i++) {
                if (!visited[i] && width[i] > best) {
                    best = width[i];
                    u = i;
                }
            }
            if (u === -1) break;
            visited[u] = true;
            if (u === endIdx) break;
            for (const edge of graphData.adj[u]) {
                const candidate = Math.min(width[u], edge.weight);
                if (candidate > width[edge.to]) {
                    width[edge.to] = candidate;
                    pred[edge.to] = u;
                }
            }
        }
        if (width[endIdx] === 0) return { path: [], width: 0 };
        return { path: this._reconstructPath(startIdx, endIdx, pred), width: width[endIdx] };
    }

    // ‚ö° Spolehlivost hrany podle standardn√≠ho vzorce: r = exp(-w)
    // Pro w > 0: r ‚àà (0, 1) - ƒç√≠m vy≈°≈°√≠ v√°ha, t√≠m ni≈æ≈°√≠ spolehlivost
    // Pro w = 0: r = 1 (maxim√°ln√≠ spolehlivost)
    // Pro w < 0: r > 1 (nen√≠ standardn√≠ interpretace, ale matematicky platn√©)
    _edgeReliability(weight) {
        return Math.exp(-weight);
    }

    safestPath(startNode, endNode) {
        // Nejbezpeƒçnƒõj≈°√≠ cesta maximalizuje souƒçin spolehlivost√≠ hran
        // Spolehlivost hrany: r = exp(-w) kde w je v√°ha hrany
        // Maximalizace souƒçinu r1 * r2 * ... = exp(-w1) * exp(-w2) * ... = exp(-(w1+w2+...))
        // = minimalizace souƒçtu vah = nejkrat≈°√≠ cesta!
        // 
        // Pro kladn√© v√°hy: vy≈°≈°√≠ v√°ha = ni≈æ≈°√≠ spolehlivost
        // Pro z√°porn√© v√°hy: algoritmus st√°le funguje, ale interpretace je nestandardn√≠
        
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        if (startIdx === endIdx) return { path: [startNode], reliability: 1 };
        
        // Kontrola z√°porn√Ωch vah - pro nƒõ pou≈æijeme Bellman-Ford
        let hasNegative = false;
        for (const edge of graphData.edges) {
            if (edge.weight < 0) {
                hasNegative = true;
                break;
            }
        }
        
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const pred = Array(n).fill(null);
        dist[startIdx] = 0;
        
        if (hasNegative) {
            // Bellman-Ford pro z√°porn√© v√°hy
            for (let i = 0; i < n - 1; i++) {
                let updated = false;
                for (const edge of graphData.edges) {
                    if (dist[edge.from] === Infinity) continue;
                    const candidate = dist[edge.from] + edge.weight;
                    if (candidate < dist[edge.to]) {
                        dist[edge.to] = candidate;
                        pred[edge.to] = edge.from;
                        updated = true;
                    }
                }
                if (!updated) break;
            }
            // Detekce z√°porn√©ho cyklu
            let negativeCycle = false;
            for (const edge of graphData.edges) {
                if (dist[edge.from] !== Infinity && dist[edge.from] + edge.weight < dist[edge.to]) {
                    negativeCycle = true;
                    break;
                }
            }
            if (negativeCycle) {
                return { path: [], reliability: null, error: 'Detekov√°n z√°porn√Ω cyklus ‚Äì spolehlivost nen√≠ definov√°na.' };
            }
        } else {
            // Dijkstra pro nez√°porn√© v√°hy
            const visited = Array(n).fill(false);
            for (let iter = 0; iter < n; iter++) {
                let u = -1;
                let best = Infinity;
                for (let i = 0; i < n; i++) {
                    if (!visited[i] && dist[i] < best) {
                        best = dist[i];
                        u = i;
                    }
                }
                if (u === -1) break;
                visited[u] = true;
                if (u === endIdx) break;
                for (const edge of graphData.adj[u]) {
                    // P≈ô√≠m√© sƒç√≠t√°n√≠ vah (ekvivalent n√°soben√≠ spolehlivost√≠ p≈ôes logaritmus)
                    const candidate = dist[u] + edge.weight;
                    if (candidate < dist[edge.to]) {
                        dist[edge.to] = candidate;
                        pred[edge.to] = u;
                    }
                }
            }
        }
        
        if (dist[endIdx] === Infinity) return { path: [], reliability: 0 };
        
        // Spolehlivost cesty = exp(-souƒçet vah) = souƒçin spolehlivost√≠ hran
        const pathReliability = Math.exp(-dist[endIdx]);
        
        return {
            path: this._reconstructPath(startIdx, endIdx, pred),
            reliability: pathReliability,
            totalWeight: dist[endIdx]
        };
    }

    longestPathInfo(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        const topo = this.topologicalSort(true, graphData);
        if (topo.isDAG) {
            const dist = Array(this.nodes.length).fill(-Infinity);
            const pred = Array(this.nodes.length).fill(null);
            dist[startIdx] = 0;
            for (const u of topo.order) {
                if (dist[u] === -Infinity) continue;
                for (const edge of graphData.adj[u]) {
                    const candidate = dist[u] + edge.weight;
                    if (candidate > dist[edge.to]) {
                        dist[edge.to] = candidate;
                        pred[edge.to] = u;
                    }
                }
            }
            if (dist[endIdx] === -Infinity) {
                return { path: [], weight: null, mode: 'dag' };
            }
            return {
                path: this._reconstructPath(startIdx, endIdx, pred),
                weight: dist[endIdx],
                mode: 'dag'
            };
        }
        const { paths } = this.simplePathsUpTo(startNode, endNode, this.nodes.length - 1, 2000);
        if (!paths.length) return { path: [], weight: null, mode: 'fallback' };
        let bestPath = null;
        let bestWeight = -Infinity;
        for (const p of paths) {
            const w = this.pathWeightFromNodes(p, 'max');
            if (w !== null && w > bestWeight) {
                bestWeight = w;
                bestPath = p;
            }
        }
        return {
            path: bestPath || [],
            weight: bestWeight === -Infinity ? null : bestWeight,
            mode: 'fallback',
            limited: paths.length >= 2000
        };
    }

    cpmAnalysis() {
        const graphData = this._buildDirectedGraph(false);
        if (graphData.edges.length === 0) {
            return { error: 'Pro CPM anal√Ωzu jsou pot≈ôeba orientovan√© hrany (operace).' };
        }
        const topo = this.topologicalSort(false, graphData);
        if (!topo.isDAG) {
            return { error: 'S√≠≈•ov√Ω graf obsahuje cyklus ‚Äì kritickou cestu lze hledat jen v acyklick√©m grafu.' };
        }
        const order = topo.order;
        const n = this.nodes.length;
        const earliest = Array(n).fill(0);
        for (const u of order) {
            for (const edge of graphData.adj[u]) {
                const candidate = earliest[u] + edge.weight;
                if (candidate > earliest[edge.to]) {
                    earliest[edge.to] = candidate;
                }
            }
        }
        const projectDuration = Math.max(...earliest);
        const latest = Array(n).fill(projectDuration);
        for (let i = order.length - 1; i >= 0; i--) {
            const u = order[i];
            if (!graphData.adj[u].length) {
                latest[u] = Math.min(latest[u], projectDuration);
                continue;
            }
            let minCandidate = Infinity;
            for (const edge of graphData.adj[u]) {
                const candidate = latest[edge.to] - edge.weight;
                if (candidate < minCandidate) minCandidate = candidate;
            }
            if (minCandidate !== Infinity) {
                latest[u] = Math.min(latest[u], minCandidate);
            }
        }
        // Pro uzly pot≈ôebujeme vypoƒç√≠tat ES, EF, LS, LF
        // ES (Early Start) = nejd≈ô√≠ve mo≈æn√Ω start = earliest[idx]
        // EF (Early Finish) = nejd≈ô√≠ve mo≈æn√© ukonƒçen√≠ = max(EF v≈°ech p≈ô√≠choz√≠ch hran) = earliest[idx]
        // LS (Late Start) = nejpozdƒõji p≈ô√≠pustn√Ω start = min(LS v≈°ech odchoz√≠ch hran - duration) 
        // LF (Late Finish) = nejpozdƒõji p≈ô√≠pustn√© ukonƒçen√≠ = latest[idx]
        // Pro uzlov√Ω graf: ES = EF (uzel je okam≈æik, ne ƒçinnost)
        const nodeSummaries = this.nodes.map((id, idx) => {
            const es = earliest[idx];  // Early Start = Early Finish pro uzel
            const ef = earliest[idx];  // Early Finish
            const ls = latest[idx];    // Late Start = Late Finish pro uzel  
            const lf = latest[idx];    // Late Finish
            const slack = lf - ef;     // Rezerva = LF - EF (nebo LS - ES)
            return {
                id,
                es,
                ef,
                ls,
                lf,
                earliest: earliest[idx],
                latest: latest[idx],
                slack,
                isCritical: Math.abs(slack) < 1e-6
            };
        });
        const activities = graphData.edges.map(edge => {
            const earlyStart = earliest[edge.from];
            const duration = edge.weight;
            const earlyFinish = earlyStart + duration;
            const lateFinish = latest[edge.to];
            const lateStart = lateFinish - duration;
            const slack = lateStart - earlyStart;
            return {
                id: edge.label || `${edge.fromId}‚Üí${edge.toId}`,
                from: edge.fromId,
                to: edge.toId,
                duration,
                earlyStart,
                earlyFinish,
                lateStart,
                lateFinish,
                slack,
                isCritical: Math.abs(slack) < 1e-6
            };
        });
        const criticalActivities = activities.filter(a => a.isCritical);
        const criticalPath = this._extractCriticalPath(criticalActivities);
        return {
            projectDuration,
            nodeSummaries,
            activities,
            criticalPath,
            criticalEdgesCount: criticalActivities.length
        };
    }

    _extractCriticalPath(criticalActivities) {
        if (!criticalActivities.length) return [];
        const adjacency = {};
        const indegree = {};
        for (const act of criticalActivities) {
            if (!adjacency[act.from]) adjacency[act.from] = [];
            adjacency[act.from].push(act);
            indegree[act.to] = (indegree[act.to] || 0) + 1;
            indegree[act.from] = indegree[act.from] || 0;
        }
        const startCandidates = Object.keys(adjacency).filter(node => (indegree[node] || 0) === 0);
        const start = startCandidates[0] || criticalActivities[0].from;
        const stack = [[start, [start]]];
        let bestPath = [];
        while (stack.length) {
            const [node, path] = stack.pop();
            const nextEdges = adjacency[node] || [];
            if (!nextEdges.length) {
                if (path.length > bestPath.length) {
                    bestPath = path.slice();
                }
            } else {
                for (const edge of nextEdges) {
                    stack.push([edge.to, [...path, edge.to]]);
                }
            }
        }
        return bestPath;
    }

    _buildCapacityMatrixForFlows() {
        if (!this.nodes.length) return null;
        const data = this._buildDirectedGraph(true);
        const n = this.nodes.length;
        const capacity = Array.from({ length: n }, () => Array(n).fill(0));
        data.edges.forEach(edge => {
            capacity[edge.from][edge.to] += edge.weight;
        });
        return { capacity, idx: data.idx };
    }

    _flowEdgesFrom(capacity, residual) {
        const edges = [];
        const n = capacity.length;
        const EPS = 1e-9;
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                const cap = capacity[i][j];
                if (cap <= EPS) continue;
                const flow = cap - residual[i][j];
                if (flow > EPS) {
                    edges.push({
                        from: this.nodes[i],
                        to: this.nodes[j],
                        flow,
                        capacity: cap,
                        utilization: cap ? flow / cap : 0
                    });
                }
            }
        }
        edges.sort((a, b) => b.flow - a.flow);
        return edges;
    }

    _capacitySummary(capacity, sourceIdx, sinkIdx) {
        const outFromSource = capacity[sourceIdx].reduce((a, b) => a + b, 0);
        let intoSink = 0;
        for (let i = 0; i < capacity.length; i++) {
            intoSink += capacity[i][sinkIdx];
        }
        return { outFromSource, intoSink };
    }

    _deriveMinCut(capacity, residual, sourceIdx) {
        const n = capacity.length;
        const visited = Array(n).fill(false);
        const stack = [sourceIdx];
        const EPS = 1e-9;
        while (stack.length) {
            const u = stack.pop();
            if (visited[u]) continue;
            visited[u] = true;
            for (let v = 0; v < n; v++) {
                if (visited[v]) continue;
                if (residual[u][v] > EPS) {
                    stack.push(v);
                }
            }
        }
        const S = [];
        const T = [];
        const edges = [];
        for (let i = 0; i < n; i++) {
            if (visited[i]) S.push(this.nodes[i]);
            else T.push(this.nodes[i]);
            for (let j = 0; j < n; j++) {
                if (visited[i] && !visited[j] && capacity[i][j] > EPS) {
                    edges.push({
                        from: this.nodes[i],
                        to: this.nodes[j],
                        capacity: capacity[i][j]
                    });
                }
            }
        }
        const value = edges.reduce((acc, e) => acc + e.capacity, 0);
        return { value, S, T, edges };
    }

    _augmentingPathMaxFlow(baseCapacity, sourceIdx, sinkIdx, useBfs) {
        const n = baseCapacity.length;
        const capacity = baseCapacity.map(row => row.slice());
        const residual = capacity.map(row => row.slice());
        const parent = Array(n).fill(-1);
        const augmentingPaths = [];
        const EPS = 1e-9;
        const findPath = () => {
            parent.fill(-1);
            parent[sourceIdx] = sourceIdx;
            if (useBfs) {
                const queue = [sourceIdx];
                while (queue.length) {
                    const u = queue.shift();
                    for (let v = 0; v < n; v++) {
                        if (parent[v] !== -1) continue;
                        if (residual[u][v] <= EPS) continue;
                        parent[v] = u;
                        if (v === sinkIdx) return true;
                        queue.push(v);
                    }
                }
            } else {
                const stack = [sourceIdx];
                while (stack.length) {
                    const u = stack.pop();
                    for (let v = 0; v < n; v++) {
                        if (parent[v] !== -1) continue;
                        if (residual[u][v] <= EPS) continue;
                        parent[v] = u;
                        if (v === sinkIdx) return true;
                        stack.push(v);
                    }
                }
            }
            return false;
        };
        let maxFlow = 0;
        let iterations = 0;
        while (findPath()) {
            iterations++;
            let pathFlow = Infinity;
            let v = sinkIdx;
            const pathNodes = [];
            while (v !== sourceIdx) {
                const u = parent[v];
                pathFlow = Math.min(pathFlow, residual[u][v]);
                pathNodes.push(this.nodes[v]);
                v = u;
            }
            pathNodes.push(this.nodes[sourceIdx]);
            pathNodes.reverse();
            augmentingPaths.push({
                path: pathNodes,
                bottleneck: pathFlow
            });
            v = sinkIdx;
            while (v !== sourceIdx) {
                const u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow;
                v = u;
            }
            maxFlow += pathFlow;
            if (iterations > 10000) break;
        }
        const minCut = this._deriveMinCut(capacity, residual, sourceIdx);
        return {
            maxFlow,
            augmentingPaths,
            iterations,
            minCut,
            flowEdges: this._flowEdgesFrom(capacity, residual),
            residual
        };
    }

    _pushRelabelMaxFlow(baseCapacity, sourceIdx, sinkIdx) {
        const n = baseCapacity.length;
        const capacity = baseCapacity.map(row => row.slice());
        const flow = Array.from({ length: n }, () => Array(n).fill(0));
        const height = Array(n).fill(0);
        const excess = Array(n).fill(0);
        const neighborSets = Array.from({ length: n }, () => new Set());
        for (let u = 0; u < n; u++) {
            for (let v = 0; v < n; v++) {
                if (capacity[u][v] > 0 || capacity[v][u] > 0) {
                    neighborSets[u].add(v);
                }
            }
        }
        const neighbors = neighborSets.map(set => Array.from(set));
        height[sourceIdx] = n;
        for (let v = 0; v < n; v++) {
            if (capacity[sourceIdx][v] > 0) {
                const cap = capacity[sourceIdx][v];
                flow[sourceIdx][v] = cap;
                flow[v][sourceIdx] = -cap;
                excess[v] += cap;
                excess[sourceIdx] -= cap;
            }
        }
        const nodes = [];
        for (let i = 0; i < n; i++) {
            if (i !== sourceIdx && i !== sinkIdx) nodes.push(i);
        }
        const seen = Array(n).fill(0);
        let relabelCount = 0;
        let pushCount = 0;
        const residualCapacity = (u, v) => capacity[u][v] - flow[u][v];
        const push = (u, v) => {
            const send = Math.min(excess[u], residualCapacity(u, v));
            if (send <= 0) return false;
            flow[u][v] += send;
            flow[v][u] -= send;
            excess[u] -= send;
            excess[v] += send;
            pushCount++;
            return true;
        };
        const relabel = (u) => {
            let minHeight = Infinity;
            neighbors[u].forEach(v => {
                if (residualCapacity(u, v) > 1e-9) {
                    minHeight = Math.min(minHeight, height[v]);
                }
            });
            if (minHeight < Infinity) {
                height[u] = minHeight + 1;
            } else {
                height[u] = Infinity;
            }
            relabelCount++;
        };
        let p = 0;
        while (p < nodes.length) {
            const u = nodes[p];
            const oldHeight = height[u];
            while (excess[u] > 1e-9) {
                const neighborList = neighbors[u];
                if (!neighborList.length) break;
                if (seen[u] >= neighborList.length) {
                    relabel(u);
                    seen[u] = 0;
                    continue;
                }
                const v = neighborList[seen[u]];
                if (residualCapacity(u, v) > 1e-9 && height[u] === height[v] + 1) {
                    push(u, v);
                } else {
                    seen[u]++;
                }
            }
            if (height[u] > oldHeight) {
                nodes.splice(0, 0, nodes.splice(p, 1)[0]);
                p = 0;
            } else {
                p++;
            }
        }
        const maxFlow = Math.max(0, excess[sinkIdx]);
        const residual = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                residual[i][j] = capacity[i][j] - flow[i][j];
            }
        }
        const minCut = this._deriveMinCut(capacity, residual, sourceIdx);
        const flowEdges = [];
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (capacity[i][j] > 0) {
                    const val = Math.max(0, flow[i][j]);
                    if (val > 1e-9) {
                        flowEdges.push({
                            from: this.nodes[i],
                            to: this.nodes[j],
                            flow: val,
                            capacity: capacity[i][j],
                            utilization: capacity[i][j] ? val / capacity[i][j] : 0
                        });
                    }
                }
            }
        }
        flowEdges.sort((a, b) => b.flow - a.flow);
        const heightProfile = this.nodes.map((node, idx) => ({
            node,
            height: height[idx]
        }));
        return {
            maxFlow,
            relabelCount,
            pushCount,
            heightProfile,
            minCut,
            flowEdges,
            residual
        };
    }

    flowNetworkAnalysis(sourceNode, sinkNode) {
        const structures = this._buildCapacityMatrixForFlows();
        if (!structures) {
            return { error: 'Graf neobsahuje ≈æ√°dnou s√≠≈• pro v√Ωpoƒçet toku.' };
        }
        const { capacity, idx } = structures;
        if (!(sourceNode in idx) || !(sinkNode in idx)) {
            return { error: 'Zadejte pros√≠m existuj√≠c√≠ uzly jako zdroj (s) i c√≠l (t).' };
        }
        const sourceIdx = idx[sourceNode];
        const sinkIdx = idx[sinkNode];
        if (sourceIdx === sinkIdx) {
            return { error: 'Zdroj a c√≠l mus√≠ b√Ωt r≈Øzn√© uzly.' };
        }
        const copyMatrix = () => capacity.map(row => row.slice());
        const ford = this._augmentingPathMaxFlow(copyMatrix(), sourceIdx, sinkIdx, false);
        const edmonds = this._augmentingPathMaxFlow(copyMatrix(), sourceIdx, sinkIdx, true);
        const goldberg = this._pushRelabelMaxFlow(copyMatrix(), sourceIdx, sinkIdx);
        const bestFlow = Math.max(ford.maxFlow || 0, edmonds.maxFlow || 0, goldberg.maxFlow || 0);
        const representativeCut = edmonds.minCut || ford.minCut || goldberg.minCut;
        return {
            source: sourceNode,
            sink: sinkNode,
            fordFulkerson: ford,
            edmondsKarp: edmonds,
            goldberg,
            bestFlow,
            minCut: representativeCut,
            capacitySummary: this._capacitySummary(capacity, sourceIdx, sinkIdx)
        };
    }

    dfsTraversal(startNode) {
        const result = [];
        const visited = new Set();
        const adj = this.neighbours();

        function dfs(node) {
            if (!node || visited.has(node)) {
                return;
            }
            visited.add(node);
            result.push(node);
            const neighbors = adj[node] || [];
            for (const neighbor of neighbors) {
                dfs(neighbor);
            }
        }

        dfs(startNode);
        return result;
    }

    bfsTraversal(startNode) {
        const result = [];
        const visited = new Set();
        const queue = [startNode];
        const adj = this.neighbours();

        if (!this.nodes.includes(startNode)) {
            return [];
        }

        visited.add(startNode);

        while (queue.length > 0) {
            const node = queue.shift();
            result.push(node);

            const neighbors = adj[node] || [];
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        return result;
    }
}


function createMatrixTable(matrix, rowLabels, colLabels) {
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th'));
    for (const label of colLabels) {
        const th = document.createElement('th');
        th.textContent = label;
        headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (let i = 0; i < matrix.length; i++) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = rowLabels[i];
        tr.appendChild(th);
        for (let j = 0; j < matrix[i].length; j++) {
            const td = document.createElement('td');
            const val = matrix[i][j];
            td.textContent = (val === Infinity ? '‚àû' : val);
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    table.addEventListener('mouseover', handleMatrixMouseOver(matrix));
    table.addEventListener('mouseout', handleMatrixMouseOut);
    return table;
}

function handleMatrixMouseOver(matrix) {
    return function(event) {
        const cell = event.target.closest('td');
        if (!cell) return;

        const rowIndex = cell.parentNode.rowIndex - 1;
        const colIndex = cell.cellIndex - 1;

        // Row stats
        const row = matrix[rowIndex];
        const rowSum = row.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
        const rowCounts = row.reduce((acc, val) => {
            if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});

        // Column stats
        const col = matrix.map(r => r[colIndex]);
        const colSum = col.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
        const colCounts = col.reduce((acc, val) => {
            if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});

        let statsHTML = `<strong>≈ò√°dek ${rowIndex + 1}:</strong> Souƒçet = ${rowSum}<br>`;
        statsHTML += `<strong>Sloupec ${colIndex + 1}:</strong> Souƒçet = ${colSum}<br>`;

        // Diagonal stats
        if (rowIndex === colIndex) {
            const mainDiag = matrix.map((r, i) => r[i]);
            const mainDiagSum = mainDiag.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            statsHTML += `<strong>Hlavn√≠ diagon√°la:</strong> Souƒçet = ${mainDiagSum}<br>`;
        }
        if (rowIndex + colIndex === matrix.length - 1) {
            const antiDiag = matrix.map((r, i) => r[matrix.length - 1 - i]);
            const antiDiagSum = antiDiag.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            statsHTML += `<strong>Vedlej≈°√≠ diagon√°la:</strong> Souƒçet = ${antiDiagSum}<br>`;
        }

        const tooltip = document.getElementById('matrix-stats-tooltip');
        tooltip.innerHTML = statsHTML;
        tooltip.style.display = 'block';
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY + 10}px`;
    };
}

function handleMatrixMouseOut(event) {
    const tooltip = document.getElementById('matrix-stats-tooltip');
    tooltip.style.display = 'none';
}

function calculateMatrixStats(matrix, rowLabels = null, colLabels = null) {
    const n = matrix.length;
    if (n === 0) return {
        positiveCount: 0, negativeCount: 0, zeroCount: 0, infinityCount: 0,
        totalCount: 0, totalSum: 0, rowSums: [], colSums: [], valueCounts: {},
        diagonalSum: 0, diagonalCounts: {}, antiDiagonalSum: 0, antiDiagonalCounts: {},
        mainDiagonalStats: [], antiDiagonalStats: [],
        rowStats: [], colStats: [], rowLabels: [], colLabels: []
    };
    const m = matrix[0].length;

    let positiveCount = 0;
    let negativeCount = 0;
    let zeroCount = 0;
    let infinityCount = 0;
    let totalSum = 0;
    const rowSums = Array(n).fill(0);
    const colSums = Array(m).fill(0);
    const valueCounts = {};
    let diagonalSum = 0;
    const diagonalCounts = {};
    let antiDiagonalSum = 0;
    const antiDiagonalCounts = {};
    
    // Statistiky pro ka≈æd√Ω ≈ô√°dek a sloupec
    const rowStats = Array(n).fill(null).map(() => ({ sum: 0, counts: {}, positive: 0, negative: 0, zero: 0 }));
    const colStats = Array(m).fill(null).map(() => ({ sum: 0, counts: {}, positive: 0, negative: 0, zero: 0 }));
    
    // Statistiky pro diagon√°ly (detailn√≠ pro ka≈æd√Ω prvek)
    const mainDiagonalStats = [];
    const antiDiagonalStats = [];

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            const val = matrix[i][j];

            if (val > 0 && isFinite(val)) {
                positiveCount++;
                rowStats[i].positive++;
                colStats[j].positive++;
            } else if (val < 0 && isFinite(val)) {
                negativeCount++;
                rowStats[i].negative++;
                colStats[j].negative++;
            } else if (val === 0) {
                zeroCount++;
                rowStats[i].zero++;
                colStats[j].zero++;
            } else if (!isFinite(val)) {
                infinityCount++;
            }

            if (isFinite(val)) {
                rowSums[i] += val;
                colSums[j] += val;
                totalSum += val;
                rowStats[i].sum += val;
                colStats[j].sum += val;
            }

            const key = !isFinite(val) ? '‚àû' : val;
            valueCounts[key] = (valueCounts[key] || 0) + 1;
            rowStats[i].counts[key] = (rowStats[i].counts[key] || 0) + 1;
            colStats[j].counts[key] = (colStats[j].counts[key] || 0) + 1;
        }
    }

    // Hlavn√≠ diagon√°la (i == j)
    if (n === m) {
        for (let i = 0; i < n; i++) {
            const val = matrix[i][i];
            if (isFinite(val)) {
                diagonalSum += val;
            }
            const key = !isFinite(val) ? '‚àû' : val;
            diagonalCounts[key] = (diagonalCounts[key] || 0) + 1;
            
            // Detailn√≠ statistika pro ka≈æd√Ω prvek hlavn√≠ diagon√°ly
            const rLabel = rowLabels ? rowLabels[i] : `R${i+1}`;
            const cLabel = colLabels ? colLabels[i] : `C${i+1}`;
            mainDiagonalStats.push({
                rowLabel: rLabel,
                colLabel: cLabel,
                value: val,
                position: i
            });
        }
        
        // Vedlej≈°√≠ diagon√°la (i + j == n - 1)
        for (let i = 0; i < n; i++) {
            const j = n - 1 - i;
            const val = matrix[i][j];
            if (isFinite(val)) {
                antiDiagonalSum += val;
            }
            const key = !isFinite(val) ? '‚àû' : val;
            antiDiagonalCounts[key] = (antiDiagonalCounts[key] || 0) + 1;
            
            // Detailn√≠ statistika pro ka≈æd√Ω prvek vedlej≈°√≠ diagon√°ly
            const rLabel = rowLabels ? rowLabels[i] : `R${i+1}`;
            const cLabel = colLabels ? colLabels[j] : `C${j+1}`;
            antiDiagonalStats.push({
                rowLabel: rLabel,
                colLabel: cLabel,
                value: val,
                position: i
            });
        }
    }

    return {
        positiveCount, negativeCount, zeroCount, infinityCount,
        totalCount: n * m, totalSum, rowSums, colSums, valueCounts,
        diagonalSum, diagonalCounts, antiDiagonalSum, antiDiagonalCounts,
        mainDiagonalStats, antiDiagonalStats,
        rowStats, colStats,
        rowLabels: rowLabels || Array(n).fill(null).map((_, i) => `R${i+1}`),
        colLabels: colLabels || Array(m).fill(null).map((_, i) => `C${i+1}`)
    };
}

function createMatrixStatsHTML(stats, options = {}) {
    let html = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
    const hasPosNeg = stats.positiveCount > 0 || stats.negativeCount > 0;

    if (hasPosNeg) {
        html += `<div style="display: flex; gap: 1.5rem; margin-bottom: 0.75rem; font-size: 1rem;">`;
        if (stats.positiveCount > 0) html += `<div><span style="color: #198754; font-weight: bold;">‚úî Kladn√©:</span> ${stats.positiveCount}</div>`;
        if (stats.negativeCount > 0) html += `<div><span style="color: #dc3545; font-weight: bold;">‚úñ Z√°porn√©:</span> ${stats.negativeCount}</div>`;
        if (stats.zeroCount > 0) html += `<div><span style="color: #6c757d; font-weight: bold;">_ Nulov√©:</span> ${stats.zeroCount}</div>`;
        html += `</div>`;
    }

    const toggleId = `toggle-${Math.random().toString(36).substr(2, 9)}`;
    const filterId = `filter-${Math.random().toString(36).substr(2, 9)}`;
    html += `
        <div style="margin-bottom: 1rem;">
            <input type="checkbox" id="${toggleId}" class="matrix-stats-toggle" style="display: none;">
            <label for="${toggleId}" style="cursor: pointer; color: #0d6efd; text-decoration: underline;">Zobrazit/skr√Ωt pokroƒçil√© statistiky (souƒçty)</label>
            <div class="advanced-stats" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background-color: #fff; border-radius: 0.25rem; border: 1px solid #dee2e6;">
    `;
    
    if (options.showRowColSums && stats.rowStats && stats.colStats) {
        // Pomocn√° funkce pro form√°tov√°n√≠ poƒçt≈Ø hodnot
        const formatCounts = (counts) => {
            const sortedKeys = Object.keys(counts).sort((a, b) => (a === '‚àû' ? 1 : (b === '‚àû' ? -1 : a - b)));
            return sortedKeys.map(key => `${key}√ó${counts[key]}`).join(', ');
        };
        
        // Filtr pro rychl√© vyhled√°n√≠ uzlu
        html += `<div style="margin-bottom: 0.75rem; padding: 0.5rem; background-color: #e7f3ff; border-radius: 0.25rem;">
            <strong style="color: #0d6efd;">üîç Filtr uzl≈Ø:</strong>
            <input type="text" id="${filterId}" placeholder="Zadejte n√°zev uzlu pro filtrov√°n√≠..." 
                   style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; border: 1px solid #ced4da; border-radius: 0.25rem; width: 200px;"
                   oninput="filterMatrixStatsTables(this.value, '${filterId}')">
            <button onclick="document.getElementById('${filterId}').value=''; filterMatrixStatsTables('', '${filterId}')" 
                    style="margin-left: 0.25rem; padding: 0.25rem 0.5rem; font-size: 0.85em;">Vymazat</button>
        </div>`;
        
        // ≈ò√°dky s podrobn√Ωmi statistikami
        html += `<div style="margin-bottom: 0.75rem;">
            <strong style="color: #0d6efd;">üìä Statistiky ≈ô√°dk≈Ø (uzly):</strong>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 0.5rem; font-size: 0.9em;">
                <table class="stats-table-rows-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.95em;">
                    <thead>
                        <tr style="background-color: #e9ecef;">
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">Uzel</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: right; border: 1px solid #dee2e6;">Souƒçet</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: center; border: 1px solid #dee2e6;">+ / ‚àí / 0</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">Poƒçty hodnot</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${stats.rowStats.map((rs, i) => `
                            <tr data-node="${stats.rowLabels[i]}">
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${stats.rowLabels[i]}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right;">${rs.sum}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">
                                    <span style="color: #198754;">${rs.positive}</span> / 
                                    <span style="color: #dc3545;">${rs.negative}</span> / 
                                    <span style="color: #6c757d;">${rs.zero}</span>
                                </td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-size: 0.9em;">${formatCounts(rs.counts)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>`;
        
        // Sloupce s podrobn√Ωmi statistikami
        html += `<div style="margin-bottom: 0.75rem;">
            <strong style="color: #0d6efd;">üìä Statistiky sloupc≈Ø (uzly):</strong>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 0.5rem; font-size: 0.9em;">
                <table class="stats-table-cols-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.95em;">
                    <thead>
                        <tr style="background-color: #e9ecef;">
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">Uzel</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: right; border: 1px solid #dee2e6;">Souƒçet</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: center; border: 1px solid #dee2e6;">+ / ‚àí / 0</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">Poƒçty hodnot</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${stats.colStats.map((cs, i) => `
                            <tr data-node="${stats.colLabels[i]}">
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${stats.colLabels[i]}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right;">${cs.sum}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">
                                    <span style="color: #198754;">${cs.positive}</span> / 
                                    <span style="color: #dc3545;">${cs.negative}</span> / 
                                    <span style="color: #6c757d;">${cs.zero}</span>
                                </td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-size: 0.9em;">${formatCounts(cs.counts)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>`;
        
        html += `<hr style="margin: 0.5rem 0;"/>`;
    }
    
    const sortedKeys = Object.keys(stats.valueCounts).sort((a, b) => (a === '‚àû' ? 1 : (b === '‚àû' ? -1 : a - b)));
    const valueCountsHTML = sortedKeys.map(key => {
        const count = stats.valueCounts[key];
        const percentage = ((count / stats.totalCount) * 100).toFixed(1);
        return `<div style="display: inline-block; margin: 0.25rem 1rem 0.25rem 0;">
            <strong>${key}:</strong> ${count}√ó <span style="color: #6c757d;">(${percentage}%)</span>
        </div>`;
    }).join('');

    html += `
            <div>${valueCountsHTML}</div>
            <div style="margin-top: 0.5rem; border-top: 1px solid #dee2e6; padding-top: 0.5rem;">
                <strong>Celkov√Ω souƒçet (koneƒçn√© hodnoty):</strong> ${stats.totalSum.toFixed(2)} |
                <strong>Celkem hodnot:</strong> ${stats.totalCount}
            </div>
    `;

    // Hlavn√≠ diagon√°la s detaily
    if (stats.mainDiagonalStats && stats.mainDiagonalStats.length > 0) {
        const diagonalCountsHTML = Object.keys(stats.diagonalCounts).map(key => {
            const count = stats.diagonalCounts[key];
            return `<strong>${key}:</strong> ${count}√ó`;
        }).join(', ');

        html += `
            <div style="margin-top: 0.5rem; border-top: 1px solid #dee2e6; padding-top: 0.5rem;">
                <strong style="color: #0d6efd;">‚ÜòÔ∏è Hlavn√≠ diagon√°la:</strong><br>
                <div style="margin-left: 1rem;">
                    <strong>Souƒçet:</strong> ${stats.diagonalSum.toFixed(2)} | 
                    <strong>Poƒçty hodnot:</strong> ${diagonalCountsHTML}
                </div>
                <details style="margin-top: 0.25rem;">
                    <summary style="cursor: pointer; color: #0d6efd;">Zobrazit jednotliv√© prvky diagon√°ly</summary>
                    <div style="max-height: 150px; overflow-y: auto; margin-top: 0.25rem;">
                        <table class="stats-table-diag-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Pozice</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">≈ò√°dek (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Sloupec (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Hodnota</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${stats.mainDiagonalStats.map((d, idx) => `
                                    <tr data-node="${d.rowLabel}">
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">[${idx},${idx}]</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.rowLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.colLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right; ${d.value > 0 ? 'color: #198754;' : d.value < 0 ? 'color: #dc3545;' : ''}">${isFinite(d.value) ? d.value : '‚àû'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </details>
            </div>
        `;
    }

    // Vedlej≈°√≠ diagon√°la s detaily
    if (stats.antiDiagonalStats && stats.antiDiagonalStats.length > 0) {
        const antiDiagonalCountsHTML = Object.keys(stats.antiDiagonalCounts).map(key => {
            const count = stats.antiDiagonalCounts[key];
            return `<strong>${key}:</strong> ${count}√ó`;
        }).join(', ');

        html += `
            <div style="margin-top: 0.5rem; border-top: 1px solid #dee2e6; padding-top: 0.5rem;">
                <strong style="color: #0d6efd;">‚ÜôÔ∏è Vedlej≈°√≠ diagon√°la:</strong><br>
                <div style="margin-left: 1rem;">
                    <strong>Souƒçet:</strong> ${stats.antiDiagonalSum.toFixed(2)} | 
                    <strong>Poƒçty hodnot:</strong> ${antiDiagonalCountsHTML}
                </div>
                <details style="margin-top: 0.25rem;">
                    <summary style="cursor: pointer; color: #0d6efd;">Zobrazit jednotliv√© prvky vedlej≈°√≠ diagon√°ly</summary>
                    <div style="max-height: 150px; overflow-y: auto; margin-top: 0.25rem;">
                        <table class="stats-table-antidiag-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Pozice</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">≈ò√°dek (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Sloupec (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Hodnota</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${stats.antiDiagonalStats.map((d, idx) => {
                                    const n = stats.antiDiagonalStats.length;
                                    return `
                                    <tr data-node="${d.rowLabel}">
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">[${idx},${n - 1 - idx}]</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.rowLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.colLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right; ${d.value > 0 ? 'color: #198754;' : d.value < 0 ? 'color: #dc3545;' : ''}">${isFinite(d.value) ? d.value : '‚àû'}</td>
                                    </tr>
                                `}).join('')}
                            </tbody>
                        </table>
                    </div>
                </details>
            </div>
        `;
    }

    html += `</div></div>`;

    return html;
}

// Funkce pro filtrov√°n√≠ tabulek statistik podle uzlu
function filterMatrixStatsTables(filterValue, filterId) {
    const filter = filterValue.toLowerCase().trim();
    const tables = document.querySelectorAll(`.stats-table-rows-${filterId}, .stats-table-cols-${filterId}, .stats-table-diag-${filterId}, .stats-table-antidiag-${filterId}`);
    
    tables.forEach(table => {
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const nodeName = row.getAttribute('data-node');
            if (!filter || (nodeName && nodeName.toLowerCase().includes(filter))) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
    });
}

function createListTable(map) {
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');
    for (const key of Object.keys(map)) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = key;
        tr.appendChild(th);
        const td = document.createElement('td');
        td.textContent = map[key].join(', ');
        tr.appendChild(td);
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
}

let currentGraph = null;

document.getElementById('parseBtn').addEventListener('click', () => {
    const input = document.getElementById('graphInput').value;
    const graph = new Graph();
    graph.parse(input);
    currentGraph = graph;
    
    const output = document.getElementById('output');
    output.innerHTML = '';
    
    if (graph.nodes.length === 0) {
        output.textContent = 'Nebyl rozpozn√°n ≈æ√°dn√Ω uzel. Zkontrolujte pros√≠m vstup.';
        document.getElementById('counters').style.display = 'none';
        return;
    }

    // ‚ö° D≈ÆLE≈ΩIT√â: Z√≠skej properties() hned na zaƒç√°tku, pou≈æ√≠v√° se to v≈°ude!
    const props = graph.properties();

    // Update counters
    document.getElementById('nodeCount').textContent = graph.nodes.length;
    document.getElementById('edgeCount').textContent = graph.edges.length;
    document.getElementById('componentCount').textContent = graph.countComponents();
    document.getElementById('counters').style.display = 'block';

    // üìä STATISTICK√Å SEKCE - Kompletn√≠ p≈ôehled grafu
    const statsSection = document.createElement('div');
    statsSection.id = 'statisticsSection';
    statsSection.style.margin = '1rem 0';
    statsSection.style.padding = '1rem';
    statsSection.style.backgroundColor = '#f8f9fa';
    statsSection.style.border = '1px solid #dee2e6';
    statsSection.style.borderRadius = '0.25rem';
    
    const statsHeader = document.createElement('h2');
    statsHeader.style.marginTop = '0';
    statsHeader.style.color = '#0d6efd';
    statsHeader.innerHTML = 'üìä Kompletn√≠ statistick√Ω p≈ôehled';
    statsSection.appendChild(statsHeader);
    
    const statsBtn = document.createElement('button');
    statsBtn.textContent = 'Zobrazit statistiky';
    statsBtn.style.marginBottom = '1rem';
    
    const statsContent = document.createElement('div');
    statsContent.style.display = 'none';
    
    statsBtn.addEventListener('click', () => {
        if (statsContent.style.display === 'none') {
            const stats = graph.getStatistics();
            const degrees = graph.degrees();
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">';
            
            // üìà Z√°kladn√≠ metriky
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #0d6efd;">
                    <h3 style="margin-top: 0; color: #0d6efd;">üìà Z√°kladn√≠ metriky</h3>
                    <div style="line-height: 1.8;">
                        <strong>Uzly:</strong> ${stats.nodeCount}<br>
                        <strong>Hrany:</strong> ${stats.edgeCount}<br>
                        <strong>Komponenty:</strong> ${stats.componentCount}<br>
                        <strong>Izolovan√© uzly:</strong> ${stats.isolatedNodes.length}${stats.isolatedNodes.length > 0 ? ` (${stats.isolatedNodes.slice(0, 5).join(', ')}${stats.isolatedNodes.length > 5 ? '...' : ''})` : ''}<br>
                        <strong>Smyƒçky:</strong> ${stats.loops}<br>
                        <strong>Hustota grafu:</strong> ${(stats.density * 100).toFixed(2)}%
                    </div>
                </div>
            `;

            // üìè Nejkrat≈°√≠ a nejdel≈°√≠ hrana
            if (stats.shortestEdge) {
                const shortest = stats.shortestEdge;
                const longest = stats.longestEdge;
                const shortestWeight = shortest.weight !== null && shortest.weight !== undefined ? shortest.weight : 1;
                const longestWeight = longest.weight !== null && longest.weight !== undefined ? longest.weight : 1;
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #6f42c1;">
                        <h3 style="margin-top: 0; color: #6f42c1;">üìè Nejkrat≈°√≠ a nejdel≈°√≠ hrana</h3>
                        <div style="line-height: 1.8;">
                            <strong>Nejkrat≈°√≠:</strong> ${shortest.u} ‚Üí ${shortest.v} (v√°ha: ${shortestWeight})<br>
                            <strong>Nejdel≈°√≠:</strong> ${longest.u} ‚Üí ${longest.v} (v√°ha: ${longestWeight})
                        </div>
                    </div>
                `;
            }
            if (stats.edgeWeights) {
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #fd7e14;">
                        <h3 style="margin-top: 0; color: #fd7e14;">‚öñÔ∏è Statistiky vah hran</h3>
                        <div style="line-height: 1.8;">
                            <strong>Min v√°ha:</strong> ${stats.edgeWeights.min}<br>
                            <strong>Max v√°ha:</strong> ${stats.edgeWeights.max}<br>
                            <strong>Pr≈Ømƒõrn√° v√°ha:</strong> ${stats.edgeWeights.avg.toFixed(2)}<br>
                            <strong>Distribuce:</strong> ${Object.entries(stats.edgeWeights.distribution).map(([w, c]) => `${w}: ${c}√ó`).join(', ')}
                        </div>
                    </div>
                `;
            }
            
            // üéØ Stupnƒõ uzl≈Ø
            const degDistKeys = Object.keys(stats.degrees.distribution).map(Number).sort((a, b) => a - b);
            const degDistStr = degDistKeys.slice(0, 10).map(deg => `${deg}: ${stats.degrees.distribution[deg]}√ó`).join(', ');
            
            // ‚ö° NOV√â: Pro orientovan√© grafy zobraz IN/OUT stupnƒõ
            let degreeDetailsHTML = '';
            if (stats.inDegrees && stats.outDegrees) {
                degreeDetailsHTML = `
                    <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid #dee2e6;">
                    <strong style="color: #0d6efd;">IN-degree:</strong><br>
                    <span style="margin-left: 1rem;">Min: ${stats.inDegrees.min} | Max: ${stats.inDegrees.max} | √ò ${stats.inDegrees.avg.toFixed(2)}</span><br>
                    <strong style="color: #dc3545;">OUT-degree:</strong><br>
                    <span style="margin-left: 1rem;">Min: ${stats.outDegrees.min} | Max: ${stats.outDegrees.max} | √ò ${stats.outDegrees.avg.toFixed(2)}</span>
                `;
            }
            
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #198754;">
                    <h3 style="margin-top: 0; color: #198754;">üéØ Stupnƒõ uzl≈Ø</h3>
                    <div style="line-height: 1.8;">
                        <strong>Min:</strong> ${stats.degrees.min}<br>
                        <strong>Max:</strong> ${stats.degrees.max}<br>
                        <strong>Pr≈Ømƒõr:</strong> ${stats.degrees.avg.toFixed(2)}<br>
                        <strong>Medi√°n:</strong> ${stats.degrees.median}<br>
                        ${degreeDetailsHTML}
                        <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid #dee2e6;">
                        <strong>Distribuce:</strong><br>
                        <span style="font-size: 0.9rem; color: #666;">${degDistStr}${degDistKeys.length > 10 ? '...' : ''}</span>
                    </div>
                </div>
            `;
            
            // üîó Hrany
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #dc3545;">
                    <h3 style="margin-top: 0; color: #dc3545;">üîó Hrany</h3>
                    <div style="line-height: 1.8;">
                        <strong>Orientovan√©:</strong> ${stats.directedEdges}<br>
                        <strong>Neorientovan√©:</strong> ${stats.undirectedEdges}<br>
                        <strong>S vahami:</strong> ${stats.weightedEdges}<br>
                        <strong>N√°sobn√© hrany:</strong> ${stats.multipleEdgeGroups} skupin (${stats.totalMultipleEdges} hran)<br>
                        <strong>Smyƒçky:</strong> ${stats.loops}
                    </div>
                </div>
            `;
            
            // üå≥ Komponenty
            if (stats.componentSizes) {
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #ffc107;">
                        <h3 style="margin-top: 0; color: #f59f00;">üå≥ Komponenty</h3>
                        <div style="line-height: 1.8;">
                            <strong>Poƒçet komponent:</strong> ${stats.componentCount}<br>
                            <strong>Nejvƒõt≈°√≠:</strong> ${stats.largestComponent} uzl≈Ø<br>
                            <strong>Nejmen≈°√≠:</strong> ${stats.smallestComponent} uzl≈Ø<br>
                            <strong>Velikosti:</strong> ${stats.componentSizes.slice(0, 10).join(', ')}${stats.componentSizes.length > 10 ? '...' : ''}
                        </div>
                    </div>
                `;
            }
            
            // üìè Pr≈Ømƒõr a polomƒõr (pokud vypoƒç√≠t√°no)
            if (stats.diameter !== null) {
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #6f42c1;">
                        <h3 style="margin-top: 0; color: #6f42c1;">üìè Pr≈Ømƒõr a polomƒõr</h3>
                        <div style="line-height: 1.8;">
                            <strong>Pr≈Ømƒõr grafu:</strong> ${stats.diameter}<br>
                            <strong>Polomƒõr grafu:</strong> ${stats.radius}<br>
                            <strong>Centr√°ln√≠ uzly:</strong> ${stats.centerNodes.slice(0, 10).join(', ')}${stats.centerNodes.length > 10 ? '...' : ''}<br>
                            <strong>Perifern√≠ uzly:</strong> ${stats.peripheralNodes.slice(0, 10).join(', ')}${stats.peripheralNodes.length > 10 ? '...' : ''}
                        </div>
                    </div>
                `;
            } else if (stats.nodeCount > 100) {
                html += `
                    <div style="background-color: #fff3cd; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #ffc107;">
                        <h3 style="margin-top: 0; color: #856404;">üìè Pr≈Ømƒõr a polomƒõr</h3>
                        <div style="line-height: 1.8;">
                            <em>P≈ô√≠li≈° velk√Ω graf pro v√Ωpoƒçet pr≈Ømƒõru (> 100 uzl≈Ø)</em>
                        </div>
                    </div>
                `;
            }
            
            // üèÜ TOP uzly podle stupnƒõ
            const topNodes = Object.entries(degrees)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
            
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #20c997; grid-column: span 1;">
                    <h3 style="margin-top: 0; color: #20c997;">üèÜ TOP uzly (nejvy≈°≈°√≠ stupe≈à)</h3>
                    <div style="line-height: 1.6; font-size: 0.9rem;">
                        ${topNodes.map(([node, deg], i) => `${i + 1}. <strong>${node}</strong> (${deg})`).join('<br>')}
                    </div>
                </div>
            `;
            
            // üìâ Histogram stup≈à≈Ø (pokud ne moc uzl≈Ø)
            if (stats.nodeCount <= 50) {
                const maxFreq = Math.max(...Object.values(stats.degrees.distribution));
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #0dcaf0; grid-column: span 2;">
                        <h3 style="margin-top: 0; color: #0dcaf0;">üìâ Histogram stup≈à≈Ø</h3>
                        <div style="font-family: monospace; font-size: 0.85rem; line-height: 1.4;">
                `;
                
                for (const deg of degDistKeys) {
                    const count = stats.degrees.distribution[deg];
                    const barWidth = Math.round((count / maxFreq) * 40);
                    const bar = '‚ñà'.repeat(barWidth);
                    html += `Stupe≈à ${deg.toString().padStart(2)}: ${bar} ${count}<br>`;
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // Legenda
            html += `
                <div style="margin-top: 1rem; padding: 0.75rem; background-color: #e7f3ff; border-radius: 0.25rem; border: 1px solid #0d6efd;">
                    <strong>üí° Vysvƒõtlen√≠ pojm≈Ø:</strong><br>
                    <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; line-height: 1.6;">
                        ‚Ä¢ <strong>Hustota:</strong> Pomƒõr skuteƒçn√Ωch hran k max. mo≈æn√Ωm (0% = ≈æ√°dn√© hrany, 100% = √∫pln√Ω graf)<br>
                        ‚Ä¢ <strong>Pr≈Ømƒõr:</strong> Maxim√°ln√≠ excentricita = nejdel≈°√≠ nejkrat≈°√≠ cesta mezi libovoln√Ωmi uzly<br>
                        ‚Ä¢ <strong>Polomƒõr:</strong> Minim√°ln√≠ excentricita = centrum grafu<br>
                        ‚Ä¢ <strong>Centr√°ln√≠ uzly:</strong> Uzly s nejmen≈°√≠ excentricitou (nejbl√≠≈æ ke v≈°em ostatn√≠m)<br>
                        ‚Ä¢ <strong>Perifern√≠ uzly:</strong> Uzly s nejvƒõt≈°√≠ excentricitou (nejd√°l od ostatn√≠ch)
                    </div>
                </div>
            `;
            
            statsContent.innerHTML = html;
            statsContent.style.display = 'block';
            statsBtn.textContent = 'Skr√Ωt statistiky';
        } else {
            statsContent.style.display = 'none';
            statsBtn.textContent = 'Zobrazit statistiky';
        }
    });
    
    statsSection.appendChild(statsBtn);
    statsSection.appendChild(statsContent);
    output.appendChild(statsSection);

    // Query sections for each matrix type
    const createQuerySection = (title, matrixType) => {
    const section = document.createElement('div');
    section.className = 'query-section';
    section.innerHTML = `<h3>${title}</h3>`;
    
    const inputDiv = document.createElement('div');
    inputDiv.className = 'query-inputs';
    
    const datalistId = `nodes-datalist-${matrixType}`;
    const datalist = document.createElement('datalist');
    datalist.id = datalistId;
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        datalist.appendChild(option);
    });
    section.appendChild(datalist);

    const selectU = document.createElement('input');
    selectU.setAttribute('list', datalistId);
    selectU.className = 'node-input';
    const selectV = document.createElement('input');
    selectV.setAttribute('list', datalistId);
    selectV.className = 'node-input';
    
    const queryBtn = document.createElement('button');
    queryBtn.textContent = 'Dotaz';
    
    const resultDiv = document.createElement('div');
    resultDiv.className = 'query-result';
    resultDiv.style.display = 'none';
    
    queryBtn.addEventListener('click', () => {
        const u = selectU.value;
        const v = selectV.value;
        let result;
        
        switch(matrixType) {
            case 'adjacency':
                result = graph.adjacencyValue(u, v);
                resultDiv.textContent = `A[${u}, ${v}] = ${result}`;
                break;
            case 'sign':
                result = graph.signValue(u, v);
                resultDiv.textContent = `S[${u}, ${v}] = ${result}`;
                break;
            case 'length':
                result = graph.lengthValue(u, v);
                resultDiv.textContent = `L[${u}, ${v}] = ${result === Infinity ? '‚àû' : result}`;
                break;
            case 'power2':
                result = graph.adjacencyPowerValue(u, v, 2);
                resultDiv.textContent = `A¬≤[${u}, ${v}] = ${result}`;
                break;
            case 'power3':
                result = graph.adjacencyPowerValue(u, v, 3);
                resultDiv.textContent = `A¬≥[${u}, ${v}] = ${result}`;
                break;
            case 'laplacian':
                result = graph.laplacianValue(u, v);
                resultDiv.innerHTML = `Laplaci√°nsk√° matice <strong>L[${u}, ${v}] = ${result}</strong><br>
                    <small>L = D - A (D = matice stup≈à≈Ø, A = matice sousednosti)</small>`;
                break;
            case 'multiplicity':
                result = graph.multiplicityValue(u, v);
                resultDiv.innerHTML = `Multiplicita hran mezi <strong>${u}</strong> a <strong>${v}</strong>: <strong>${result}</strong><br>
                    <small>Poƒçet v≈°ech hran (vƒçetnƒõ paraleln√≠ch) spojuj√≠c√≠ch tyto uzly</small>`;
                break;
            case 'shortest':
                result = graph.shortestPath(u, v);
                if (result.distance === Infinity) {
                    resultDiv.textContent = `Nejkrat≈°√≠ cesta z ${u} do ${v}: neexistuje`;
                } else {
                    const pathStr = result.path.join(' ‚Üí ');
                    resultDiv.innerHTML = `Nejkrat≈°√≠ cesta z <strong>${u}</strong> do <strong>${v}</strong>:<br>
                        D√©lka: <strong>${result.distance}</strong><br>
                        Sled: <strong>${pathStr}</strong>`;
                }
                break;
        }
        resultDiv.style.display = 'block';
    });
    
    // ‚úÖ OPRAVA: Spr√°vn√© vytv√°≈ôen√≠ labelu a p≈ôid√°n√≠ element≈Ø
    const labelU = document.createElement('span');
    labelU.textContent = 'Od uzlu: ';
    inputDiv.appendChild(labelU);
    inputDiv.appendChild(selectU);
    
    const labelV = document.createElement('span');
    labelV.textContent = ' Do uzlu: ';
    inputDiv.appendChild(labelV);
    inputDiv.appendChild(selectV);
    
    inputDiv.appendChild(queryBtn);
    
    section.appendChild(inputDiv);
    section.appendChild(resultDiv);
    return section;
};

    // Node and edge list with degrees (scrollable)
    const listSection = document.createElement('div');
    listSection.className = 'section';
    listSection.innerHTML = '<h2>Seznam uzl≈Ø a hran</h2>';
    
    const degrees = graph.degrees();
    const nodeListDiv = document.createElement('div');
    nodeListDiv.className = 'scrollable-list';
    const nodeList = document.createElement('ul');
    nodeList.style.listStyle = 'none';
    nodeList.style.padding = '0';
    
    // ‚ö° VYLEP≈†EN√ç: Pro orientovan√© grafy zobraz IN/OUT stupnƒõ
    const showDirectedDegrees = props.oriented === 'orientovan√Ω';
    
    graph.nodes.forEach(id => {
        const li = document.createElement('li');
        const w = graph.nodeWeights[id];
        const deg = degrees[id];
        
        let degreeInfo = '';
        if (showDirectedDegrees) {
            // Pro orientovan√©: spoƒç√≠tej in/out degree
            let inDegree = 0;
            let outDegree = 0;
            for (const e of graph.edges) {
                if (e.direction === '>' && e.u === id) outDegree++;
                else if (e.direction === '>' && e.v === id) inDegree++;
                else if (e.direction === '<' && e.u === id) inDegree++;
                else if (e.direction === '<' && e.v === id) outDegree++;
                else if (e.direction === '-') {
                    // Neorientovan√© hrany v mixed grafu
                    if (e.u === id || e.v === id) {
                        if (e.u === e.v) { inDegree++; outDegree++; } // Smyƒçka
                        else { inDegree++; outDegree++; }
                    }
                }
            }
            degreeInfo = `<span class="degree-info">in: ${inDegree} | out: ${outDegree} | celkem: ${deg}</span>`;
        } else {
            degreeInfo = `<span class="degree-info">stupe≈à: ${deg}</span>`;
        }
        
        li.innerHTML = `<strong>Uzel ${id}</strong>${w !== null && w !== undefined ? ` (hodnota: ${w})` : ''}${degreeInfo}`;
        nodeList.appendChild(li);
    });
    nodeListDiv.appendChild(nodeList);
    listSection.appendChild(nodeListDiv);
    
    const edgeListDiv = document.createElement('div');
    edgeListDiv.className = 'scrollable-list';
    const edgeList = document.createElement('ul');
    edgeList.style.listStyle = 'none';
    edgeList.style.padding = '0';
    graph.edges.forEach(e => {
        const li = document.createElement('li');
        const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
        const label = e.label ? ` [${e.label}]` : '';
        let orientation;
        if (e.direction === '>') orientation = '‚Üí';
        else if (e.direction === '<') orientation = '‚Üê';
        else orientation = '‚Äî';
        li.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
        edgeList.appendChild(li);
    });
    edgeListDiv.appendChild(edgeList);
    listSection.appendChild(edgeListDiv);
    output.appendChild(listSection);

    // Adjacency matrix with query and binary/count toggle
    const adjSection = document.createElement('div');
    adjSection.className = 'section';
    adjSection.innerHTML = '<h2>Matice sousednosti</h2>';
    
    const adjLegendDiv = document.createElement('div');
    adjLegendDiv.style.backgroundColor = '#e7f3ff';
    adjLegendDiv.style.padding = '0.75rem';
    adjLegendDiv.style.borderRadius = '0.25rem';
    adjLegendDiv.style.marginBottom = '1rem';
    adjLegendDiv.style.border = '1px solid #0d6efd';
    adjLegendDiv.innerHTML = `
        <strong>üìä Matice sousednosti A[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>A[i,j] = 0:</strong> Bez hrany z i do j<br>
            ‚Ä¢ <strong>A[i,j] = 1:</strong> Existuje hrana z i do j<br>
            ‚Ä¢ <strong>A[i,j] ‚â• 2:</strong> V√≠ce paraleln√≠ch hran (multigraf)<br>
            ‚Ä¢ <strong>Symetrick√° matice:</strong> Graf je neorientovan√Ω
        </div>
    `;
    adjSection.appendChild(adjLegendDiv);
    
    const adjToggleDiv = document.createElement('div');
    adjToggleDiv.style.marginBottom = '1rem';
    adjToggleDiv.innerHTML = '<label><input type="checkbox" id="adjBinary" /> Bin√°rn√≠ verze (0/1)</label>';
    adjSection.appendChild(adjToggleDiv);
    
    adjSection.appendChild(createQuerySection('Dotaz na hodnotu', 'adjacency'));

    
    const showAdjBtn = document.createElement('button');
    showAdjBtn.textContent = 'Zobrazit celou matici';
    const adjMatrixDiv = document.createElement('div');
    adjMatrixDiv.className = 'matrix';
    adjMatrixDiv.style.display = 'none';
    const adjStatsDiv = document.createElement('div');
    adjStatsDiv.style.display = 'none';
    adjStatsDiv.style.marginTop = '1rem';
    adjStatsDiv.style.padding = '1rem';
    adjStatsDiv.style.backgroundColor = '#e7f3ff';
    adjStatsDiv.style.borderRadius = '0.25rem';
    
    showAdjBtn.addEventListener('click', () => {
        if (adjMatrixDiv.style.display === 'none') {
            const binary = document.getElementById('adjBinary').checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            const stats = calculateMatrixStats(adjMat, graph.nodes, graph.nodes);
            adjStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });
            
            adjMatrixDiv.style.display = 'block';
            adjStatsDiv.style.display = 'block';
            showAdjBtn.textContent = 'Skr√Ωt matici';
        } else {
            adjMatrixDiv.style.display = 'none';
            adjStatsDiv.style.display = 'none';
            showAdjBtn.textContent = 'Zobrazit celou matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'adjBinary' && adjMatrixDiv.style.display === 'block') {
            const binary = e.target.checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            const { colStats, totalZeros, totalOnes } = countBinaryMatrix(adjMat);
            adjStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Celkov√° statistika hodnot 0 a 1:</h4>';
            adjStatsDiv.innerHTML += `<div style="display: flex; gap: 2rem; margin-top: 0.5rem;">`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #0b5ed7; font-weight: bold;">Poƒçet 1:</span> ${totalOnes}√ó</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #dc3545; font-weight: bold;">Poƒçet 0:</span> ${totalZeros}√ó</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="font-weight: bold;">Celkem:</span> ${totalOnes + totalZeros}</div>`;
            adjStatsDiv.innerHTML += `</div>`;
        }
    });
    
    adjSection.appendChild(showAdjBtn);
    adjSection.appendChild(adjMatrixDiv);
    adjSection.appendChild(adjStatsDiv);
    output.appendChild(adjSection);

    // Sign matrix with query
    const signSection = document.createElement('div');
    signSection.className = 'section';
    signSection.innerHTML = '<h2>Znam√©nkov√° matice</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const signLegendDiv = document.createElement('div');
    signLegendDiv.style.backgroundColor = '#e7f3ff';
    signLegendDiv.style.padding = '0.75rem';
    signLegendDiv.style.borderRadius = '0.25rem';
    signLegendDiv.style.marginBottom = '1rem';
    signLegendDiv.style.border = '1px solid #0d6efd';
    signLegendDiv.innerHTML = `
        <strong>üìä Znam√©nkov√° matice S[i,j] = A[i,j] - A[j,i]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>S[i,j] > 0:</strong> V√≠ce hran z i do j ne≈æ z j do i<br>
            ‚Ä¢ <strong>S[i,j] < 0:</strong> V√≠ce hran z j do i ne≈æ z i do j<br>
            ‚Ä¢ <strong>S[i,j] = 0:</strong> Symetricky nebo bez hran<br>
            ‚Ä¢ <strong>Zji≈°≈•uje≈°:</strong> Asymetrii a vyv√°≈æen√≠ smƒõr≈Ø v grafu
        </div>
    `;
    signSection.appendChild(signLegendDiv);
    
    signSection.appendChild(createQuerySection('Dotaz na hodnotu', 'sign'));
    
    const showSignBtn = document.createElement('button');
    showSignBtn.textContent = 'Zobrazit celou matici';
    const signMatrixDiv = document.createElement('div');
    signMatrixDiv.className = 'matrix';
    signMatrixDiv.style.display = 'none';
    const signStatsDiv = document.createElement('div');
    signStatsDiv.style.display = 'none';
    signStatsDiv.style.marginTop = '1rem';
    signStatsDiv.style.padding = '1rem';
    signStatsDiv.style.backgroundColor = '#e7f3ff';
    signStatsDiv.style.borderRadius = '0.25rem';
    
    showSignBtn.addEventListener('click', () => {
        if (signMatrixDiv.style.display === 'none') {
            const signMat = graph.signMatrix();
            signMatrixDiv.innerHTML = '';
            signMatrixDiv.appendChild(createMatrixTable(signMat, graph.nodes, graph.nodes));
            
            const stats = calculateMatrixStats(signMat, graph.nodes, graph.nodes);
            signStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });
            
            signMatrixDiv.style.display = 'block';
            signStatsDiv.style.display = 'block';
            showSignBtn.textContent = 'Skr√Ωt matici';
        } else {
            signMatrixDiv.style.display = 'none';
            signStatsDiv.style.display = 'none';
            showSignBtn.textContent = 'Zobrazit celou matici';
        }
    });
    signSection.appendChild(showSignBtn);
    signSection.appendChild(signMatrixDiv);
    signSection.appendChild(signStatsDiv);
    output.appendChild(signSection);

    // Laplacian matrix with query
    const laplacianSection = document.createElement('div');
    laplacianSection.className = 'section';
    laplacianSection.innerHTML = '<h2>Laplaci√°nsk√° matice (L = D - A)</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const laplacianLegendDiv = document.createElement('div');
    laplacianLegendDiv.style.backgroundColor = '#e7f3ff';
    laplacianLegendDiv.style.padding = '0.75rem';
    laplacianLegendDiv.style.borderRadius = '0.25rem';
    laplacianLegendDiv.style.marginBottom = '1rem';
    laplacianLegendDiv.style.border = '1px solid #0d6efd';
    
    // ‚ö° DYNAMICK√Å vysvƒõtlivka podle typu grafu
    const isDirected = props.oriented === 'orientovan√Ω';
    laplacianLegendDiv.innerHTML = `
        <strong>üìä Laplaci√°nsk√° matice L = D - A:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>L[U,V] = 0:</strong> Uzly U a V nejsou spojeny<br>
            ‚Ä¢ <strong>L[U,V] = -1:</strong> Uzly U a V jsou p≈ô√≠mo spojeny hranou<br>
            ‚Ä¢ <strong>L[U,U]:</strong> ${isDirected ? '<strong style="color: #0d6efd;">V√Ωstupn√≠ stupe≈à</strong> (poƒçet hran VYCH√ÅZEJ√çC√çCH z U)' : '<strong>Stupe≈à uzlu</strong> (poƒçet hran dot√Ωkaj√≠c√≠ch se U)'}<br>
            ‚Ä¢ <strong>Vlastnost:</strong> Souƒçet ka≈æd√©ho ≈ô√°dku = 0
        </div>
    `;
    laplacianSection.appendChild(laplacianLegendDiv);
    
    laplacianSection.appendChild(createQuerySection('Dotaz na hodnotu L[U,V]', 'laplacian'));
    
    const showLaplacianBtn = document.createElement('button');
    showLaplacianBtn.textContent = 'Zobrazit celou matici';
    const laplacianMatrixDiv = document.createElement('div');
    laplacianMatrixDiv.className = 'matrix';
    laplacianMatrixDiv.style.display = 'none';
    const laplacianStatsDiv = document.createElement('div');
    laplacianStatsDiv.style.display = 'none';
    laplacianStatsDiv.style.marginTop = '1rem';
    laplacianStatsDiv.style.padding = '1rem';
    laplacianStatsDiv.style.backgroundColor = '#e7f3ff';
    laplacianStatsDiv.style.borderRadius = '0.25rem';
    
    showLaplacianBtn.addEventListener('click', () => {
        if (laplacianMatrixDiv.style.display === 'none') {
            const laplacianMat = graph.laplacianMatrix();
            laplacianMatrixDiv.innerHTML = '';
            laplacianMatrixDiv.appendChild(createMatrixTable(laplacianMat, graph.nodes, graph.nodes));

            const stats = calculateMatrixStats(laplacianMat, graph.nodes, graph.nodes);
            laplacianStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });

            laplacianMatrixDiv.style.display = 'block';
            laplacianStatsDiv.style.display = 'block';
            showLaplacianBtn.textContent = 'Skr√Ωt matici';
        } else {
            laplacianMatrixDiv.style.display = 'none';
            laplacianStatsDiv.style.display = 'none';
            showLaplacianBtn.textContent = 'Zobrazit celou matici';
        }
    });
    laplacianSection.appendChild(showLaplacianBtn);
    laplacianSection.appendChild(laplacianMatrixDiv);
    laplacianSection.appendChild(laplacianStatsDiv);
    output.appendChild(laplacianSection);

    // Multiplicity query section
    const multiplicitySection = document.createElement('div');
    multiplicitySection.className = 'section';
    multiplicitySection.innerHTML = '<h2>Multiplicita hran (poƒçet paraleln√≠ch hran)</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const multiplicityLegendDiv = document.createElement('div');
    multiplicityLegendDiv.style.backgroundColor = '#e7f3ff';
    multiplicityLegendDiv.style.padding = '0.75rem';
    multiplicityLegendDiv.style.borderRadius = '0.25rem';
    multiplicityLegendDiv.style.marginBottom = '1rem';
    multiplicityLegendDiv.style.border = '1px solid #0d6efd';
    multiplicityLegendDiv.innerHTML = `
        <strong>üìä Multiplicita hran:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Multiplicita = 1:</strong> Pr√°vƒõ 1 hrana (nebo v√≠ce v jednom smƒõru)<br>
            ‚Ä¢ <strong>Multiplicita > 1:</strong> V√≠ce paraleln√≠ch hran (multigraf)<br>
            ‚Ä¢ <strong>Poƒç√≠t√° obƒõ strany:</strong> Hrany U‚ÜíV a V‚ÜíU se sƒç√≠taj√≠<br>
            ‚Ä¢ <strong>Bez ohledu na v√°hu:</strong> Poƒç√≠t√° jen existenci hran, ne jejich v√°hu
        </div>
    `;
    multiplicitySection.appendChild(multiplicityLegendDiv);
    
    multiplicitySection.appendChild(createQuerySection('Dotaz na multiplicitu', 'multiplicity'));
    output.appendChild(multiplicitySection);

    // Power matrices with queries
    const powerSection = document.createElement('div');
    powerSection.className = 'section';
    powerSection.innerHTML = '<h2>Druh√° a t≈ôet√≠ mocnina matice sousednosti (poƒçet sled≈Ø d√©lky N)</h2>';
    
    // P≈ôidej legend
    const powerLegendDiv = document.createElement('div');
    powerLegendDiv.style.backgroundColor = '#e7f3ff';
    powerLegendDiv.style.padding = '0.75rem';
    powerLegendDiv.style.borderRadius = '0.25rem';
    powerLegendDiv.style.marginBottom = '1rem';
    powerLegendDiv.style.border = '1px solid #0d6efd';
    powerLegendDiv.innerHTML = `
        <strong>üìä Mocnina matice A<sup>k</sup>[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>A<sup>k</sup>[i,j] = ƒç√≠slo:</strong> Poƒçet proch√°zek d√©lky k z i do j<br>
            ‚Ä¢ <strong>A¬≤:</strong> Cesty s 2 hranami (zprost≈ôedkovan√≠ soused√©)<br>
            ‚Ä¢ <strong>A¬≥:</strong> Cesty s 3 hranami atd.<br>
            ‚Ä¢ <strong>Zji≈°≈•uje≈°:</strong> Kolik zp≈Øsob≈Ø j√≠t z i do j p≈ôesnƒõ k kroky
        </div>
    `;
    powerSection.appendChild(powerLegendDiv);
    
    powerSection.appendChild(createQuerySection('Dotaz na A¬≤', 'power2'));
    powerSection.appendChild(createQuerySection('Dotaz na A¬≥', 'power3'));
    
    // Custom power query section
    const customPowerDiv = document.createElement('div');
    customPowerDiv.className = 'query-section';
    customPowerDiv.innerHTML = '<h3>Libovoln√° mocnina matice sousednosti</h3>';
    
    // Add legend
    const customPowerLegendDiv = document.createElement('div');
    customPowerLegendDiv.style.backgroundColor = '#fff3cd';
    customPowerLegendDiv.style.padding = '0.75rem';
    customPowerLegendDiv.style.borderRadius = '0.25rem';
    customPowerLegendDiv.style.marginBottom = '1rem';
    customPowerLegendDiv.style.border = '1px solid #ffc107';
    customPowerLegendDiv.innerHTML = `
        <strong>üìñ Vysvƒõtlen√≠:</strong><br>
        <span style="margin-left: 1rem;">‚Ä¢ <strong>A<sup>k</sup>[u, v]</strong> ud√°v√° poƒçet cest <strong>d√©lky k</strong> z uzlu <strong>u</strong> do uzlu <strong>v</strong></span><br>
        <span style="margin-left: 1rem;">‚Ä¢ Nap≈ô√≠klad A<sup>3</sup>[A, C] = 5 znamen√°, ≈æe existuje <strong>5 r≈Øzn√Ωch cest d√©lky 3</strong> z uzlu A do uzlu C</span><br>
        <span style="margin-left: 1rem;">‚Ä¢ D√©lka cesty = poƒçet hran v cestƒõ (ne poƒçet uzl≈Ø!)</span>
    `;
    customPowerDiv.appendChild(customPowerLegendDiv);
    
    const customPowerInputDiv = document.createElement('div');
    customPowerInputDiv.className = 'query-inputs';

    const powerDatalist = document.createElement('datalist');
    powerDatalist.id = 'nodes-datalist-power';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        powerDatalist.appendChild(option);
    });
    customPowerDiv.appendChild(powerDatalist);

    const selectPowerU = document.createElement('input');
    selectPowerU.setAttribute('list', 'nodes-datalist-power');
    const selectPowerV = document.createElement('input');
    selectPowerV.setAttribute('list', 'nodes-datalist-power');
    
    const powerInput = document.createElement('input');
    powerInput.type = 'number';
    powerInput.min = '1';
    powerInput.max = '20';
    powerInput.value = '4';
    powerInput.style.width = '80px';
    powerInput.style.padding = '0.5rem';
    powerInput.style.border = '1px solid #ced4da';
    powerInput.style.borderRadius = '0.25rem';
    
    const customPowerBtn = document.createElement('button');
    customPowerBtn.textContent = 'Vypoƒç√≠tat';
    
    const customPowerResultDiv = document.createElement('div');
    customPowerResultDiv.className = 'query-result';
    customPowerResultDiv.style.display = 'none';
    
    customPowerBtn.addEventListener('click', () => {
        const u = selectPowerU.value;
        const v = selectPowerV.value;
        const k = parseInt(powerInput.value);
        
        if (k < 1 || k > 20) {
            customPowerResultDiv.textContent = 'Mocnina mus√≠ b√Ωt mezi 1 a 20';
            customPowerResultDiv.style.display = 'block';
            return;
        }
        
        customPowerBtn.disabled = true;
        customPowerBtn.textContent = 'Poƒç√≠t√°m...';
        
        setTimeout(() => {
            const result = graph.adjacencyPowerValue(u, v, k);
            customPowerResultDiv.textContent = `A^${k}[${u}, ${v}] = ${result}`;
            customPowerResultDiv.style.display = 'block';
            customPowerBtn.disabled = false;
            customPowerBtn.textContent = 'Vypoƒç√≠tat';
        }, 50);
    });
    
    const labelPowerU = document.createElement('span');
    labelPowerU.textContent = 'Od uzlu: ';
    customPowerInputDiv.appendChild(labelPowerU);
    customPowerInputDiv.appendChild(selectPowerU);
    
    const labelPowerV = document.createElement('span');
    labelPowerV.textContent = ' Do uzlu: ';
    customPowerInputDiv.appendChild(labelPowerV);
    customPowerInputDiv.appendChild(selectPowerV);
    
    const labelPower = document.createElement('span');
    labelPower.textContent = ' Mocnina: ';
    customPowerInputDiv.appendChild(labelPower);
    customPowerInputDiv.appendChild(powerInput);
    customPowerInputDiv.appendChild(customPowerBtn);
    
    customPowerDiv.appendChild(customPowerInputDiv);
    customPowerDiv.appendChild(customPowerResultDiv);
    powerSection.appendChild(customPowerDiv);
    
    const showPowerBtn = document.createElement('button');
    showPowerBtn.textContent = 'Zobrazit cel√© matice';
    const powerMatrixDiv = document.createElement('div');
    powerMatrixDiv.style.display = 'none';
    const powerStatsDiv = document.createElement('div');
    powerStatsDiv.style.display = 'none';
    powerStatsDiv.style.marginTop = '1rem';

    showPowerBtn.addEventListener('click', () => {
        if (powerMatrixDiv.style.display === 'none') {
            const A2 = graph.adjacencyPower(2);
            const A3 = graph.adjacencyPower(3);
            powerMatrixDiv.innerHTML = '<h3>A¬≤</h3>';
            const div2 = document.createElement('div');
            div2.className = 'matrix';
            div2.appendChild(createMatrixTable(A2, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div2);
            powerMatrixDiv.innerHTML += '<h3>A¬≥</h3>';
            const div3 = document.createElement('div');
            div3.className = 'matrix';
            div3.appendChild(createMatrixTable(A3, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div3);

            const stats2 = calculateMatrixStats(A2, graph.nodes, graph.nodes);
            const stats3 = calculateMatrixStats(A3, graph.nodes, graph.nodes);
            powerStatsDiv.innerHTML = `
                <div style="padding: 1rem; background-color: #e7f3ff; border-radius: 0.25rem;">
                    ${createMatrixStatsHTML(stats2, { showRowColSums: true })}
                </div>
                <div style="margin-top: 1rem; padding: 1rem; background-color: #e7f3ff; border-radius: 0.25rem;">
                    ${createMatrixStatsHTML(stats3, { showRowColSums: true })}
                </div>
            `;

            powerMatrixDiv.style.display = 'block';
            powerStatsDiv.style.display = 'block';
            showPowerBtn.textContent = 'Skr√Ωt matice';
        } else {
            powerMatrixDiv.style.display = 'none';
            powerStatsDiv.style.display = 'none';
            showPowerBtn.textContent = 'Zobrazit cel√© matice';
        }
    });
    powerSection.appendChild(showPowerBtn);
    powerSection.appendChild(powerMatrixDiv);
    powerSection.appendChild(powerStatsDiv);
    output.appendChild(powerSection);

    // Sum of walks query section
    const sumWalksSection = document.createElement('div');
    sumWalksSection.className = 'section';
    sumWalksSection.innerHTML = '<h2>Suma v≈°ech proch√°zek (‚àë A¬π + A¬≤ + ... + A·µè)</h2>';
    
    const sumWalksDiv = document.createElement('div');
    sumWalksDiv.className = 'query-section';
    sumWalksDiv.innerHTML = '<h3>Dotaz na celkov√Ω poƒçet proch√°zek d√©lek 1 a≈æ k</h3>';
    
    // Add legend
    const sumWalksLegendDiv = document.createElement('div');
    sumWalksLegendDiv.style.backgroundColor = '#e7f3ff';
    sumWalksLegendDiv.style.padding = '0.75rem';
    sumWalksLegendDiv.style.borderRadius = '0.25rem';
    sumWalksLegendDiv.style.marginBottom = '1rem';
    sumWalksLegendDiv.style.border = '1px solid #0d6efd';
    sumWalksLegendDiv.innerHTML = `
        <strong>üìä Vysvƒõtlen√≠:</strong><br>
        <span style="margin-left: 1rem;">‚Ä¢ Seƒçte poƒçet v≈°ech proch√°zek d√©lek 1, 2, 3, ..., a≈æ k mezi uzly U a V</span><br>
        <span style="margin-left: 1rem;">‚Ä¢ Nap≈ô. pro k=3: poƒç√≠t√° cesty d√©lky 1 + cesty d√©lky 2 + cesty d√©lky 3</span><br>
        <span style="margin-left: 1rem;">‚Ä¢ U≈æiteƒçn√© pro anal√Ωzu celkov√© propojitelnosti uzl≈Ø</span>
    `;
    sumWalksDiv.appendChild(sumWalksLegendDiv);
    
    const sumWalksInputDiv = document.createElement('div');
    sumWalksInputDiv.className = 'query-inputs';

    const sumDatalist = document.createElement('datalist');
    sumDatalist.id = 'nodes-datalist-sum';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        sumDatalist.appendChild(option);
    });
    sumWalksDiv.appendChild(sumDatalist);

    const selectSumU = document.createElement('input');
    selectSumU.setAttribute('list', 'nodes-datalist-sum');
    const selectSumV = document.createElement('input');
    selectSumV.setAttribute('list', 'nodes-datalist-sum');
    
    const sumKInput = document.createElement('input');
    sumKInput.type = 'number';
    sumKInput.min = '1';
    sumKInput.max = '10';
    sumKInput.value = '3';
    sumKInput.style.width = '80px';
    sumKInput.style.padding = '0.5rem';
    sumKInput.style.border = '1px solid #ced4da';
    sumKInput.style.borderRadius = '0.25rem';
    
    const sumWalksBtn = document.createElement('button');
    sumWalksBtn.textContent = 'Vypoƒç√≠tat';
    
    const sumWalksResultDiv = document.createElement('div');
    sumWalksResultDiv.className = 'query-result';
    sumWalksResultDiv.style.display = 'none';
    
    sumWalksBtn.addEventListener('click', () => {
        const u = selectSumU.value;
        const v = selectSumV.value;
        const k = parseInt(sumKInput.value);
        
        if (k < 1 || k > 10) {
            sumWalksResultDiv.textContent = 'Hodnota k mus√≠ b√Ωt mezi 1 a 10';
            sumWalksResultDiv.style.display = 'block';
            return;
        }
        
        sumWalksBtn.disabled = true;
        sumWalksBtn.textContent = 'Poƒç√≠t√°m...';
        
        setTimeout(() => {
            const result = graph.sumWalksValue(u, v, k);
            sumWalksResultDiv.innerHTML = `‚àë proch√°zek (d√©lky 1..${k}) z <strong>${u}</strong> do <strong>${v}</strong>: <strong>${result}</strong><br>
                <small>Celkov√Ω poƒçet v≈°ech cest d√©lek 1 a≈æ ${k}</small>`;
            sumWalksResultDiv.style.display = 'block';
            sumWalksBtn.disabled = false;
            sumWalksBtn.textContent = 'Vypoƒç√≠tat';
        }, 50);
    });
    
    const labelSumU = document.createElement('span');
    labelSumU.textContent = 'Od uzlu: ';
    sumWalksInputDiv.appendChild(labelSumU);
    sumWalksInputDiv.appendChild(selectSumU);
    
    const labelSumV = document.createElement('span');
    labelSumV.textContent = ' Do uzlu: ';
    sumWalksInputDiv.appendChild(labelSumV);
    sumWalksInputDiv.appendChild(selectSumV);
    
    const labelSumK = document.createElement('span');
    labelSumK.textContent = ' Max. d√©lka k: ';
    sumWalksInputDiv.appendChild(labelSumK);
    sumWalksInputDiv.appendChild(sumKInput);
    sumWalksInputDiv.appendChild(sumWalksBtn);
    
    sumWalksDiv.appendChild(sumWalksInputDiv);
    sumWalksDiv.appendChild(sumWalksResultDiv);
    sumWalksSection.appendChild(sumWalksDiv);
    output.appendChild(sumWalksSection);

    // Incidence matrix with signed/unsigned toggle
    const incSection = document.createElement('div');
    incSection.className = 'section';
    incSection.innerHTML = '<h2>Matice incidence</h2>';
    
    const incLegendDiv = document.createElement('div');
    incLegendDiv.style.backgroundColor = '#e7f3ff';
    incLegendDiv.style.padding = '0.75rem';
    incLegendDiv.style.borderRadius = '0.25rem';
    incLegendDiv.style.marginBottom = '1rem';
    incLegendDiv.style.border = '1px solid #0d6efd';
    incLegendDiv.innerHTML = `
        <strong>ÔøΩ Matice incidence:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>-1 v ≈ô√°dku:</strong> Uzel je ocas orientovan√© hrany (v√Ωchoz√≠)<br>
            ‚Ä¢ <strong>+1 v ≈ô√°dku:</strong> Uzel je hlava orientovan√© hrany (c√≠lov√Ω)<br>
            ‚Ä¢ <strong>1 v ≈ô√°dku (oboj√≠):</strong> Uzel je incidentn√≠ s neorientovanou hranou<br>
            ‚Ä¢ <strong>0 v ≈ô√°dku:</strong> Uzel nen√≠ incidentn√≠ s touto hranou
        </div>
    `;
    incSection.appendChild(incLegendDiv);
    
    const incToggleDiv = document.createElement('div');
    incToggleDiv.style.marginBottom = '1rem';
    incToggleDiv.innerHTML = '<label><input type="checkbox" id="incSigned" checked /> Podepsan√° (signed)</label>';
    incSection.appendChild(incToggleDiv);
    
    const showIncBtn = document.createElement('button');
    showIncBtn.textContent = 'Zobrazit matici';
    const incMatrixDiv = document.createElement('div');
    incMatrixDiv.className = 'matrix';
    incMatrixDiv.style.display = 'none';
    
    showIncBtn.addEventListener('click', () => {
        if (incMatrixDiv.style.display === 'none') {
            const signed = document.getElementById('incSigned').checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
            incMatrixDiv.style.display = 'block';
            showIncBtn.textContent = 'Skr√Ωt matici';
        } else {
            incMatrixDiv.style.display = 'none';
            showIncBtn.textContent = 'Zobrazit matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'incSigned' && incMatrixDiv.style.display === 'block') {
            const signed = e.target.checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
        }
    });
    
    incSection.appendChild(showIncBtn);
    incSection.appendChild(incMatrixDiv);
    output.appendChild(incSection);

    // Reachability matrix (transitive closure)
    const reachSection = document.createElement('div');
    reachSection.className = 'section';
    reachSection.innerHTML = '<h2>Dosa≈æitelnost (transitivn√≠ uz√°vƒõr)</h2>';
    
    const reachLegendDiv = document.createElement('div');
    reachLegendDiv.style.backgroundColor = '#e7f3ff';
    reachLegendDiv.style.padding = '0.75rem';
    reachLegendDiv.style.borderRadius = '0.25rem';
    reachLegendDiv.style.marginBottom = '1rem';
    reachLegendDiv.style.border = '1px solid #0d6efd';
    reachLegendDiv.innerHTML = `
        <strong>üîÑ Dosa≈æitelnost R[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>R[i,j] = 1:</strong> Uzel j je dosa≈æiteln√Ω z i (existuje cesta)<br>
            ‚Ä¢ <strong>R[i,j] = 0:</strong> Uzel j NEN√ç dosa≈æiteln√Ω z i<br>
            ‚Ä¢ <strong>R[i,i] = 1:</strong> V≈ædy (uzel dos√°hne s√°m sebe)<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong> Zji≈°tƒõn√≠ komponent a souvislosti
        </div>
    `;
    reachSection.appendChild(reachLegendDiv);
    
    // Query interface
    const reachQueryDiv = document.createElement('div');
    reachQueryDiv.className = 'query-section';
    reachQueryDiv.innerHTML = '<h3>Dotaz na dosa≈æitelnost</h3>';
    
    const reachInputDiv = document.createElement('div');
    reachInputDiv.className = 'query-inputs';
    
    const inputReachU = document.createElement('input');
    inputReachU.type = 'text';
    inputReachU.placeholder = 'Zadejte uzel (nap≈ô. A)';
    inputReachU.style.width = '120px';
    inputReachU.style.padding = '0.5rem';
    inputReachU.style.border = '1px solid #ced4da';
    inputReachU.style.borderRadius = '0.25rem';
    
    const inputReachV = document.createElement('input');
    inputReachV.type = 'text';
    inputReachV.placeholder = 'Zadejte uzel (nap≈ô. B)';
    inputReachV.style.width = '120px';
    inputReachV.style.padding = '0.5rem';
    inputReachV.style.border = '1px solid #ced4da';
    inputReachV.style.borderRadius = '0.25rem';
    
    const reachQueryBtn = document.createElement('button');
    reachQueryBtn.textContent = 'Je dosa≈æiteln√Ω?';
    
    const reachQueryResult = document.createElement('div');
    reachQueryResult.className = 'query-result';
    reachQueryResult.style.display = 'none';
    
    reachQueryBtn.addEventListener('click', () => {
        const u = inputReachU.value.trim();
        const v = inputReachV.value.trim();
        
        if (!u || !v) {
            reachQueryResult.innerHTML = `<strong>‚ö†Ô∏è Chyba:</strong> Zadejte oba uzly`;
            reachQueryResult.style.display = 'block';
            return;
        }
        
        const uIdx = graph.nodes.indexOf(u);
        const vIdx = graph.nodes.indexOf(v);
        
        if (uIdx === -1 || vIdx === -1) {
            const invalidNodes = [];
            if (uIdx === -1) invalidNodes.push(`"${u}"`);
            if (vIdx === -1) invalidNodes.push(`"${v}"`);
            reachQueryResult.innerHTML = `<strong>‚ö†Ô∏è Chyba:</strong> Uzel ${invalidNodes.join(' a ')} neexistuje v grafu. Dostupn√© uzly: ${graph.nodes.join(', ')}`;
            reachQueryResult.style.display = 'block';
            return;
        }
        
        const reachMat = graph.reachability();
        const isReachable = reachMat[uIdx][vIdx] === 1;
        
        reachQueryResult.innerHTML = `<strong>${u} ‚Üí ${v}:</strong> ${isReachable ? '‚úÖ ANO (dosa≈æiteln√Ω)' : '‚ùå NE (nedosa≈æiteln√Ω)'}`;
        reachQueryResult.style.display = 'block';
    });
    
    const labelReachU = document.createElement('span');
    labelReachU.textContent = 'Z uzlu: ';
    reachInputDiv.appendChild(labelReachU);
    reachInputDiv.appendChild(inputReachU);
    
    const labelReachV = document.createElement('span');
    labelReachV.textContent = ' Do uzlu: ';
    reachInputDiv.appendChild(labelReachV);
    reachInputDiv.appendChild(inputReachV);
    reachInputDiv.appendChild(reachQueryBtn);
    
    reachQueryDiv.appendChild(reachInputDiv);
    reachQueryDiv.appendChild(reachQueryResult);
    reachSection.appendChild(reachQueryDiv);
    
    // Statistics button
    const showReachStatsBtn = document.createElement('button');
    showReachStatsBtn.textContent = 'Zobrazit statistiky dosa≈æitelnosti';
    showReachStatsBtn.style.marginTop = '1rem';
    const reachStatsDiv = document.createElement('div');
    reachStatsDiv.style.display = 'none';
    reachStatsDiv.style.marginTop = '1rem';
    
    showReachStatsBtn.addEventListener('click', () => {
        if (reachStatsDiv.style.display === 'none') {
            const reachMat = graph.reachability();
            const n = graph.nodes.length;
            const components = graph.getComponents();
            
            // Calculate statistics
            const reachableFrom = {}; // kolik uzl≈Ø je dosa≈æiteln√Ωch z ka≈æd√©ho uzlu
            const reachableBy = {};   // z kolika uzl≈Ø je ka≈æd√Ω uzel dosa≈æiteln√Ω
            let totalReachable = 0;
            
            for (let i = 0; i < n; i++) {
                reachableFrom[graph.nodes[i]] = 0;
                reachableBy[graph.nodes[i]] = 0;
            }
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j && reachMat[i][j] === 1) {
                        reachableFrom[graph.nodes[i]]++;
                        reachableBy[graph.nodes[j]]++;
                        totalReachable++;
                    }
                }
            }
            
            const maxPossible = n * (n - 1);
            const reachabilityPercent = ((totalReachable / maxPossible) * 100).toFixed(1);
            
            // Isolated nodes (cannot reach anyone, no one can reach them)
            const isolated = graph.nodes.filter(node => 
                reachableFrom[node] === 0 && reachableBy[node] === 0
            );
            
            reachStatsDiv.innerHTML = `
                <div style="background-color: #f8f9fa; padding: 1rem; border-radius: 0.25rem; border: 1px solid #dee2e6;">
                    <h3 style="margin-top: 0; color: #0d6efd;">üìà Statistiky dosa≈æitelnosti a komponent</h3>
                    
                    <div style="background-color: white; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem;">
                        <strong>Celkov√° dosa≈æitelnost:</strong><br>
                        ‚Ä¢ <strong>${totalReachable}</strong> z ${maxPossible} mo≈æn√Ωch spojen√≠ (${reachabilityPercent}%)<br>
                        ‚Ä¢ Pr≈Ømƒõrnƒõ ka≈æd√Ω uzel dos√°hne <strong>${(totalReachable / n).toFixed(1)}</strong> uzl≈Ø<br>
                        ‚Ä¢ Graf m√° <strong>${components.length}</strong> ${components.length === 1 ? 'komponentu' : components.length < 5 ? 'komponenty' : 'komponent'}
                    </div>
                    
                    ${isolated.length > 0 ? `
                    <div style="background-color: #fff3cd; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem; border: 1px solid #ffc107;">
                        <strong>‚ö†Ô∏è Izolovan√© uzly (${isolated.length}):</strong><br>
                        <span style="font-size: 0.9rem;">Tyto uzly nemaj√≠ ≈æ√°dn√© spojen√≠ s ostatn√≠mi:</span><br>
                        <code style="background-color: #fff; padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: inline-block; margin-top: 0.25rem;">
                            ${isolated.slice(0, 30).join(', ')}${isolated.length > 30 ? ` ... a dal≈°√≠ch ${isolated.length - 30}` : ''}
                        </code>
                    </div>
                    ` : ''}
                    
                    <div style="background-color: white; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem;">
                        <strong>üîó Komponenty grafu (${components.length}):</strong><br>
                        <span style="font-size: 0.9rem; color: #666;">Ka≈æd√° komponenta m√° reprezentanta (ko≈ôenov√Ω uzel) - pou≈æij ho pro BFS:</span><br>
                        <div style="margin-top: 0.5rem;">
                            ${components.map((comp, idx) => `
                                <div style="background-color: ${idx % 2 === 0 ? '#f8f9fa' : '#fff'}; padding: 0.5rem; margin-top: 0.25rem; border-radius: 0.25rem; border-left: 3px solid ${idx === 0 ? '#0d6efd' : idx === 1 ? '#198754' : '#dc3545'};">
                                    <strong>Komponenta ${idx + 1}</strong> (${comp.size} ${comp.size === 1 ? 'uzel' : comp.size < 5 ? 'uzly' : 'uzl≈Ø'}):
                                    <br>
                                    <span style="font-size: 0.9rem;">
                                        üéØ <strong>Reprezentant (root):</strong> <code style="background-color: #e7f3ff; padding: 0.1rem 0.4rem; border-radius: 0.2rem; font-weight: bold;">${comp.root}</code>
                                        ${comp.size <= 20 ? `<br>üì¶ Uzly: ${comp.nodes.join(', ')}` : `<br>üì¶ Prvn√≠ uzly: ${comp.nodes.slice(0, 20).join(', ')} ... (celkem ${comp.size})`}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            reachStatsDiv.style.display = 'block';
            showReachStatsBtn.textContent = 'Skr√Ωt statistiky';
        } else {
            reachStatsDiv.style.display = 'none';
            showReachStatsBtn.textContent = 'Zobrazit statistiky dosa≈æitelnosti';
        }
    });
    
    reachSection.appendChild(showReachStatsBtn);
    reachSection.appendChild(reachStatsDiv);
    
    // Full matrix (only for small graphs)
    if (graph.nodes.length <= 50) {
        const showReachMatrixBtn = document.createElement('button');
        showReachMatrixBtn.textContent = 'Zobrazit celou matici';
        showReachMatrixBtn.style.marginTop = '0.5rem';
        const reachMatrixDiv = document.createElement('div');
        reachMatrixDiv.className = 'matrix';
        reachMatrixDiv.style.display = 'none';
        
        showReachMatrixBtn.addEventListener('click', () => {
            if (reachMatrixDiv.style.display === 'none') {
                const reachMat = graph.reachability();
                reachMatrixDiv.innerHTML = '';
                reachMatrixDiv.appendChild(createMatrixTable(reachMat, graph.nodes, graph.nodes));
                reachMatrixDiv.style.display = 'block';
                showReachMatrixBtn.textContent = 'Skr√Ωt matici';
            } else {
                reachMatrixDiv.style.display = 'none';
                showReachMatrixBtn.textContent = 'Zobrazit celou matici';
            }
        });
        
        reachSection.appendChild(showReachMatrixBtn);
        reachSection.appendChild(reachMatrixDiv);
    } else {
        const warningDiv = document.createElement('div');
        warningDiv.style.marginTop = '1rem';
        warningDiv.style.padding = '0.75rem';
        warningDiv.style.backgroundColor = '#fff3cd';
        warningDiv.style.borderRadius = '0.25rem';
        warningDiv.style.border = '1px solid #ffc107';
        warningDiv.innerHTML = `
            <strong>‚ÑπÔ∏è Pozn√°mka:</strong> Graf m√° ${graph.nodes.length} uzl≈Ø - matice ${graph.nodes.length}√ó${graph.nodes.length} by byla nep≈ôehledn√°. 
            Pou≈æijte dotaz nebo statistiky v√Ω≈°e.
        `;
        reachSection.appendChild(warningDiv);
    }
    
    output.appendChild(reachSection);

    // BFS Layers
    const bfsSection = document.createElement('div');
    bfsSection.className = 'section';
    bfsSection.innerHTML = '<h2>BFS Vrstvy (Breadth-First Search Layers)</h2>';
    
    const bfsLegendDiv = document.createElement('div');
    bfsLegendDiv.style.backgroundColor = '#e7f3ff';
    bfsLegendDiv.style.padding = '0.75rem';
    bfsLegendDiv.style.borderRadius = '0.25rem';
    bfsLegendDiv.style.marginBottom = '1rem';
    bfsLegendDiv.style.border = '1px solid #0d6efd';
    bfsLegendDiv.innerHTML = `
        <strong>üåä BFS vrstvy:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Vrstva 0:</strong> Startovn√≠ uzel<br>
            ‚Ä¢ <strong>Vrstva k:</strong> Uzly dostupn√© v k kroc√≠ch ze startu<br>
            ‚Ä¢ <strong>Ka≈æd√Ω uzel:</strong> Objev√≠ se pr√°vƒõ v jedn√© vrstvƒõ<br>
            ‚Ä¢ <strong>U≈æit√≠:</strong> Vzd√°lenost od start, komponenty, ≈°√≠≈ôen√≠ informace
        </div>
    `;
    bfsSection.appendChild(bfsLegendDiv);
    
    const bfsControlDiv = document.createElement('div');
    bfsControlDiv.style.marginBottom = '1rem';
    bfsControlDiv.innerHTML = '<label>Startovn√≠ uzel: <input id="bfsStart" list="nodes-datalist-bfs"></label> <button id="bfsBtn" class="btn" style="margin-left: 0.5rem;">Spoƒç√≠tat vrstvy</button>';
    bfsSection.appendChild(bfsControlDiv);

    const bfsDatalist = document.createElement('datalist');
    bfsDatalist.id = 'nodes-datalist-bfs';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        bfsDatalist.appendChild(option);
    });
    bfsSection.appendChild(bfsDatalist);

    const bfsResultDiv = document.createElement('div');
    bfsResultDiv.className = 'scroll';
    bfsResultDiv.style.display = 'none';
    bfsSection.appendChild(bfsResultDiv);
    
    bfsControlDiv.querySelector('#bfsBtn').addEventListener('click', () => {
        const bfsStartSelect = document.getElementById('bfsStart');
        const start = bfsStartSelect.value;
        const layers = graph.bfsLayers(start);
        let html = '<h4>Vrstvy uzl≈Ø:</h4>';
        for (const [k, nodes] of Object.entries(layers)) {
            html += `<div style="margin: 0.5rem 0;"><strong>Vrstva ${k}:</strong> ${nodes.join(', ')}</div>`;
        }
        bfsResultDiv.innerHTML = html;
        bfsResultDiv.style.display = 'block';
    });
    
    output.appendChild(bfsSection);

    // All shortest paths (unweighted)
    const allPathsSection = document.createElement('div');
    allPathsSection.className = 'section';
    allPathsSection.innerHTML = '<h2>V≈°echny nejkrat≈°√≠ cesty (neohodnocen√©)</h2>';
    
    const allPathsLegendDiv = document.createElement('div');
    allPathsLegendDiv.style.backgroundColor = '#e7f3ff';
    allPathsLegendDiv.style.padding = '0.75rem';
    allPathsLegendDiv.style.borderRadius = '0.25rem';
    allPathsLegendDiv.style.marginBottom = '1rem';
    allPathsLegendDiv.style.border = '1px solid #0d6efd';
    allPathsLegendDiv.innerHTML = `
        <strong>üõ§Ô∏è V≈°echny nejkrat≈°√≠ cesty:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Najde V≈†ECHNY:</strong> Cesty stejn√© d√©lky mezi U a V<br>
            ‚Ä¢ <strong>Algoritmus:</strong> BFS (d√©lka = poƒçet hran)<br>
            ‚Ä¢ <strong>Limit 200:</strong> Zobraz√≠ max 200 cest (m≈Ø≈æe jich b√Ωt hodnƒõ!)<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong> Anal√Ωza redundance, alternativn√≠ trasy
        </div>
    `;
    allPathsSection.appendChild(allPathsLegendDiv);
    
    const allPathsControlDiv = document.createElement('div');
    allPathsControlDiv.className = 'query-inputs';

    const allPathsDatalist = document.createElement('datalist');
    allPathsDatalist.id = 'nodes-datalist-allpaths';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        allPathsDatalist.appendChild(option);
    });
    allPathsSection.appendChild(allPathsDatalist);

    const selectAllU = document.createElement('input');
    selectAllU.setAttribute('list', 'nodes-datalist-allpaths');
    const selectAllV = document.createElement('input');
    selectAllV.setAttribute('list', 'nodes-datalist-allpaths');
    
    const allPathsBtn = document.createElement('button');
    allPathsBtn.textContent = 'Naj√≠t v≈°echny cesty';
    
    allPathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    allPathsControlDiv.appendChild(selectAllU);
    const labelAllV = document.createElement('span');
    labelAllV.textContent = ' Do uzlu: ';
    allPathsControlDiv.appendChild(labelAllV);
    allPathsControlDiv.appendChild(selectAllV);
    allPathsControlDiv.appendChild(allPathsBtn);
    
    allPathsSection.appendChild(allPathsControlDiv);
    
    const allPathsResultDiv = document.createElement('div');
    allPathsResultDiv.className = 'scroll';
    allPathsResultDiv.style.display = 'none';
    allPathsSection.appendChild(allPathsResultDiv);
    
    allPathsBtn.addEventListener('click', () => {
        const u = selectAllU.value;
        const v = selectAllV.value;
        const paths = graph.allShortestPathsUnweighted(u, v);
        
        if (paths.length === 0) {
            allPathsResultDiv.textContent = 'Nenalezena ≈æ√°dn√° cesta.';
        } else {
            let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">Poƒçet nejkrat≈°√≠ch cest: ${paths.length}</div>`;
            html += paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' ‚Üí ')}`).join('<br/>');
            if (paths.length > 200) html += '<br/>‚Ä¶ dal≈°√≠ nezobrazeny (limit 200)';
            allPathsResultDiv.innerHTML = html;
        }
        allPathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(allPathsSection);

    // Simple paths up to K
    const simplePathsSection = document.createElement('div');
    simplePathsSection.className = 'section';
    simplePathsSection.innerHTML = '<h2>Jednoduch√© cesty U‚ÜíV do d√©lky K</h2>';
    
    const simplePathsLegendDiv = document.createElement('div');
    simplePathsLegendDiv.style.backgroundColor = '#e7f3ff';
    simplePathsLegendDiv.style.padding = '0.75rem';
    simplePathsLegendDiv.style.borderRadius = '0.25rem';
    simplePathsLegendDiv.style.marginBottom = '1rem';
    simplePathsLegendDiv.style.border = '1px solid #0d6efd';
    simplePathsLegendDiv.innerHTML = `
        <strong>üéØ Jednoduch√© cesty (do d√©lky K):</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Jednoduch√° cesta:</strong> Neproch√°z√≠ ≈æ√°dn√Ω uzel v√≠cekr√°t<br>
            ‚Ä¢ <strong>Max d√©lka K:</strong> Obsahuje max K hran<br>
            ‚Ä¢ <strong>Bez limitu K:</strong> Hled√° a≈æ do d√©lky |V|-1<br>
            ‚Ä¢ <strong>Limit 10,000:</strong> Maxim√°lnƒõ 10,000 v√Ωsledk≈Ø kv≈Øli v√Ωkonu
        </div>
    `;
    simplePathsSection.appendChild(simplePathsLegendDiv);
    
    const simplePathsControlDiv = document.createElement('div');
    simplePathsControlDiv.className = 'query-inputs';

    const simplePathsDatalist = document.createElement('datalist');
    simplePathsDatalist.id = 'nodes-datalist-simplepaths';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        simplePathsDatalist.appendChild(option);
    });
    simplePathsSection.appendChild(simplePathsDatalist);

    const selectSimpleU = document.createElement('input');
    selectSimpleU.setAttribute('list', 'nodes-datalist-simplepaths');
    const selectSimpleV = document.createElement('input');
    selectSimpleV.setAttribute('list', 'nodes-datalist-simplepaths');
    
    const simpleKInput = document.createElement('input');
    simpleKInput.type = 'number';
    simpleKInput.min = '1';
    simpleKInput.placeholder = 'K (pr√°zdn√© = |V|-1)';
    simpleKInput.style.width = '150px';
    simpleKInput.style.padding = '0.5rem';
    simpleKInput.style.border = '1px solid #ced4da';
    simpleKInput.style.borderRadius = '0.25rem';
    
    const simplePathsBtn = document.createElement('button');
    simplePathsBtn.textContent = 'Naj√≠t cesty';
    
    simplePathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    simplePathsControlDiv.appendChild(selectSimpleU);
    const labelSimpleV = document.createElement('span');
    labelSimpleV.textContent = ' Do uzlu: ';
    simplePathsControlDiv.appendChild(labelSimpleV);
    simplePathsControlDiv.appendChild(selectSimpleV);
    const labelSimpleK = document.createElement('span');
    labelSimpleK.textContent = ' Max d√©lka K: ';
    simplePathsControlDiv.appendChild(labelSimpleK);
    simplePathsControlDiv.appendChild(simpleKInput);
    simplePathsControlDiv.appendChild(simplePathsBtn);
    
    simplePathsSection.appendChild(simplePathsControlDiv);
    
    const simplePathsResultDiv = document.createElement('div');
    simplePathsResultDiv.className = 'scroll';
    simplePathsResultDiv.style.display = 'none';
    simplePathsSection.appendChild(simplePathsResultDiv);
    
    simplePathsBtn.addEventListener('click', () => {
        const u = selectSimpleU.value;
        const v = selectSimpleV.value;
        const K = simpleKInput.value ? parseInt(simpleKInput.value, 10) : null;
        const result = graph.simplePathsUpTo(u, v, K, 10000);
        
        const more = (result.count > result.paths.length) ? ' (zastaveno na limitu 10,000)' : '';
        let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">Poƒçet: ${result.count}${more}</div>`;
        html += result.paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' ‚Üí ')}`).join('<br/>');
        if (result.count > 200) html += '<br/>‚Ä¶ dal≈°√≠ nezobrazeny (limit 200)';
        
        simplePathsResultDiv.innerHTML = html;
        simplePathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(simplePathsSection);

    // Neighbor sets by direction
    const neighborSection = document.createElement('div');
    neighborSection.className = 'section';
    neighborSection.innerHTML = '<h2>Soused√© podle smƒõru</h2>';
    
    const neighborLegendDiv = document.createElement('div');
    neighborLegendDiv.style.backgroundColor = '#e7f3ff';
    neighborLegendDiv.style.padding = '0.75rem';
    neighborLegendDiv.style.borderRadius = '0.25rem';
    neighborLegendDiv.style.marginBottom = '1rem';
    neighborLegendDiv.style.border = '1px solid #0d6efd';
    neighborLegendDiv.innerHTML = `
        <strong>üë• Soused√© podle typu hrany:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>OUT (‚Üí):</strong> Uzly, do kter√Ωch vede hrana ven<br>
            ‚Ä¢ <strong>IN (‚Üê):</strong> Uzly, ze kter√Ωch vede hrana dovnit≈ô<br>
            ‚Ä¢ <strong>UND (‚Äî):</strong> Uzly spojen√© neorientovanou hranou<br>
            ‚Ä¢ <strong>Stupe≈à uzlu:</strong> |OUT| + |IN| + |UND| (s korekc√≠)
        </div>
    `;
    neighborSection.appendChild(neighborLegendDiv);
    
    const neighborControlDiv = document.createElement('div');
    neighborControlDiv.style.marginBottom = '1rem';
    neighborControlDiv.innerHTML = '<label>Uzel: <input id="neighborSelect" list="nodes-datalist-neighbor"></label> <button id="neighborBtn" style="margin-left: 0.5rem;">Zobrazit sousedy</button>';
    neighborSection.appendChild(neighborControlDiv);

    const neighborDatalist = document.createElement('datalist');
    neighborDatalist.id = 'nodes-datalist-neighbor';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        neighborDatalist.appendChild(option);
    });
    neighborSection.appendChild(neighborDatalist);
    
    const neighborResultDiv = document.createElement('div');
    neighborResultDiv.className = 'scroll';
    neighborResultDiv.style.display = 'none';
    neighborSection.appendChild(neighborResultDiv);
    
    neighborControlDiv.querySelector('#neighborBtn').addEventListener('click', () => {
        const neighborSelect = document.getElementById('neighborSelect');
        const node = neighborSelect.value;
        const neighbors = graph.neighborSets(node);
        let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
        html += `<div style="padding: 0.5rem; background-color: #d1ecf1; border-radius: 0.25rem;"><strong>OUT (odchoz√≠):</strong> ${neighbors.out.join(', ') || '‚àÖ'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #d4edda; border-radius: 0.25rem;"><strong>IN (p≈ô√≠choz√≠):</strong> ${neighbors.inn.join(', ') || '‚àÖ'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #fff3cd; border-radius: 0.25rem;"><strong>Neorientovan√≠:</strong> ${neighbors.und.join(', ') || '‚àÖ'}</div>`;
        html += '</div>';
        neighborResultDiv.innerHTML = html;
        neighborResultDiv.style.display = 'block';
    });
    
    output.appendChild(neighborSection);

    // Length matrix with query
    const lenSection = document.createElement('div');
    lenSection.className = 'section';
    lenSection.innerHTML = '<h2>Matice d√©lek</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const lenLegendDiv = document.createElement('div');
    lenLegendDiv.style.backgroundColor = '#e7f3ff';
    lenLegendDiv.style.padding = '0.75rem';
    lenLegendDiv.style.borderRadius = '0.25rem';
    lenLegendDiv.style.marginBottom = '1rem';
    lenLegendDiv.style.border = '1px solid #0d6efd';
    lenLegendDiv.innerHTML = `
        <strong>üìä Matice d√©lek L[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>L[i,j] = ƒç√≠slo:</strong> V√°ha/d√©lka p≈ô√≠m√© hrany<br>
            ‚Ä¢ <strong>L[i,j] = ‚àû:</strong> Bez p≈ô√≠m√©ho spojen√≠<br>
            ‚Ä¢ <strong>L[i,i] = 0:</strong> Vzd√°lenost k sobƒõ sam√©mu<br>
            ‚Ä¢ <strong>Pozn√°mka:</strong> Jen p≈ô√≠m√© hrany, ne nejkrat≈°√≠ cesty
        </div>
    `;
    lenSection.appendChild(lenLegendDiv);
    
    lenSection.appendChild(createQuerySection('Dotaz na hodnotu', 'length'));
    
    const showLenBtn = document.createElement('button');
    showLenBtn.textContent = 'Zobrazit celou matici';
    const lenMatrixDiv = document.createElement('div');
    lenMatrixDiv.className = 'matrix';
    lenMatrixDiv.style.display = 'none';
    const lenStatsDiv = document.createElement('div');
    lenStatsDiv.style.display = 'none';
    lenStatsDiv.style.marginTop = '1rem';
    lenStatsDiv.style.padding = '1rem';
    lenStatsDiv.style.backgroundColor = '#e7f3ff';
    lenStatsDiv.style.borderRadius = '0.25rem';

    showLenBtn.addEventListener('click', () => {
        if (lenMatrixDiv.style.display === 'none') {
            const lenMat = graph.lengthMatrix();
            lenMatrixDiv.innerHTML = '';
            lenMatrixDiv.appendChild(createMatrixTable(lenMat, graph.nodes, graph.nodes));

            const stats = calculateMatrixStats(lenMat, graph.nodes, graph.nodes);
            lenStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });

            lenMatrixDiv.style.display = 'block';
            lenStatsDiv.style.display = 'block';
            showLenBtn.textContent = 'Skr√Ωt matici';
        } else {
            lenMatrixDiv.style.display = 'none';
            lenStatsDiv.style.display = 'none';
            showLenBtn.textContent = 'Zobrazit celou matici';
        }
    });
    lenSection.appendChild(showLenBtn);
    lenSection.appendChild(lenMatrixDiv);
    lenSection.appendChild(lenStatsDiv);
    output.appendChild(lenSection);

    // Shortest path query
    const shortestSection = document.createElement('div');
    shortestSection.className = 'section';
    shortestSection.innerHTML = '<h2>Nejkrat≈°√≠ cesty (Floyd-Warshall)</h2>';
    
    // P≈ôidej vysvƒõtlivku pro Floyd-Warshall
    const fwLegendDiv = document.createElement('div');
    fwLegendDiv.style.backgroundColor = '#e7f3ff';
    fwLegendDiv.style.padding = '0.75rem';
    fwLegendDiv.style.borderRadius = '0.25rem';
    fwLegendDiv.style.marginBottom = '1rem';
    fwLegendDiv.style.border = '1px solid #0d6efd';
    fwLegendDiv.innerHTML = `
        <strong>üõ£Ô∏è Floyd-Warshall≈Øv algoritmus:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            ‚Ä¢ <strong>Co poƒç√≠t√°:</strong> Nejkrat≈°√≠ cesty mezi V≈†EMI p√°ry uzl≈Ø najednou<br>
            ‚Ä¢ <strong>V√Ωhoda:</strong> Zvl√°d√° i <strong>z√°porn√© v√°hy</strong> (ale ne z√°porn√© cykly)<br>
            ‚Ä¢ <strong>Slo≈æitost:</strong> O(V¬≥) ‚Äì vhodn√© pro men≈°√≠ grafy (do ~500 uzl≈Ø)<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Routov√°n√≠ v s√≠t√≠ch</strong> ‚Äì p≈ôedpoƒç√≠t√°n√≠ smƒõrovac√≠ch tabulek</li>
                <li><strong>Tranzitivn√≠ uz√°vƒõr</strong> ‚Äì kdo dos√°hne na koho</li>
                <li><strong>Detekce z√°porn√Ωch cykl≈Ø</strong> ‚Äì arbitr√°≈æ mƒõn</li>
                <li><strong>Centrum grafu</strong> ‚Äì uzel s nejmen≈°√≠ maxim√°ln√≠ vzd√°lenost√≠</li>
            </ul>
            ‚Ä¢ <strong>Matice p≈ôedch≈Ødc≈Ø:</strong> Umo≈æ≈àuje rekonstruovat celou cestu, nejen vzd√°lenost
        </div>
    `;
    shortestSection.appendChild(fwLegendDiv);
    
    shortestSection.appendChild(createQuerySection('Dotaz na nejkrat≈°√≠ cestu', 'shortest'));
    
    const showPredBtn = document.createElement('button');
    showPredBtn.textContent = 'Vypoƒç√≠tat celou matici p≈ôedch≈Ødc≈Ø';
    const predMatrixDiv = document.createElement('div');
    predMatrixDiv.className = 'matrix';
    predMatrixDiv.style.display = 'none';
    showPredBtn.addEventListener('click', () => {
        if (predMatrixDiv.style.display === 'none') {
            showPredBtn.disabled = true;
            showPredBtn.textContent = 'Poƒç√≠t√°m...';
            setTimeout(() => {
                const fw = graph.floydWarshall();
                const pred = fw.pred.map(row => row.map(p => p === null ? '‚Äì' : graph.nodes[p]));
                predMatrixDiv.innerHTML = '';
                predMatrixDiv.appendChild(createMatrixTable(pred, graph.nodes, graph.nodes));
                predMatrixDiv.style.display = 'block';
                showPredBtn.textContent = 'Skr√Ωt matici';
                showPredBtn.disabled = false;
            }, 50);
        } else {
            predMatrixDiv.style.display = 'none';
            showPredBtn.textContent = 'Zobrazit celou matici';
        }
    });
    shortestSection.appendChild(showPredBtn);
    shortestSection.appendChild(predMatrixDiv);
    output.appendChild(shortestSection);

    // Incident edges
    const incident = graph.incidentEdges();
    const incEdgeSection = document.createElement('div');
    incEdgeSection.className = 'section';
    incEdgeSection.innerHTML = '<h2>Tabulka incidentn√≠ch hran</h2>';
    
    // P≈ôidej vysvƒõtlivku pro incidentn√≠ hrany
    const incEdgeLegendDiv = document.createElement('div');
    incEdgeLegendDiv.style.backgroundColor = '#e7f3ff';
    incEdgeLegendDiv.style.padding = '0.75rem';
    incEdgeLegendDiv.style.borderRadius = '0.25rem';
    incEdgeLegendDiv.style.marginBottom = '1rem';
    incEdgeLegendDiv.style.border = '1px solid #0d6efd';
    incEdgeLegendDiv.innerHTML = `
        <strong>üîó Co jsou incidentn√≠ hrany?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            ‚Ä¢ <strong>Definice:</strong> Hrany, kter√© ‚Äûdot√Ωkaj√≠" dan√Ω uzel (vych√°zej√≠ z nƒõj nebo do nƒõj vch√°zej√≠)<br>
            ‚Ä¢ <strong>Stupe≈à uzlu:</strong> Poƒçet incidentn√≠ch hran = stupe≈à uzlu (degree)<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Anal√Ωza s√≠t√≠</strong> ‚Äì identifikace hub≈Ø (uzly s mnoha spojen√≠mi)</li>
                <li><strong>Eulerovsk√© cesty</strong> ‚Äì graf m√° Eul. cestu ‚ü∫ max 2 uzly lich√©ho stupnƒõ</li>
                <li><strong>Grafov√° vizualizace</strong> ‚Äì rozlo≈æen√≠ podle stup≈à≈Ø</li>
                <li><strong>Optimalizace</strong> ‚Äì pro≈ôez√°v√°n√≠ hran u m√°lo propojen√Ωch uzl≈Ø</li>
            </ul>
        </div>
    `;
    incEdgeSection.appendChild(incEdgeLegendDiv);
    
    const incEdgeDiv = document.createElement('div');
    incEdgeDiv.className = 'matrix';
    incEdgeDiv.appendChild(createListTable(incident));
    incEdgeSection.appendChild(incEdgeDiv);
    output.appendChild(incEdgeSection);

    // Neighbours
    const neighbours = graph.neighbours();
    const neighSection = document.createElement('div');
    neighSection.className = 'section';
    neighSection.innerHTML = '<h2>Seznam soused≈Ø</h2>';
    
    // P≈ôidej vysvƒõtlivku pro seznam soused≈Ø
    const neighLegendDiv = document.createElement('div');
    neighLegendDiv.style.backgroundColor = '#e7f3ff';
    neighLegendDiv.style.padding = '0.75rem';
    neighLegendDiv.style.borderRadius = '0.25rem';
    neighLegendDiv.style.marginBottom = '1rem';
    neighLegendDiv.style.border = '1px solid #0d6efd';
    neighLegendDiv.innerHTML = `
        <strong>üë• Co je seznam soused≈Ø (Adjacency List)?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            ‚Ä¢ <strong>Definice:</strong> Pro ka≈æd√Ω uzel seznam v≈°ech uzl≈Ø, se kter√Ωmi je p≈ô√≠mo spojen hranou<br>
            ‚Ä¢ <strong>Pamƒõ≈•ov√° n√°roƒçnost:</strong> O(V + E) ‚Äì efektivnƒõj≈°√≠ ne≈æ matice sousednosti pro ≈ô√≠dk√© grafy<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>BFS/DFS</strong> ‚Äì rychl√Ω p≈ô√≠stup k soused≈Øm v O(1) amortizovanƒõ</li>
                <li><strong>Soci√°ln√≠ s√≠tƒõ</strong> ‚Äì seznam p≈ô√°tel, sleduj√≠c√≠ch</li>
                <li><strong>Doporuƒçovac√≠ syst√©my</strong> ‚Äì ‚Äûp≈ô√°tel√© p≈ô√°tel"</li>
                <li><strong>Webov√© crawlery</strong> ‚Äì odkazy z jedn√© str√°nky</li>
            </ul>
            ‚Ä¢ <strong>Tip:</strong> Pro orientovan√© grafy rozli≈°ujeme odchoz√≠ (OUT) a p≈ô√≠choz√≠ (IN) sousedy
        </div>
    `;
    neighSection.appendChild(neighLegendDiv);
    
    const neighDiv = document.createElement('div');
    neighDiv.className = 'matrix';
    neighDiv.appendChild(createListTable(neighbours));
    neighSection.appendChild(neighDiv);
    output.appendChild(neighSection);

    // Multiple edges detection and listing
    const multipleEdges = graph.findMultipleEdges();
    const multiEdgeSection = document.createElement('div');
    multiEdgeSection.className = 'section';
    multiEdgeSection.innerHTML = '<h2>V√≠ce√°sobn√© hrany</h2>';
    
    // P≈ôidej vysvƒõtlivku pro v√≠ce√°sobn√© hrany
    const multiEdgeLegendDiv = document.createElement('div');
    multiEdgeLegendDiv.style.backgroundColor = '#e7f3ff';
    multiEdgeLegendDiv.style.padding = '0.75rem';
    multiEdgeLegendDiv.style.borderRadius = '0.25rem';
    multiEdgeLegendDiv.style.marginBottom = '1rem';
    multiEdgeLegendDiv.style.border = '1px solid #0d6efd';
    multiEdgeLegendDiv.innerHTML = `
        <strong>üîÄ Co jsou v√≠ce√°sobn√© (paraleln√≠) hrany?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            ‚Ä¢ <strong>Definice:</strong> Dvƒõ nebo v√≠ce hran spojuj√≠c√≠ch stejnou dvojici uzl≈Ø<br>
            ‚Ä¢ <strong>Multigraf:</strong> Graf, kter√Ω obsahuje v√≠ce√°sobn√© hrany<br>
            ‚Ä¢ <strong>Kde se vyskytuj√≠:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Dopravn√≠ s√≠tƒõ</strong> ‚Äì v√≠ce linek mezi stanicemi (metro, autobus)</li>
                <li><strong>Telekomunikace</strong> ‚Äì redundantn√≠ kabely mezi serverovnami</li>
                <li><strong>Elektrick√© obvody</strong> ‚Äì paralelnƒõ zapojen√© rezistory</li>
                <li><strong>Finanƒçn√≠ transakce</strong> ‚Äì v√≠ce p≈ôevod≈Ø mezi √∫ƒçty</li>
            </ul>
            ‚Ä¢ <strong>Pozor:</strong> Mnoho algoritm≈Ø p≈ôedpokl√°d√° prost√Ω graf ‚Äì v√≠ce√°sobn√© hrany je t≈ôeba o≈°et≈ôit
        </div>
    `;
    multiEdgeSection.appendChild(multiEdgeLegendDiv);
    
    if (multipleEdges.length === 0) {
        const noMultiMsg = document.createElement('p');
        noMultiMsg.textContent = 'Graf neobsahuje ≈æ√°dn√© v√≠ce√°sobn√© hrany.';
        noMultiMsg.style.color = '#28a745';
        noMultiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(noMultiMsg);
    } else {
        const multiMsg = document.createElement('p');
        multiMsg.textContent = `Nalezeno ${multipleEdges.length} skupin v√≠ce√°sobn√Ωch hran:`;
        multiMsg.style.color = '#dc3545';
        multiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(multiMsg);
        
        const multiEdgeDiv = document.createElement('div');
        multiEdgeDiv.className = 'scrollable-list';
        const multiList = document.createElement('ul');
        multiList.style.listStyle = 'none';
        multiList.style.padding = '0';
        
        for (const group of multipleEdges) {
            const li = document.createElement('li');
            li.style.marginBottom = '1rem';
            li.style.padding = '0.5rem';
            li.style.backgroundColor = '#fff3cd';
            li.style.border = '1px solid #ffc107';
            li.style.borderRadius = '0.25rem';
            
            const title = document.createElement('strong');
            title.textContent = `${group.key} (${group.count}√ó n√°sobn√° hrana)`;
            li.appendChild(title);
            
            const edgeList = document.createElement('ul');
            edgeList.style.marginTop = '0.5rem';
            edgeList.style.marginLeft = '1rem';
            
            for (const e of group.edges) {
                const edgeLi = document.createElement('li');
                const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
                const label = e.label ? ` [${e.label}]` : '';
                let orientation;
                if (e.direction === '>') orientation = '‚Üí';
                else if (e.direction === '<') orientation = '‚Üê';
                else orientation = '‚Äî';
                edgeLi.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
                edgeList.appendChild(edgeLi);
            }
            
            li.appendChild(edgeList);
            multiList.appendChild(li);
        }
        
        multiEdgeDiv.appendChild(multiList);
        multiEdgeSection.appendChild(multiEdgeDiv);
    }
    
    output.appendChild(multiEdgeSection);

    // Properties (props u≈æ je definovan√© na zaƒç√°tku)
    const propSection = document.createElement('div');
    propSection.className = 'section';
    propSection.innerHTML = '<h2>Vlastnosti grafu</h2>';
    
    // P≈ôidej vysvƒõtlivky pro u≈æivatele
    const legendDiv = document.createElement('div');
    legendDiv.style.backgroundColor = '#fff3cd';
    legendDiv.style.padding = '1rem';
    legendDiv.style.borderRadius = '0.25rem';
    legendDiv.style.marginBottom = '1rem';
    legendDiv.style.border = '1px solid #ffc107';
    legendDiv.innerHTML = `
        <strong>üìñ Rychl√Ω slovn√≠k pojm≈Ø:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6; font-size: 0.95rem;">
            ‚Ä¢ <strong>Ohodnocen√Ω:</strong> M√° v√°hy na hran√°ch/uzlech | <strong>Orientovan√Ω:</strong> Hrany maj√≠ smƒõr (‚Üí)<br>
            ‚Ä¢ <strong>Souvisl√Ω:</strong> Z ka≈æd√©ho uzlu lze dojet do ka≈æd√©ho | <strong>Silnƒõ/Slabƒõ:</strong> Pouze v orientovan√Ωch<br>
            ‚Ä¢ <strong>Prost√Ω:</strong> Max 1 hrana mezi uzly | <strong>Jednoduch√Ω:</strong> Prost√Ω bez smyƒçek<br>
            ‚Ä¢ <strong>√öpln√Ω:</strong> V≈°echny uzly spojeny | <strong>Regul√°rn√≠:</strong> V≈°echny uzly stejn√Ω stupe≈à<br>
            ‚Ä¢ <strong>Bipartitn√≠:</strong> Uzly v 2 skupin√°ch, hrany jen mezi | <strong>Rovinn√Ω:</strong> Nakresliteln√Ω bez k≈ô√≠≈æen√≠
        </div>
    `;
    propSection.appendChild(legendDiv);
    
    const propDiv = document.createElement('div');
    propDiv.className = 'properties';
    const addProp = (name, value) => {
        const span = document.createElement('span');
        span.textContent = `${name}: ${value}`;
        propDiv.appendChild(span);
    };
    addProp('Ohodnocen√Ω', props.weighted ? 'ano' : 'ne');
    addProp('Orientace', props.oriented);
    addProp('Souvisl√Ω', props.connected ? 'ano' : 'ne');
    
    // ‚ö° OPRAVA: Zobraz strong/weak connectivity chyt≈ôe
    if (props.oriented === 'orientovan√Ω') {
        if (props.stronglyConnected) {
            addProp('Silnƒõ souvisl√Ω', 'ano');
            // Slabƒõ souvisl√Ω nemus√≠me zobrazovat - je implicitn√≠!
        } else if (props.weaklyConnected) {
            addProp('Silnƒõ souvisl√Ω', 'ne');
            addProp('Slabƒõ souvisl√Ω', 'ano');
        } else {
            addProp('Silnƒõ souvisl√Ω', 'ne');
            addProp('Slabƒõ souvisl√Ω', 'ne');
        }
    }
    
    addProp('Prost√Ω', props.prosty ? 'ano' : 'ne');
    addProp('Jednoduch√Ω', props.jednoduchy ? 'ano' : 'ne');
    addProp('Multigraf', props.multigraph ? 'ano' : 'ne');
    addProp('Diskr√©tn√≠', props.discrete ? 'ano (bez hran)' : 'ne');
    addProp('Koneƒçn√Ω', props.finite ? 'ano' : 'ne');
    addProp('Symetrizovan√Ω', props.symmetric ? 'ano' : 'ne');
    addProp('√öpln√Ω', props.complete ? 'ano' : 'ne');
    addProp('Regul√°rn√≠', props.regular ? 'ano' : 'ne');
    addProp('Bipartitn√≠', props.bipartite ? 'ano' : 'ne');
    addProp('Rovinn√Ω', typeof props.planar === 'string' ? props.planar : (props.planar ? 'ano' : 'ne'));
    propSection.appendChild(propDiv);
    output.appendChild(propSection);

    // Graph exploration section
    const exploreSection = document.createElement('div');
    exploreSection.id = 'exploreSection';
    exploreSection.className = 'section';
    exploreSection.innerHTML = '<h2>Prohled√°v√°n√≠ grafu (BFS/DFS)</h2>';
    
    // P≈ôidej vysvƒõtlivku pro BFS/DFS
    const exploreLegendDiv = document.createElement('div');
    exploreLegendDiv.style.backgroundColor = '#e7f3ff';
    exploreLegendDiv.style.padding = '0.75rem';
    exploreLegendDiv.style.borderRadius = '0.25rem';
    exploreLegendDiv.style.marginBottom = '1rem';
    exploreLegendDiv.style.border = '1px solid #0d6efd';
    exploreLegendDiv.innerHTML = `
        <strong>üîç K ƒçemu jsou BFS a DFS dobr√©?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>BFS (Breadth-First Search):</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li>Najde <strong>nejkrat≈°√≠ cestu</strong> v neohodnocen√©m grafu (poƒçet hran)</li>
                <li>Vhodn√© pro <strong>hled√°n√≠ nejbli≈æ≈°√≠ch soused≈Ø</strong> (soci√°ln√≠ s√≠tƒõ, doporuƒçovac√≠ syst√©my)</li>
                <li>Testov√°n√≠ <strong>souvislosti grafu</strong> a hled√°n√≠ komponent</li>
                <li>ƒåasov√° slo≈æitost: O(V + E)</li>
            </ul>
            <strong>DFS (Depth-First Search):</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Detekce cykl≈Ø</strong> v grafu</li>
                <li><strong>Topologick√© ≈ôazen√≠</strong> pro DAG (pl√°nov√°n√≠ √∫kol≈Ø, z√°vislosti)</li>
                <li>Hled√°n√≠ <strong>silnƒõ souvisl√Ωch komponent</strong> (Tarjan, Kosaraju)</li>
                <li>Generov√°n√≠ <strong>bludi≈°≈•</strong> a ≈ôe≈°en√≠ probl√©m≈Ø s backtrackingem</li>
                <li>ƒåasov√° slo≈æitost: O(V + E)</li>
            </ul>
        </div>
    `;
    exploreSection.appendChild(exploreLegendDiv);
    
    const exploreControls = document.createElement('div');
    exploreControls.className = 'query-inputs';
    exploreControls.innerHTML = `
        <select id="traversalAlgo" class="query-select">
            <option value="bfs">BFS (do ≈°√≠≈ôky)</option>
            <option value="dfs">DFS (do hloubky)</option>
        </select>
        <input id="startNode" list="nodes-datalist-explore" placeholder="Startovac√≠ uzel">
        <datalist id="nodes-datalist-explore"></datalist>
        <button id="runTraversal">Spustit</button>
    `;
    exploreSection.appendChild(exploreControls);
    const exploreResult = document.createElement('div');
    exploreResult.id = 'exploreResult';
    exploreResult.style.display = 'none';
    exploreSection.appendChild(exploreResult);
    output.appendChild(exploreSection);

    // Spanning Tree section
    const spanningTreeSection = document.createElement('div');
    spanningTreeSection.id = 'spanningTreeSection';
    spanningTreeSection.className = 'section';
    spanningTreeSection.innerHTML = '<h2>Kostra grafu</h2>';
    
    // P≈ôidej vysvƒõtlivku pro kostru grafu
    const spanningTreeLegendDiv = document.createElement('div');
    spanningTreeLegendDiv.style.backgroundColor = '#e7f3ff';
    spanningTreeLegendDiv.style.padding = '0.75rem';
    spanningTreeLegendDiv.style.borderRadius = '0.25rem';
    spanningTreeLegendDiv.style.marginBottom = '1rem';
    spanningTreeLegendDiv.style.border = '1px solid #0d6efd';
    spanningTreeLegendDiv.innerHTML = `
        <strong>üå≤ K ƒçemu jsou kostry grafu dobr√©?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>Kostra (Spanning Tree):</strong> Podgraf obsahuj√≠c√≠ v≈°echny uzly s minimem hran pro souvislost (bez cykl≈Ø).<br><br>
            <strong>Minim√°ln√≠ kostra (MST):</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>N√°vrh s√≠t√≠</strong> ‚Äì elektrick√© veden√≠, vodovody, optick√© kabely s min. n√°klady</li>
                <li><strong>Clustering</strong> ‚Äì shlukov√°n√≠ dat (single-linkage clustering)</li>
                <li><strong>Aproximace NP-tƒõ≈æk√Ωch probl√©m≈Ø</strong> ‚Äì TSP (obchodn√≠ cestuj√≠c√≠)</li>
                <li><strong>Poƒç√≠taƒçov√© s√≠tƒõ</strong> ‚Äì spanning tree protocol (prevence smyƒçek)</li>
            </ul>
            <strong>Maxim√°ln√≠ kostra:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>Maximalizace kapacity/≈°√≠≈ôky p√°sma</strong> v s√≠ti</li>
                <li><strong>Anal√Ωza nejsilnƒõj≈°√≠ch vazeb</strong> v soci√°ln√≠ch s√≠t√≠ch</li>
            </ul>
            <strong>Poƒçet koster:</strong> Ud√°v√° redundanci grafu ‚Äì ƒç√≠m v√≠ce koster, t√≠m v√≠ce zp≈Øsob≈Ø propojen√≠.<br>
            <strong>Algoritmy:</strong> Kruskal O(E log E), Prim O(E log V), Bor≈Øvka O(E log V)
        </div>
    `;
    spanningTreeSection.appendChild(spanningTreeLegendDiv);
    
    const spanningTreeControls = document.createElement('div');
    spanningTreeControls.className = 'query-inputs';
    spanningTreeControls.innerHTML = `
        <button id="runSpanningTree">Analyzovat kostru grafu</button>
    `;
    spanningTreeSection.appendChild(spanningTreeControls);
    const spanningTreeResult = document.createElement('div');
    spanningTreeResult.id = 'spanningTreeResult';
    spanningTreeResult.style.display = 'none';
    spanningTreeSection.appendChild(spanningTreeResult);
    output.appendChild(spanningTreeSection);

    // Optimal paths (shortest/longest/safest/widest)
    const optimalSection = document.createElement('div');
    optimalSection.id = 'optimalPathsSection';
    optimalSection.className = 'section';
    optimalSection.innerHTML = '<h2>Optim√°ln√≠ cesty (nejkrat≈°√≠ / nejdel≈°√≠ / nejbezpeƒçnƒõj≈°√≠ / nej≈°ir≈°√≠)</h2>';
    
    // P≈ôidej detailn√≠ vysvƒõtlivku pro optim√°ln√≠ cesty
    const optimalLegendDiv = document.createElement('div');
    optimalLegendDiv.style.backgroundColor = '#e7f3ff';
    optimalLegendDiv.style.padding = '0.75rem';
    optimalLegendDiv.style.borderRadius = '0.25rem';
    optimalLegendDiv.style.marginBottom = '1rem';
    optimalLegendDiv.style.border = '1px solid #0d6efd';
    optimalLegendDiv.innerHTML = `
        <strong>üõ§Ô∏è P≈ôehled algoritm≈Ø pro hled√°n√≠ cest:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                <tr style="background-color: rgba(0,0,0,0.05);">
                    <th style="text-align: left; padding: 0.3rem;">Algoritmus</th>
                    <th style="text-align: left; padding: 0.3rem;">Slo≈æitost</th>
                    <th style="text-align: left; padding: 0.3rem;">Kdy pou≈æ√≠t</th>
                </tr>
                <tr>
                    <td style="padding: 0.3rem;"><strong>Moore (BFS)</strong></td>
                    <td style="padding: 0.3rem;">O(V + E)</td>
                    <td style="padding: 0.3rem;">Neohodnocen√Ω graf, hled√°me min. poƒçet hran</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.3rem;"><strong>Dijkstra</strong></td>
                    <td style="padding: 0.3rem;">O((V+E) log V)</td>
                    <td style="padding: 0.3rem;">Nez√°porn√© v√°hy ‚Äì GPS navigace, routing</td>
                </tr>
                <tr>
                    <td style="padding: 0.3rem;"><strong>Bellman-Ford</strong></td>
                    <td style="padding: 0.3rem;">O(V √ó E)</td>
                    <td style="padding: 0.3rem;">Z√°porn√© v√°hy ‚Äì arbitr√°≈æ mƒõn, detekce z√°p. cykl≈Ø</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.3rem;"><strong>Nej≈°ir≈°√≠ cesta</strong></td>
                    <td style="padding: 0.3rem;">O((V+E) log V)</td>
                    <td style="padding: 0.3rem;">Maximalizace minim√°ln√≠ kapacity ‚Äì s√≠≈•ov√© toky, bandwidth. <span style="color:#dc3545;">Vy≈æaduje nez√°porn√© kapacity!</span></td>
                </tr>
                <tr>
                    <td style="padding: 0.3rem;"><strong>Nejbezpeƒçnƒõj≈°√≠</strong></td>
                    <td style="padding: 0.3rem;">O((V+E) log V)</td>
                    <td style="padding: 0.3rem;">Spolehlivost r = exp(‚àíw). Max. souƒçin spolehlivost√≠ = min. souƒçet vah.</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.3rem;"><strong>Nejdel≈°√≠ cesta</strong></td>
                    <td style="padding: 0.3rem;">O(V + E) pro DAG</td>
                    <td style="padding: 0.3rem;">Pl√°nov√°n√≠ projekt≈Ø (CPM), kritick√° cesta</td>
                </tr>
            </table>
            <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #6c757d;">
                üí° <strong>Tip:</strong> Pro jeden zdroj ‚Üí Dijkstra/BF. Pro v≈°echny p√°ry ‚Üí Floyd-Warshall (sekce v√Ω≈°e).
            </div>
        </div>
    `;
    optimalSection.appendChild(optimalLegendDiv);
    
    const optimalInfo = document.createElement('p');
    optimalInfo.style.color = '#495057';
    optimalInfo.innerHTML = 'Moore≈Øv algoritmus (BFS) hled√° nejkrat≈°√≠ cestu v neohodnocen√©m grafu. Dijkstr≈Øv a Bellman-Ford≈Øv algoritmus pracuj√≠ s vahami (Bellman-Ford zvl√°d√° i z√°porn√© hrany) a Floyd-Warshallova varianta n√≠≈æe poskytuje kompletn√≠ matici vzd√°lenost√≠.';
    optimalSection.appendChild(optimalInfo);
    const optimalInputs = document.createElement('div');
    optimalInputs.className = 'query-inputs';
    optimalInputs.innerHTML = `
        <input id="optimalStartNode" list="nodes-datalist-optimal" placeholder="Od uzlu">
        <input id="optimalEndNode" list="nodes-datalist-optimal" placeholder="Do uzlu">
        <button id="runOptimalPaths">Analyzovat optim√°ln√≠ cesty</button>
    `;
    optimalSection.appendChild(optimalInputs);
    const optimalDatalist = document.createElement('datalist');
    optimalDatalist.id = 'nodes-datalist-optimal';
    optimalSection.appendChild(optimalDatalist);
    const optimalResult = document.createElement('div');
    optimalResult.id = 'optimalPathsResult';
    optimalResult.style.display = 'none';
    optimalSection.appendChild(optimalResult);
    output.appendChild(optimalSection);

    // CPM / critical path section
    const cpmSection = document.createElement('div');
    cpmSection.id = 'cpmSection';
    cpmSection.className = 'section';
    cpmSection.innerHTML = '<h2>Projektov√© pl√°nov√°n√≠ (s√≠≈•ov√Ω graf & CPM)</h2>';
    
    // P≈ôidej detailn√≠ CPM legendu
    const cpmLegendDiv = document.createElement('div');
    cpmLegendDiv.style.backgroundColor = '#e7f3ff';
    cpmLegendDiv.style.padding = '0.75rem';
    cpmLegendDiv.style.borderRadius = '0.25rem';
    cpmLegendDiv.style.marginBottom = '1rem';
    cpmLegendDiv.style.border = '1px solid #0d6efd';
    cpmLegendDiv.innerHTML = `
        <strong>üìä CPM (Critical Path Method) ‚Äì Metoda kritick√© cesty</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>Co je CPM?</strong> Technika projektov√©ho ≈ô√≠zen√≠ pro pl√°nov√°n√≠ a optimalizaci harmonogramu.<br><br>
            <strong>Kl√≠ƒçov√© pojmy:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>ES (Early Start)</strong> ‚Äì Nejd≈ô√≠ve mo≈æn√Ω zaƒç√°tek ƒçinnosti</li>
                <li><strong>EF (Early Finish)</strong> ‚Äì Nejd≈ô√≠ve mo≈æn√Ω konec = ES + d√©lka</li>
                <li><strong>LS (Late Start)</strong> ‚Äì Nejpozdƒõji p≈ô√≠pustn√Ω zaƒç√°tek</li>
                <li><strong>LF (Late Finish)</strong> ‚Äì Nejpozdƒõji p≈ô√≠pustn√Ω konec (deadline)</li>
                <li><strong>Rezerva (Float/Slack)</strong> ‚Äì LS ‚àí ES = o kolik lze ƒçinnost zpozdit</li>
                <li><strong>Kritick√° cesta</strong> ‚Äì Nejdel≈°√≠ cesta projektem (nulov√° rezerva)</li>
            </ul>
            <strong>K ƒçemu je CPM dobr√°:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>Stavebnictv√≠</strong> ‚Äì pl√°nov√°n√≠ v√Ωstavby, koordinace subdodavatel≈Ø</li>
                <li><strong>V√Ωvoj software</strong> ‚Äì release planning, dependency management</li>
                <li><strong>V√Ωroba</strong> ‚Äì optimalizace v√Ωrobn√≠ch linek</li>
                <li><strong>Vƒõda</strong> ‚Äì pl√°nov√°n√≠ experiment≈Ø s n√°vaznostmi</li>
            </ul>
            <strong>üî• Kritick√© ƒçinnosti</strong> = ƒçinnosti s nulovou rezervou. Jak√©koli zpo≈ædƒõn√≠ prodlou≈æ√≠ projekt!
        </div>
    `;
    cpmSection.appendChild(cpmLegendDiv);
    
    const cpmIntro = document.createElement('p');
    cpmIntro.style.color = '#495057';
    cpmIntro.innerHTML = 'Hrany interpretujeme jako ƒçinnosti s d√©lkou podle v√°hy. CPM (Critical Path Method) spoƒç√≠t√° kritickou cestu, d√©lku projektu a rezervy ƒçinnost√≠, abyste mohli pl√°novat kapacity.';
    cpmSection.appendChild(cpmIntro);
    const cpmBtn = document.createElement('button');
    cpmBtn.id = 'runCpmAnalysis';
    cpmBtn.textContent = 'Analyzovat kritickou cestu (CPM)';
    cpmSection.appendChild(cpmBtn);
    const cpmResult = document.createElement('div');
    cpmResult.id = 'cpmResult';
    cpmResult.style.display = 'none';
    cpmSection.appendChild(cpmResult);
    output.appendChild(cpmSection);

    // Network flow section
    const flowSection = document.createElement('div');
    flowSection.id = 'flowSection';
    flowSection.className = 'section';
    flowSection.innerHTML = '<h2>S√≠≈•ov√© toky (maxim√°ln√≠ tok & minim√°ln√≠ ≈ôez)</h2>';
    
    // P≈ôidej detailn√≠ vysvƒõtlivku pro s√≠≈•ov√© toky
    const flowLegendDiv = document.createElement('div');
    flowLegendDiv.style.backgroundColor = '#e7f3ff';
    flowLegendDiv.style.padding = '0.75rem';
    flowLegendDiv.style.borderRadius = '0.25rem';
    flowLegendDiv.style.marginBottom = '1rem';
    flowLegendDiv.style.border = '1px solid #0d6efd';
    flowLegendDiv.innerHTML = `
        <strong>üåä S√≠≈•ov√© toky ‚Äì Maxim√°ln√≠ tok a Minim√°ln√≠ ≈ôez</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>Co je tok v s√≠ti?</strong> P≈ôeprava ‚Äûkomodity" ze zdroje (s) do c√≠le (t) respektuj√≠c√≠ kapacity hran.<br><br>
            <strong>Kl√≠ƒçov√© pojmy:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>Kapacita hrany</strong> ‚Äì maxim√°ln√≠ tok, kter√Ω m≈Ø≈æe hranou proj√≠t</li>
                <li><strong>Rezidu√°ln√≠ kapacita</strong> ‚Äì kolik je≈°tƒõ m≈Ø≈æe hranou prot√©ct</li>
                <li><strong>Zlep≈°uj√≠c√≠ cesta</strong> ‚Äì cesta s kladnou rezidu√°ln√≠ kapacitou</li>
                <li><strong>Min-cut vƒõta</strong> ‚Äì max tok = minim√°ln√≠ ≈ôez (Ford-Fulkerson)</li>
            </ul>
            <strong>Algoritmy:</strong>
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem; margin: 0.5rem 0;">
                <tr style="background-color: rgba(0,0,0,0.05);">
                    <th style="text-align: left; padding: 0.2rem;">Algoritmus</th>
                    <th style="text-align: left; padding: 0.2rem;">Slo≈æitost</th>
                    <th style="text-align: left; padding: 0.2rem;">P≈ô√≠stup</th>
                </tr>
                <tr>
                    <td style="padding: 0.2rem;">Ford-Fulkerson (DFS)</td>
                    <td style="padding: 0.2rem;">O(E √ó max_flow)</td>
                    <td style="padding: 0.2rem;">Zlep≈°uj√≠c√≠ cesty (DFS)</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.2rem;">Edmonds-Karp (BFS)</td>
                    <td style="padding: 0.2rem;">O(V √ó E¬≤)</td>
                    <td style="padding: 0.2rem;">Nejkrat≈°√≠ zlep≈°uj√≠c√≠ cesty</td>
                </tr>
                <tr>
                    <td style="padding: 0.2rem;">Goldberg (Push-Relabel)</td>
                    <td style="padding: 0.2rem;">O(V¬≤ √ó E)</td>
                    <td style="padding: 0.2rem;">Lok√°ln√≠ operace, v√Ω≈°ky uzl≈Ø</td>
                </tr>
            </table>
            <strong>Praktick√© vyu≈æit√≠:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Logistika</strong> ‚Äì maxim√°ln√≠ p≈ôepravn√≠ kapacita</li>
                <li><strong>Poƒç√≠taƒçov√© s√≠tƒõ</strong> ‚Äì bandwidth, load balancing</li>
                <li><strong>Bipartitn√≠ p√°rov√°n√≠</strong> ‚Äì p≈ôi≈ôazov√°n√≠ √∫kol≈Ø, svatebn√≠ probl√©m</li>
                <li><strong>Segmentace obrazu</strong> ‚Äì min-cut pro oddƒõlen√≠ objekt≈Ø</li>
            </ul>
        </div>
    `;
    flowSection.appendChild(flowLegendDiv);
    
    const flowIntro = document.createElement('p');
    flowIntro.style.color = '#495057';
    flowIntro.innerHTML = 'Pro orientovan√Ω graf m≈Ø≈æeme vytvo≈ôit <strong>s√≠≈•</strong>: hrany ch√°peme jako kapacity a hled√°me maxim√°ln√≠ tok ze zdroje <em>s</em> do c√≠le <em>t</em>. Ford≈Øv-Fulkerson≈Øv a Edmonds≈Øv-Karp≈Øv algoritmus vyu≈æ√≠vaj√≠ zlep≈°uj√≠c√≠ polocesty, Goldberg≈Øv algoritmus (push-relabel) pracuje s v√Ω≈°kami uzl≈Ø.';
    flowSection.appendChild(flowIntro);
    const flowInputs = document.createElement('div');
    flowInputs.className = 'query-inputs';
    flowInputs.innerHTML = `
        <input id="flowSource" list="nodes-datalist-flow" placeholder="Zdroj (s)">
        <input id="flowSink" list="nodes-datalist-flow" placeholder="C√≠l (t)">
        <button id="runFlowAnalysis">Analyzovat tok v s√≠ti</button>
    `;
    flowSection.appendChild(flowInputs);
    const flowDatalist = document.createElement('datalist');
    flowDatalist.id = 'nodes-datalist-flow';
    flowSection.appendChild(flowDatalist);
    const flowResult = document.createElement('div');
    flowResult.id = 'flowResult';
    flowResult.style.display = 'none';
    flowSection.appendChild(flowResult);
    output.appendChild(flowSection);

    const theorySection = document.createElement('div');
    theorySection.id = 'graphTheoryGuide';
    theorySection.className = 'section';
    theorySection.innerHTML = `
        <h2>üìò Teoretick√Ω rozcestn√≠k (grafy)</h2>
        <p style="color: #495057;">Kr√°tk√Ω tah√°k k pojm≈Øm, kter√© p≈ôi pr√°ci s grafy nejƒçastƒõji pou≈æ√≠v√°me:</p>
        <ul style="line-height: 1.8; padding-left: 1.25rem;">
            <li><strong>Kostra grafu:</strong> Podgraf, kter√Ω obsahuje v≈°echny uzly a jen tolik hran, aby byl graf st√°le souvisl√Ω (tedy ≈æ√°dn√© cykly).</li>
            <li><strong>Minim√°ln√≠ kostra grafu:</strong> Soubor hran s nejni≈æ≈°√≠ mo≈ænou v√°hou. Typicky ji hled√°me Jarn√≠k≈Øv-Prim≈Øv-Dijkstr≈Øv algoritmus nebo Kruskalem.</li>
            <li><strong>Maxim√°ln√≠ kostra grafu:</strong> Analogicky hled√° nejvy≈°≈°√≠ celkovou v√°hu ‚Äì hod√≠ se nap≈ô√≠klad pro maximalizaci kapacity.</li>
            <li><strong>Laplaceova matice:</strong> L = D - A. Pom√°h√° n√°m spoƒç√≠tat poƒçet koster (vƒõta o matici strom≈Ø) a popsat spektr√°ln√≠ vlastnosti grafu.</li>
            <li><strong>Jarn√≠k≈Øv-Prim≈Øv-Dijkstr≈Øv algoritmus:</strong> Greedy p≈ô√≠stup ‚Äì zaƒçneme v n√°hodn√©m uzlu a opakovanƒõ p≈ôid√°v√°me nejlevnƒõj≈°√≠ hranu, kter√° neuzav√≠r√° cyklus.</li>
            <li><strong>Kruskal≈Øv algoritmus:</strong> Se≈ôad√≠ v≈°echny hrany podle v√°hy, p≈ôid√°v√° je od nejmen≈°√≠ch, a p≈ôes sjednocov√°n√≠ komponent hl√≠d√°, aby nevznikaly cykly.</li>
            <li><strong>Bor≈Øvk≈Øv-Sollin≈Øv algoritmus:</strong> Ka≈æd√° komponenta si vyb√≠r√° svou nejlevnƒõj≈°√≠ incidentn√≠ hranu a komponenty se paralelnƒõ spojuj√≠, dokud nez≈Østane jedna.</li>
            <li><strong>Prohled√°v√°n√≠ do ≈°√≠≈ôky (BFS):</strong> Vrstevnat√Ω pr≈Øchod grafem ‚Äì nejprve v≈°echny sousedy, pak sousedy soused≈Ø. Pou≈æ√≠v√°me frontu.</li>
            <li><strong>Prohled√°v√°n√≠ do hloubky (DFS):</strong> V≈ædy pokraƒçujeme co nejd√°l, dokud nenaraz√≠me na slepou vƒõtev, pak se vrac√≠me. Pou≈æ√≠v√°me z√°sobn√≠k (nebo rekurzi).</li>
            <li><strong>Tok v s√≠ti:</strong> Orientovan√Ω graf s kapacitami hran (s√≠≈•) a dvƒõma speci√°ln√≠mi uzly <em>s</em> (zdroj) a <em>t</em> (c√≠l). Hled√°me maxim√°ln√≠ tok, kter√Ω respektuje kapacitn√≠ omezen√≠ i rovnov√°hu v uzlech.</li>
            <li><strong>Rezervn√≠ kapacita cesty:</strong> Nejmen≈°√≠ z kapacit (resp. rezidu√°ln√≠ch kapacit) pod√©l vybran√© cesty. Ud√°v√°, o kolik lze zv√Ω≈°it tok po zlep≈°uj√≠c√≠ polocestƒõ.</li>
            <li><strong>Zlep≈°uj√≠c√≠ polocesta:</strong> Cesta v rezidu√°ln√≠ s√≠ti se z√°pasem od <em>s</em> do <em>t</em>, kter√° m√° kladnou rezervn√≠ kapacitu ‚Äì umo≈æ≈àuje zv√Ω≈°it celkov√Ω tok.</li>
            <li><strong>Ford≈Øv-Fulkerson≈Øv / Edmonds≈Øv-Karp≈Øv algoritmus:</strong> Hledaj√≠ zlep≈°uj√≠c√≠ polocesty (DFS resp. BFS) a iterativnƒõ zvƒõt≈°uj√≠ tok. Edmonds≈Øv-Karp garantuje polynomi√°ln√≠ ƒças.</li>
            <li><strong>Goldberg≈Øv algoritmus (push-relabel):</strong> Udr≈æuje v√Ω≈°ku (label) uzl≈Ø, p≈ôepos√≠l√° p≈ôebytky (push) a dynamicky p≈ôelad√≠ v√Ω≈°ky tak, aby byl nalezen maxim√°ln√≠ tok i minim√°ln√≠ ≈ôez.</li>
        </ul>
    `;
    output.appendChild(theorySection);

    // Populate explore datalist
    const exploreDatalist = document.getElementById('nodes-datalist-explore');
    const optimalDatalistEl = document.getElementById('nodes-datalist-optimal');
    const flowDatalistEl = document.getElementById('nodes-datalist-flow');
    const fillDatalist = (listEl) => {
        if (!listEl) return;
        listEl.innerHTML = '';
        graph.nodes.forEach(node => {
            const option = document.createElement('option');
            option.value = node;
            listEl.appendChild(option);
        });
    };
    fillDatalist(exploreDatalist);
    fillDatalist(optimalDatalistEl);
    fillDatalist(flowDatalistEl);

    const optimalButton = document.getElementById('runOptimalPaths');
    if (optimalButton) {
        optimalButton.addEventListener('click', () => {
            const startNode = document.getElementById('optimalStartNode').value.trim();
            const endNode = document.getElementById('optimalEndNode').value.trim();
            const resultDiv = document.getElementById('optimalPathsResult');
            if (!resultDiv) return;
            if (!startNode || !endNode) {
                resultDiv.innerHTML = '<p style="color:#dc3545;">Vypl≈àte pros√≠m oba uzly.</p>';
                resultDiv.style.display = 'block';
                return;
            }
            const dijkstra = graph.shortestPath(startNode, endNode);
            const moore = graph.mooreShortestPath(startNode, endNode);
            const bellman = graph.bellmanFordPath(startNode, endNode);
            const longest = graph.longestPathInfo(startNode, endNode);
            const safest = graph.safestPath(startNode, endNode);
            const widest = graph.widestPath(startNode, endNode);
            const formatPath = (arr) => (arr && arr.length ? arr.join(' ‚Üí ') : 'Cesta nenalezena');
            const formatDistance = (val) => {
                if (val === null || val === undefined) return '‚Äî';
                if (val === Infinity) return '‚àû';
                if (!Number.isFinite(val)) return '‚Äî';
                const rounded = Math.round((val + Number.EPSILON) * 100) / 100;
                return Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(2);
            };
            let html = '<div class="optimal-grid">';
            html += `<div class="result-box">
                <div class="result-label">Nejkrat≈°√≠ cesta (Dijkstr≈Øv algoritmus)</div>
                <div>Vzd√°lenost: ${formatDistance(dijkstra ? dijkstra.distance : null)}</div>
                <div>Cesta: ${formatPath(dijkstra ? dijkstra.path : [])}</div>
            </div>`;
            html += `<div class="result-box">
                <div class="result-label">Moor≈Øv algoritmus (BFS)</div>
                <div>Poƒçet hran: ${moore && moore.distance !== Infinity ? moore.distance : 'Cesta nenalezena'}</div>
                <div>Cesta: ${formatPath(moore ? moore.path : [])}</div>
            </div>`;
            const bellmanWarning = bellman && bellman.negativeCycle ? '<div style="color:#dc3545; margin-top:0.25rem;">Varov√°n√≠: Detekov√°na z√°porn√° kru≈ænice ‚Äì v√Ωsledky mohou b√Ωt neplatn√©.</div>' : '';
            html += `<div class="result-box">
                <div class="result-label">Bellman-Ford≈Øv algoritmus</div>
                <div>Vzd√°lenost: ${formatDistance(bellman ? bellman.distance : null)}</div>
                <div>Cesta: ${formatPath(bellman ? bellman.path : [])}</div>
                ${bellmanWarning}
            </div>`;
            const longestNote = longest
                ? (longest.mode === 'fallback'
                    ? '<div style="font-size:0.85rem; color:#6c757d;">Graf nen√≠ DAG, proto se prohled√°vaj√≠ jednoduch√© cesty (omezeno na 2000).</div>'
                    : '<div style="font-size:0.85rem; color:#6c757d;">V√Ωpoƒçet v DAG pomoc√≠ topologick√©ho po≈ôad√≠.</div>')
                : '';
            html += `<div class="result-box">
                <div class="result-label">Nejdel≈°√≠ cesta</div>
                <div>D√©lka: ${formatDistance(longest ? longest.weight : null)}</div>
                <div>Cesta: ${formatPath(longest ? longest.path : [])}</div>
                ${longestNote}
            </div>`;
            
            // Nejbezpeƒçnƒõj≈°√≠ cesta - zpracov√°n√≠ chyb a zobrazen√≠ vzorce
            let safestError = safest && safest.error ? `<div style="color:#dc3545; margin-top:0.25rem;">‚ö†Ô∏è ${safest.error}</div>` : '';
            const reliability = safest && safest.reliability !== null ? Math.min(1, Math.max(0, safest.reliability || 0)) : 0;
            const totalWeightInfo = safest && safest.totalWeight !== undefined 
                ? `<div style="font-size:0.85rem; color:#6c757d;">Souƒçet vah: ${formatDistance(safest.totalWeight)} ‚Üí r = exp(-${formatDistance(safest.totalWeight)}) = ${(reliability * 100).toFixed(2)}%</div>` 
                : '';
            html += `<div class="result-box">
                <div class="result-label">Nejbezpeƒçnƒõj≈°√≠ cesta (maximalizace spolehlivosti)</div>
                <div>Spolehlivost: ${safest && safest.error ? '‚Äî' : (reliability * 100).toFixed(2) + ' %'}</div>
                <div>Cesta: ${formatPath(safest ? safest.path : [])}</div>
                ${totalWeightInfo}
                ${safestError}
                <div style="font-size:0.8rem; color:#6c757d; margin-top:0.25rem;">Vzorec: r = exp(‚àíw), kde w je v√°ha hrany</div>
            </div>`;
            
            // Nej≈°ir≈°√≠ cesta - zpracov√°n√≠ chyb pro z√°porn√© kapacity
            let widestError = widest && widest.error ? `<div style="color:#dc3545; margin-top:0.25rem;">‚ö†Ô∏è ${widest.error}</div>` : '';
            html += `<div class="result-box">
                <div class="result-label">Nej≈°ir≈°√≠ cesta (max-min kapacita)</div>
                <div>Kritick√© hrdlo: ${widest && widest.error ? '‚Äî' : formatDistance(widest ? widest.width : null)}</div>
                <div>Cesta: ${formatPath(widest ? widest.path : [])}</div>
                ${widestError}
            </div>`;
            html += '</div>';
            html += '<p style="font-size:0.9rem; color:#495057; margin-top:0.75rem;">Tip: √∫plnou matici nejkrat≈°√≠ch cest poskytuje sekce ‚ÄûNejkrat≈°√≠ cesty (Floyd-Warshall)‚Äú.</p>';
            resultDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        });
    }

    const cpmButton = document.getElementById('runCpmAnalysis');
    if (cpmButton) {
        cpmButton.addEventListener('click', () => {
            const result = graph.cpmAnalysis();
            const cpmDiv = document.getElementById('cpmResult');
            if (!cpmDiv) return;
            if (!result || result.error) {
                cpmDiv.innerHTML = `<p style="color:#dc3545;">${result && result.error ? result.error : 'Anal√Ωza se nezda≈ôila.'}</p>`;
                cpmDiv.style.display = 'block';
                return;
            }
            const formatNum = (val) => Number.isFinite(val) ? (Math.round((val + Number.EPSILON) * 100) / 100).toString() : '‚Äî';
            const criticalPath = result.criticalPath && result.criticalPath.length
                ? result.criticalPath.join(' ‚Üí ')
                : 'Nenalezena';
            let html = `<div class="result-box">
                <div class="result-label">Shrnut√≠ CPM</div>
                <div><strong>D√©lka projektu:</strong> ${formatNum(result.projectDuration)}</div>
                <div><strong>Poƒçet kritick√Ωch ƒçinnost√≠:</strong> ${result.criticalEdgesCount}</div>
                <div><strong>Kritick√° cesta:</strong> ${criticalPath}</div>
            </div>`;
            html += '<h4 style="margin-top: 1rem; margin-bottom: 0.5rem; color: #0d6efd;">üìç Uzlov√© ƒçasy (miln√≠ky projektu)</h4>';
            html += '<p style="font-size: 0.85rem; color: #6c757d; margin-bottom: 0.5rem;">Ka≈æd√Ω uzel p≈ôedstavuje ud√°lost/miln√≠k. ES = nejd≈ô√≠ve mo≈æn√Ω start, EF = nejd≈ô√≠ve mo≈æn√© ukonƒçen√≠, LS = nejpozdƒõji p≈ô√≠pustn√Ω start, LF = nejpozdƒõji p≈ô√≠pustn√© ukonƒçen√≠.</p>';
            html += '<div class="scrollable-list">';
            html += '<table><thead><tr><th>Uzel</th><th>ES</th><th>EF</th><th>LS</th><th>LF</th><th>Rezerva</th><th>Je kritick√Ω?</th></tr></thead><tbody>';
            result.nodeSummaries.forEach(node => {
                html += `<tr>
                    <td>${node.id}</td>
                    <td>${formatNum(node.es !== undefined ? node.es : node.earliest)}</td>
                    <td>${formatNum(node.ef !== undefined ? node.ef : node.earliest)}</td>
                    <td>${formatNum(node.ls !== undefined ? node.ls : node.latest)}</td>
                    <td>${formatNum(node.lf !== undefined ? node.lf : node.latest)}</td>
                    <td>${formatNum(node.slack)}</td>
                    <td>${node.isCritical ? 'ANO' : 'ne'}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            html += '<h4 style="margin-top: 1.5rem; margin-bottom: 0.5rem; color: #198754;">üîó Hranov√© aktivity (ƒçinnosti projektu)</h4>';
            html += '<p style="font-size: 0.85rem; color: #6c757d; margin-bottom: 0.5rem;">Ka≈æd√° hrana p≈ôedstavuje ƒçinnost s urƒçitou d√©lkou trv√°n√≠. ES = nejd≈ô√≠ve mo≈æn√Ω start, EF = nejd≈ô√≠ve mo≈æn√© ukonƒçen√≠, LS = nejpozdƒõji p≈ô√≠pustn√Ω start, LF = nejpozdƒõji p≈ô√≠pustn√© ukonƒçen√≠.</p>';
            html += '<div class="scrollable-list" style="margin-top:0.5rem;">';
            html += '<table><thead><tr><th>Hrana</th><th>V√°ha hrany</th><th>ES</th><th>EF</th><th>LS</th><th>LF</th><th>Rezerva</th><th>Je kritick√°?</th></tr></thead><tbody>';
            result.activities.forEach(act => {
                const edgeLabel = act.id || `${act.from}‚Üí${act.to}`;
                html += `<tr>
                    <td>${edgeLabel}</td>
                    <td>${formatNum(act.duration)}</td>
                    <td>${formatNum(act.earlyStart)}</td>
                    <td>${formatNum(act.earlyFinish)}</td>
                    <td>${formatNum(act.lateStart)}</td>
                    <td>${formatNum(act.lateFinish)}</td>
                    <td>${formatNum(act.slack)}</td>
                    <td>${act.isCritical ? 'ANO' : 'ne'}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            html += '<p style="font-size:0.9rem; color:#495057; margin-top:0.5rem;">Rezerva ƒçinnosti (float) = LS ‚àí ES. ƒåinnosti s nulovou rezervou tvo≈ô√≠ kritickou cestu (CPM).</p>';
            cpmDiv.innerHTML = html;
            cpmDiv.style.display = 'block';
        });
    }

    const flowButton = document.getElementById('runFlowAnalysis');
    if (flowButton) {
        flowButton.addEventListener('click', () => {
            const source = document.getElementById('flowSource').value.trim();
            const sink = document.getElementById('flowSink').value.trim();
            const flowDiv = document.getElementById('flowResult');
            if (!flowDiv) return;
            if (!source || !sink) {
                flowDiv.innerHTML = '<p style="color:#dc3545;">Zadejte pros√≠m zdroj <em>s</em> i c√≠l <em>t</em>.</p>';
                flowDiv.style.display = 'block';
                return;
            }
            const analysis = graph.flowNetworkAnalysis(source, sink);
            if (!analysis || analysis.error) {
                flowDiv.innerHTML = `<p style="color:#dc3545;">${analysis && analysis.error ? analysis.error : 'Anal√Ωza toku se nezda≈ôila.'}</p>`;
                flowDiv.style.display = 'block';
                return;
            }
            const formatNum = (val) => {
                if (!Number.isFinite(val)) return '0';
                const rounded = Math.round((val + Number.EPSILON) * 100) / 100;
                return Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(2);
            };
            const formatEdges = (edges) => {
                if (!edges || !edges.length) return '<p>Tok nen√≠ veden√Ω ≈æ√°dnou hranou.</p>';
                const rows = edges.slice(0, 6).map(edge => {
                    const utilRatio = (edge.utilization !== undefined && edge.utilization !== null)
                        ? edge.utilization
                        : (edge.capacity > 0 ? edge.flow / edge.capacity : 0);
                    const utilPercent = Number.isFinite(utilRatio) ? Math.min(100, Math.max(0, utilRatio * 100)) : 0;
                    return `<li>${edge.from} ‚Üí ${edge.to}: ${formatNum(edge.flow)} / ${formatNum(edge.capacity)} (vyu≈æit√≠ ${utilPercent.toFixed(1)} %)</li>`;
                }).join('');
                return `<ul>${rows}</ul>`;
            };
            const formatAugPaths = (paths) => {
                if (!paths || !paths.length) return '<li>≈Ω√°dn√° zlep≈°uj√≠c√≠ polocesta nebyla nalezena.</li>';
                return paths.slice(0, 5).map((p, idx) =>
                    `<li>${idx + 1}. ${p.path.join(' ‚Üí ')} (rezervn√≠ kapacita cesty: ${formatNum(p.bottleneck)})</li>`
                ).join('');
            };
            const minCut = analysis.minCut || { value: 0, S: [], T: [], edges: [] };
            const cutEdges = (minCut.edges || []).slice(0, 6).map(edge => `${edge.from} ‚Üí ${edge.to} (${formatNum(edge.capacity)})`).join(', ') || '‚Äî';
            const capacityInfo = analysis.capacitySummary || { outFromSource: 0, intoSink: 0 };
            const buildAlgorithmBox = (title, data, extraInfo = '') => {
                if (!data) return '';
                const pathList = data.augmentingPaths
                    ? `<div style="margin-top:0.5rem;"><strong>Zlep≈°uj√≠c√≠ polocesty:</strong><ul>${formatAugPaths(data.augmentingPaths)}</ul></div>`
                    : '<p style="margin-top:0.5rem; font-size:0.9rem; color:#6c757d;">Push-relabel varianta nepracuje s explicitn√≠mi polocestami, ale s p≈ôebytky a v√Ω≈°kami uzl≈Ø.</p>';
                const extraStats = [];
                if (typeof data.iterations === 'number') {
                    extraStats.push(`<div>Poƒçet polocest: ${data.iterations}</div>`);
                }
                if (typeof data.relabelCount === 'number') {
                    extraStats.push(`<div>Relabel operace: ${data.relabelCount}</div>`);
                }
                if (typeof data.pushCount === 'number') {
                    extraStats.push(`<div>Push operace: ${data.pushCount}</div>`);
                }
                if (data.heightProfile) {
                    const interesting = data.heightProfile
                        .filter(h => Number.isFinite(h.height))
                        .sort((a, b) => b.height - a.height)
                        .slice(0, 3)
                        .map(item => `${item.node}: ${item.height}`);
                    if (interesting.length) {
                        extraStats.push(`<div>V√Ω≈°ky (Goldberg): ${interesting.join(', ')}</div>`);
                    }
                }
                return `<div class="result-box">
                    <div class="result-label">${title}</div>
                    <div><strong>Maxim√°ln√≠ tok:</strong> ${formatNum(data.maxFlow || 0)}</div>
                    ${extraInfo ? `<div>${extraInfo}</div>` : ''}
                    ${extraStats.join('')}
                    <div style="margin-top:0.5rem;"><strong>Toky hran:</strong>${formatEdges(data.flowEdges || [])}</div>
                    ${pathList}
                </div>`;
            };
            let html = `<div class="result-box">
                <div class="result-label">Souhrn s√≠tƒõ</div>
                <p><strong>Tok v s√≠ti:</strong> nejlep≈°√≠ dosa≈æen√Ω maxim√°ln√≠ tok je ${formatNum(analysis.bestFlow || 0)} jednotek.</p>
                <p><strong>Kapacita ze zdroje:</strong> ${formatNum(capacityInfo.outFromSource || 0)} | <strong>Kapacita do c√≠le:</strong> ${formatNum(capacityInfo.intoSink || 0)}</p>
                <p><strong>Minim√°ln√≠ ≈ôez:</strong> ${formatNum(minCut.value || 0)} (S = {${minCut.S.join(', ')}}, T = {${minCut.T.join(', ')}})</p>
                <p><strong>Hrany ≈ôezu:</strong> ${cutEdges}</p>
            </div>`;
            html += '<div class="optimal-grid">';
            html += buildAlgorithmBox('Ford≈Øv-Fulkerson≈Øv algoritmus (DFS polocesty)', analysis.fordFulkerson, 'Zlep≈°uj√≠c√≠ polocesty hled√°me do hloubky.');
            html += buildAlgorithmBox('Edmonds≈Øv-Karp≈Øv algoritmus (BFS polocesty)', analysis.edmondsKarp, 'Polocesty jsou nejkrat≈°√≠ podle poƒçtu hran, proto se tok stabilizuje rychleji.');
            html += buildAlgorithmBox('Goldberg≈Øv algoritmus (push-relabel)', analysis.goldberg, '');
            html += '</div>';
            html += '<p style="font-size:0.9rem; color:#495057; margin-top:0.5rem;">Rezervn√≠ kapacita cesty = minimum rezidu√°ln√≠ch kapacit na zlep≈°uj√≠c√≠ polocestƒõ. Jakmile ≈æ√°dn√° takov√° polocesta neexistuje, aktu√°ln√≠ tok je maxim√°ln√≠ a odpov√≠d√° minim√°ln√≠mu ≈ôezu.</p>';
            flowDiv.innerHTML = html;
            flowDiv.style.display = 'block';
        });
    }

    document.getElementById('runTraversal').addEventListener('click', () => {
        const algo = document.getElementById('traversalAlgo').value;
        const startNode = document.getElementById('startNode').value;
        const graph = new Graph();
        graph.parse(document.getElementById('graphInput').value);
        let result = [];
        if (algo === 'bfs') {
            result = graph.bfsTraversal(startNode);
        } else {
            result = graph.dfsTraversal(startNode);
        }

        let html = `<h4>V√Ωsledek pro ${algo.toUpperCase()} od ${startNode}:</h4>`;
        html += `<p>Po≈ôad√≠ nav≈°t√≠ven√Ωch uzl≈Ø: ${result.join(' ‚Üí ')}</p>`;
        html += `<p>Dosa≈æiteln√Ωch uzl≈Ø: ${result.length}</p>`;

        const exploreResult = document.getElementById('exploreResult');
        exploreResult.innerHTML = html;
        exploreResult.style.display = 'block';
    });

    document.getElementById('runSpanningTree').addEventListener('click', () => {
        const graph = new Graph();
        graph.parse(document.getElementById('graphInput').value);
    const mst = graph.minimumSpanningTree();
    const maxTree = graph.maximumSpanningTree();
    const forestInfo = graph.countSpanningForests();
    
    let html = `<h4>V√Ωsledky anal√Ωzy kostry grafu:</h4>`;
    
    if (forestInfo.componentCount === 1) {
        // Souvisl√Ω graf - jednoduch√Ω v√Ωpis
        const countLabel = Number.isFinite(forestInfo.total) ? forestInfo.total : 'p≈ô√≠li≈° velk√© ƒç√≠slo (nelze bezpeƒçnƒõ zobrazit)';
        html += `<p><strong>Poƒçet koster:</strong> ${countLabel}</p>`;
    } else {
        // Nesouvisl√Ω graf - v√Ωpis po komponent√°ch
        const totalLabel = Number.isFinite(forestInfo.total) ? forestInfo.total : 'p≈ô√≠li≈° velk√© ƒç√≠slo';
        html += `<div style="background-color: #fff3cd; padding: 0.75rem; border-radius: 0.25rem; border: 1px solid #ffc107; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0;"><strong>üå≤ Poƒçet spanning forests (les≈Ø koster):</strong> ${totalLabel}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #856404;">Graf m√° ${forestInfo.componentCount} komponent. Celkov√Ω poƒçet spanning forests = souƒçin poƒçtu koster v≈°ech komponent.</p>`;
        html += `<div style="margin-top: 0.5rem;">`;
        forestInfo.perComponent.forEach((comp, idx) => {
            const compCountLabel = Number.isFinite(comp.count) ? comp.count : '‚àû';
            html += `<div style="font-size: 0.85rem; margin: 0.25rem 0;"><strong>Komponenta ${idx + 1}</strong> (${comp.nodes.length} uzl≈Ø): ${compCountLabel} koster</div>`;
        });
        html += `</div></div>`;
    }

        const renderTreeList = (title, treeData) => {
            const forest = (treeData && treeData.componentTrees && treeData.componentTrees.length)
                ? treeData.componentTrees
                : [{ nodes: graph.nodes, edges: treeData ? treeData.tree : [], totalWeight: treeData ? treeData.totalWeight : 0 }];
            const hasEdges = forest.some(component => component.edges.length);
            if (!hasEdges) {
                return `<p><strong>${title}:</strong> Nelze sestavit ‚Äì graf nen√≠ souvisl√Ω nebo neobsahuje ≈æ√°dn√© hrany.</p>`;
            }

            const componentCount = treeData && typeof treeData.componentCount === 'number'
                ? treeData.componentCount
                : 1;

            let block = `<div style="margin-top: 0.75rem;">
                <strong>${title}${componentCount === 1 ? ` (v√°ha: ${Math.round((treeData.totalWeight + Number.EPSILON) * 100) / 100})` : ''}</strong>`;
            if (componentCount > 1) {
                block += `<p style="margin: 0.25rem 0; font-size: 0.9rem; color: #495057;">Graf m√° ${componentCount} komponent ‚Äì zobrazujeme minim√°ln√≠ kostry jednotliv√Ωch komponent (spanning forest).</p>`;
            }

            forest.forEach((component, idx) => {
                const compWeight = component.totalWeight !== undefined ? component.totalWeight : component.edges.reduce((sum, edge) => {
                    const w = edge.weight !== null && edge.weight !== undefined ? edge.weight : 1;
                    return sum + w;
                }, 0);
                if (componentCount > 1) {
                    block += `<div style="margin-top:0.5rem; font-weight:600;">Komponenta ${idx + 1} ‚Äì ${component.nodes.length} uzl≈Ø, v√°ha ${compWeight}</div>`;
                }
                if (!component.edges.length) {
                    block += `<p style="margin:0.25rem 0 0.5rem 0; font-size:0.9rem; color:#6c757d;">Komponenta obsahuje pouze izolovan√Ω uzel (${component.nodes.join(', ')}).</p>`;
                    return;
                }
                block += '<ul>' + component.edges.map(edge => {
                    const w = edge.weight !== null && edge.weight !== undefined ? edge.weight : 1;
                    return `<li>${edge.u} - ${edge.v} (v√°ha: ${w})${edge.label ? ` ‚Äì ${edge.label}` : ''}</li>`;
                }).join('') + '</ul>';
            });

            block += '</div>';
            return block;
        };

        html += renderTreeList('Minim√°ln√≠ kostra (Jarn√≠k-Prim-Dijkstra)', mst);
        html += renderTreeList('Maxim√°ln√≠ kostra (obr√°cen√° heuristika)', maxTree);
        html += `<p style="margin-top: 0.75rem; font-size: 0.9rem; color: #084298;">
            Minim√°ln√≠ kostru poƒç√≠t√°me variantou Jarn√≠kova-Primova algoritmu ‚Äì zaƒç√≠n√°me v jednom uzlu a p≈ôid√°v√°me nejlevnƒõj≈°√≠ hranu, kter√° graf dr≈æ√≠ souvisl√Ω.
            Maxim√°ln√≠ kostra vyu≈æ√≠v√° stejn√Ω princip, ale hrany bereme od nejtƒõ≈æ≈°√≠ch k nejlehƒç√≠m, tak≈æe dostaneme nejdra≈æ≈°√≠ mo≈ænou kostru.
            Celkov√Ω poƒçet koster z√≠sk√°v√°me pomoc√≠ Laplaceovy matice a vƒõty o matici strom≈Ø.
        </p>`;

        const spanningTreeResult = document.getElementById('spanningTreeResult');
        spanningTreeResult.innerHTML = html;
        spanningTreeResult.style.display = 'block';
    });
});

document.addEventListener('change', function(event) {
    if (event.target.classList.contains('matrix-stats-toggle')) {
        const advancedStatsDiv = event.target.nextElementSibling.nextElementSibling;
        if (advancedStatsDiv) {
            advancedStatsDiv.style.display = event.target.checked ? 'block' : 'none';
        }
    }
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// V√ÅNOƒåN√ç SVƒöT√ùLKA - CHRISTMAS LIGHTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function generateChristmasLights() {
    const container = document.getElementById('lightsContainer');
    const colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
    const screenWidth = window.innerWidth;
    const lightSpacing = 45;
    const numberOfLights = Math.floor(screenWidth / lightSpacing);
    
    container.innerHTML = '';
    
    for (let i = 0; i < numberOfLights; i++) {
        const light = document.createElement('div');
        light.className = 'light ' + colors[i % colors.length];
        light.style.animationDelay = (Math.random() * 2) + 's, ' + (Math.random() * 2) + 's';
        container.appendChild(light);
    }
}

// Inicializovat svƒõt√Ωlka
generateChristmasLights();
window.addEventListener('resize', generateChristmasLights);
</script>
</body>
</html>
