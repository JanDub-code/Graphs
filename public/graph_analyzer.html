<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="utf-8">
    <title>Graph Analyzer</title>
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           THEME VARIABLES - Light & Dark Mode
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        :root {
            /* Light theme (default) */
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e9ecef;
            --bg-info: #e7f3ff;
            --bg-success: #d1e7dd;
            --bg-properties: #e2e3e5;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-accent: #0d6efd;
            --text-accent-hover: #0b5ed7;
            --text-muted: #6c757d;
            --text-info: #084298;
            --text-success: #198754;
            --text-danger: #dc3545;
            --border-color: #dee2e6;
            --border-input: #ced4da;
            --border-info: #b6d4fe;
            --btn-primary-bg: #0d6efd;
            --btn-primary-hover: #0b5ed7;
            --shadow-color: rgba(0, 0, 0, 0.15);
            --shadow-accent: rgba(13, 110, 253, 0.4);
            --tooltip-bg: rgba(0, 0, 0, 0.8);
            --tooltip-text: #ffffff;
        }

        [data-theme="dark"] {
            /* Dark theme */
            --bg-primary: #1a1d21;
            --bg-secondary: #2d3238;
            --bg-tertiary: #3d444d;
            --bg-info: #1e3a5f;
            --bg-success: #1e3a2f;
            --bg-properties: #3d444d;
            --bg-warning: #3d3215;
            --text-primary: #e9ecef;
            --text-secondary: #adb5bd;
            --text-accent: #6ea8fe;
            --text-accent-hover: #3d8bfd;
            --text-muted: #868e96;
            --text-info: #6ea8fe;
            --text-success: #20c997;
            --text-danger: #e35d6a;
            --text-warning: #ffc107;
            --border-color: #495057;
            --border-input: #5c636a;
            --border-info: #3d6cb3;
            --btn-primary-bg: #0d6efd;
            --btn-primary-hover: #3d8bfd;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-accent: rgba(61, 139, 253, 0.4);
            --tooltip-bg: rgba(45, 50, 56, 0.95);
            --tooltip-text: #e9ecef;
        }

        /* Smooth transitions for theme changes */
        body, .query-section, .result-box, .scrollable-list, table, th, td, 
        textarea, select, button, .properties span, .query-result {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           THEME TOGGLE BUTTON
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .theme-toggle {
            position: fixed;
            top: 60px;
            right: 20px;
            z-index: 1001;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-accent);
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px var(--shadow-color);
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.1) rotate(15deg);
            box-shadow: 0 6px 20px var(--shadow-accent);
        }

        .theme-toggle .icon {
            transition: transform 0.5s ease;
        }

        .theme-toggle:hover .icon {
            transform: rotate(360deg);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BASE STYLES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        h1, h2, h3 {
            color: var(--text-accent);
        }
        textarea {
            width: 100%;
            max-width: 100%;
            min-height: 160px;
            padding: 0.5rem;
            border: 1px solid var(--border-input);
            border-radius: 0.25rem;
            font-family: monospace;
            margin-bottom: 1rem;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background-color: var(--btn-primary-bg);
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            margin-bottom: 1rem;
            margin-right: 0.5rem;
        }
        button:hover {
            background-color: var(--btn-primary-hover);
        }
        button:disabled {
            background-color: var(--text-muted);
            cursor: not-allowed;
        }
        table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }
        th, td {
            border: 1px solid var(--border-color);
            padding: 0.25rem 0.5rem;
            text-align: center;
        }
        th {
            background-color: var(--bg-tertiary);
        }
        .matrix {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        .section {
            margin-bottom: 2rem;
        }
        .properties span {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            padding: 0.25rem 0.5rem;
            background-color: var(--bg-properties);
            border-radius: 0.25rem;
        }
        .query-section {
            background-color: var(--bg-secondary);
            padding: 1rem;
            border: 1px solid var(--border-input);
            border-radius: 0.25rem;
            margin-bottom: 1rem;
        }
        .query-inputs {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .query-inputs select {
            padding: 0.5rem;
            border: 1px solid var(--border-input);
            border-radius: 0.25rem;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        .query-result {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: var(--bg-info);
            border-radius: 0.25rem;
            font-weight: bold;
        }
        /* Info box - light blue background */
        .info-box {
            background-color: var(--bg-info) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-info) !important;
        }
        /* Dark mode override for info box - override inline #e7f3ff */
        [data-theme="dark"] .info-box {
            background-color: var(--bg-info) !important;
            background: var(--bg-info) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-info) !important;
        }
        /* Warning box - light yellow background */
        .warning-box {
            background-color: var(--bg-warning) !important;
            color: var(--text-primary) !important;
            border-color: var(--text-warning) !important;
        }
        /* Dark mode override for warning box - override inline #fff3cd */
        [data-theme="dark"] .warning-box {
            background-color: var(--bg-warning) !important;
            background: var(--bg-warning) !important;
            color: var(--text-primary) !important;
            border-color: var(--text-warning) !important;
        }
        /* Stats box - light gray background */
        .stats-box {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-color) !important;
        }
        /* Stats card - individual stat boxes with white background */
        .stats-card {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }
        .stats-card h3 {
            color: inherit !important;
        }
        /* Dark mode overrides for stats cards - override inline white background */
        [data-theme="dark"] .stats-card {
            background-color: var(--bg-secondary) !important;
            background: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }
        [data-theme="dark"] .stats-card h3 {
            color: inherit !important;
        }
        [data-theme="dark"] .stats-card strong {
            color: var(--text-primary) !important;
        }
        .scrollable-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            padding: 0.5rem;
            background-color: var(--bg-secondary);
        }
        .degree-info {
            display: inline-block;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9em;
        }
        .optimal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 1rem;
        }
        .result-box {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            padding: 0.75rem;
            box-shadow: inset 0 0 0 rgba(0,0,0,0);
        }
        .result-label {
            font-weight: bold;
            color: var(--text-accent);
            margin-bottom: 0.5rem;
        }

        /* Theme-aware utility classes for dynamic content */
        .text-success { color: var(--text-success) !important; }
        .text-danger { color: var(--text-danger) !important; }
        .text-muted { color: var(--text-muted) !important; }
        .text-accent { color: var(--text-accent) !important; }
        .text-info { color: var(--text-info) !important; }
        .bg-info { background-color: var(--bg-info) !important; }
        .bg-secondary { background-color: var(--bg-secondary) !important; }
        .border-info { border-color: var(--border-info) !important; }
        .border-color { border-color: var(--border-color) !important; }

        /* Counters box styling */
        .counters-box {
            margin: 1rem 0;
            padding: 1rem;
            background-color: var(--bg-info);
            border: 1px solid var(--text-accent);
            border-radius: 0.25rem;
        }
        .counters-box h3 {
            margin-top: 0;
            color: var(--text-accent);
        }
        .counters-box .stat-value {
            color: var(--text-accent-hover);
            font-weight: bold;
        }
        .counters-box .info-footer {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-info);
            font-size: 0.9rem;
            color: var(--text-info);
        }

        /* Additional styles for dynamically generated content */
        code {
            background-color: var(--bg-tertiary);
            padding: 0.15rem 0.4rem;
            border-radius: 0.25rem;
            font-family: monospace;
            color: var(--text-primary);
        }

        /* Input fields in dark mode */
        input[type="text"], input[type="number"], select {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-input);
        }

        /* Warning/info boxes - override inline styles */
        [data-theme="dark"] div[style*="background-color: #fff3cd"],
        [data-theme="dark"] div[style*="background-color:#fff3cd"] {
            background-color: #3d3215 !important;
            color: var(--text-primary) !important;
        }
        [data-theme="dark"] div[style*="border-left: 4px solid #ffc107"],
        [data-theme="dark"] div[style*="border: 1px solid #ffc107"] {
            border-color: #ffc107 !important;
        }

        /* Details/summary styling */
        details summary {
            cursor: pointer;
            color: var(--text-accent);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           COMPREHENSIVE DARK MODE OVERRIDES FOR INLINE STYLES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* All tables inside output */
        [data-theme="dark"] #output table,
        [data-theme="dark"] .matrix table,
        [data-theme="dark"] .scrollable-list table {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        [data-theme="dark"] #output table th,
        [data-theme="dark"] #output table td,
        [data-theme="dark"] .matrix table th,
        [data-theme="dark"] .matrix table td {
            border-color: var(--border-color) !important;
            background-color: inherit;
        }
        [data-theme="dark"] #output table th,
        [data-theme="dark"] .matrix table th,
        [data-theme="dark"] tr[style*="background-color: #e9ecef"],
        [data-theme="dark"] th[style*="background-color"],
        [data-theme="dark"] thead tr {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }

        /* Override ALL inline background colors in dark mode */
        [data-theme="dark"] div[style*="background-color: #e7f3ff"],
        [data-theme="dark"] div[style*="background-color:#e7f3ff"],
        [data-theme="dark"] div[style*="background-color: #e2d9f3"],
        [data-theme="dark"] [style*="background-color: #e7f3ff"],
        [data-theme="dark"] [style*="background-color:#e7f3ff"] {
            background-color: var(--bg-info) !important;
        }

        [data-theme="dark"] div[style*="background-color: #fff"],
        [data-theme="dark"] div[style*="background-color:#fff"],
        [data-theme="dark"] div[style*="background-color: white"],
        [data-theme="dark"] div[style*="background-color:white"],
        [data-theme="dark"] [style*="background-color: #fff"],
        [data-theme="dark"] [style*="background-color: white"] {
            background-color: var(--bg-secondary) !important;
        }

        [data-theme="dark"] div[style*="background-color: #f8f9fa"],
        [data-theme="dark"] div[style*="background-color:#f8f9fa"],
        [data-theme="dark"] [style*="background-color: #f8f9fa"] {
            background-color: var(--bg-primary) !important;
        }

        [data-theme="dark"] div[style*="background-color: #e9ecef"],
        [data-theme="dark"] [style*="background-color: #e9ecef"],
        [data-theme="dark"] [style*="background-color:#e9ecef"] {
            background-color: var(--bg-tertiary) !important;
        }

        [data-theme="dark"] div[style*="background-color: #d1e7dd"],
        [data-theme="dark"] [style*="background-color: #d1e7dd"] {
            background-color: var(--bg-success) !important;
        }

        /* Override inline text colors */
        [data-theme="dark"] span[style*="color: #198754"],
        [data-theme="dark"] [style*="color: #198754"],
        [data-theme="dark"] [style*="color:#198754"] {
            color: var(--text-success) !important;
        }
        [data-theme="dark"] span[style*="color: #dc3545"],
        [data-theme="dark"] [style*="color: #dc3545"],
        [data-theme="dark"] [style*="color:#dc3545"] {
            color: var(--text-danger) !important;
        }
        [data-theme="dark"] span[style*="color: #6c757d"],
        [data-theme="dark"] span[style*="color: #666"],
        [data-theme="dark"] [style*="color: #6c757d"],
        [data-theme="dark"] [style*="color: #666"] {
            color: var(--text-muted) !important;
        }
        [data-theme="dark"] [style*="color: #0d6efd"],
        [data-theme="dark"] [style*="color:#0d6efd"],
        [data-theme="dark"] [style*="color: #0b5ed7"],
        [data-theme="dark"] [style*="color:#0b5ed7"],
        [data-theme="dark"] h3[style*="color:"],
        [data-theme="dark"] strong[style*="color: #0d6efd"],
        [data-theme="dark"] label[style*="color: #0d6efd"] {
            color: var(--text-accent) !important;
        }
        [data-theme="dark"] [style*="color: #084298"],
        [data-theme="dark"] [style*="color:#084298"] {
            color: var(--text-info) !important;
        }
        [data-theme="dark"] [style*="color: #856404"] {
            color: #ffc107 !important;
        }

        /* Section specific colors */
        [data-theme="dark"] h3[style*="color: #6f42c1"] { color: #b47cff !important; }
        [data-theme="dark"] h3[style*="color: #fd7e14"] { color: #fd9843 !important; }
        [data-theme="dark"] h3[style*="color: #f59f00"] { color: #ffc107 !important; }
        [data-theme="dark"] h3[style*="color: #20c997"] { color: #20c997 !important; }
        [data-theme="dark"] h3[style*="color: #0dcaf0"] { color: #0dcaf0 !important; }

        /* Override inline borders */
        [data-theme="dark"] [style*="border: 1px solid #dee2e6"],
        [data-theme="dark"] [style*="border:1px solid #dee2e6"],
        [data-theme="dark"] td[style*="border: 1px solid #dee2e6"],
        [data-theme="dark"] th[style*="border: 1px solid #dee2e6"] {
            border-color: var(--border-color) !important;
        }
        [data-theme="dark"] [style*="border: 1px solid #0d6efd"],
        [data-theme="dark"] [style*="border:1px solid #0d6efd"] {
            border-color: var(--text-accent) !important;
        }
        [data-theme="dark"] [style*="border: 1px solid #ced4da"],
        [data-theme="dark"] [style*="border:1px solid #ced4da"] {
            border-color: var(--border-input) !important;
        }
        [data-theme="dark"] [style*="border-top: 1px solid #b6d4fe"],
        [data-theme="dark"] [style*="border-top:1px solid #b6d4fe"] {
            border-color: var(--border-info) !important;
        }

        /* Query sections and result boxes */
        [data-theme="dark"] .query-section,
        [data-theme="dark"] .result-box,
        [data-theme="dark"] .scrollable-list {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
            color: var(--text-primary) !important;
        }

        /* Stats tables inside advanced-stats */
        [data-theme="dark"] .advanced-stats,
        [data-theme="dark"] .advanced-stats table,
        [data-theme="dark"] .advanced-stats div {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }
        [data-theme="dark"] .advanced-stats td,
        [data-theme="dark"] .advanced-stats th {
            border-color: var(--border-color) !important;
            background-color: transparent !important;
        }
        [data-theme="dark"] .advanced-stats thead tr,
        [data-theme="dark"] .advanced-stats tr:first-child {
            background-color: var(--bg-tertiary) !important;
        }

        /* Matrix containers */
        [data-theme="dark"] .matrix {
            background-color: var(--bg-secondary);
        }

        /* Section divs with inline styles */
        [data-theme="dark"] .section > div,
        [data-theme="dark"] #output > div {
            color: var(--text-primary);
        }

        /* Ensure all text inside output is readable */
        [data-theme="dark"] #output,
        [data-theme="dark"] #output * {
            color: inherit;
        }
        [data-theme="dark"] #output h2,
        [data-theme="dark"] #output h3 {
            color: var(--text-accent);
        }

        /* Checkboxes and labels */
        [data-theme="dark"] input[type="checkbox"] + label,
        [data-theme="dark"] .matrix-stats-toggle + label {
            color: var(--text-accent) !important;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ADDITIONAL OVERRIDES FOR PROBLEMATIC SECTIONS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* Force all sections in output to use theme colors */
        [data-theme="dark"] #output .section {
            background-color: transparent !important;
        }
        
        /* Optimal grid boxes */
        [data-theme="dark"] .optimal-grid > div {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }

        /* Info explanation boxes with light blue bg */
        [data-theme="dark"] div[style*="padding: 1rem"][style*="background-color"],
        [data-theme="dark"] div[style*="padding: 0.75rem"][style*="background-color"],
        [data-theme="dark"] div[style*="padding:1rem"][style*="background-color"],
        [data-theme="dark"] div[style*="padding:0.75rem"][style*="background-color"] {
            background-color: var(--bg-info) !important;
            border-color: var(--border-info) !important;
            color: var(--text-primary) !important;
        }

        /* Tables with explicit styling - target more specifically */
        [data-theme="dark"] table[style*="width: 100%"] th,
        [data-theme="dark"] table[style*="width:100%"] th {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }
        [data-theme="dark"] table[style*="width: 100%"] td,
        [data-theme="dark"] table[style*="width:100%"] td {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }

        /* Warning boxes with yellow background */
        [data-theme="dark"] div[style*="#fff3cd"],
        [data-theme="dark"] [style*="background-color: #fff3cd"],
        [data-theme="dark"] [style*="background-color:#fff3cd"] {
            background-color: var(--bg-warning) !important;
            color: var(--text-primary) !important;
        }

        /* Summary/details elements */
        [data-theme="dark"] details {
            background-color: var(--bg-secondary);
            border-color: var(--border-color);
        }

        /* All strong elements inside output */
        [data-theme="dark"] #output strong {
            color: var(--text-primary);
        }
        [data-theme="dark"] #output strong[style*="color"] {
            color: var(--text-accent) !important;
        }

        /* Force input backgrounds */
        [data-theme="dark"] input[style*="border"],
        [data-theme="dark"] input[style*="padding"] {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-input) !important;
        }

        /* Override row highlighting in tables */
        [data-theme="dark"] tr[style*="background-color: #fff3cd"],
        [data-theme="dark"] tr[style*="background-color:#fff3cd"] {
            background-color: var(--bg-warning) !important;
        }
        [data-theme="dark"] tr[style*="background-color: #e9ecef"],
        [data-theme="dark"] tr[style*="background-color:#e9ecef"] {
            background-color: var(--bg-tertiary) !important;
        }

        /* Code elements inside output */
        [data-theme="dark"] #output code,
        [data-theme="dark"] code[style*="background-color"] {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }

        /* Fix for inline padding divs that should be info boxes */
        [data-theme="dark"] div[style*="padding: 0.5rem"][style*="border-radius"],
        [data-theme="dark"] div[style*="padding:0.5rem"][style*="border-radius"] {
            background-color: var(--bg-info) !important;
            color: var(--text-primary) !important;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CRITICAL: Override WHITE backgrounds in boxes
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* Direct white background override */
        [data-theme="dark"] div[style*="background-color: white"],
        [data-theme="dark"] div[style*="background-color:white"],
        [data-theme="dark"] [style*="background-color: white"],
        [data-theme="dark"] [style*="background-color:white"],
        [data-theme="dark"] div[style*="background: white"],
        [data-theme="dark"] div[style*="background:white"] {
            background-color: var(--bg-secondary) !important;
            background: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }

        /* Light blue info boxes (#e7f3ff) */
        [data-theme="dark"] div[style*="#e7f3ff"],
        [data-theme="dark"] [style*="background-color: #e7f3ff"],
        [data-theme="dark"] [style*="background-color:#e7f3ff"],
        [data-theme="dark"] [style*="background: #e7f3ff"] {
            background-color: var(--bg-info) !important;
            background: var(--bg-info) !important;
            color: var(--text-primary) !important;
        }

        /* Light green (#d4edda) */
        [data-theme="dark"] div[style*="#d4edda"],
        [data-theme="dark"] [style*="background-color: #d4edda"],
        [data-theme="dark"] [style*="background-color:#d4edda"] {
            background-color: var(--bg-success) !important;
            color: var(--text-primary) !important;
        }

        /* Light gray backgrounds (#f8f9fa, #e9ecef) */
        [data-theme="dark"] div[style*="#f8f9fa"],
        [data-theme="dark"] [style*="background-color: #f8f9fa"],
        [data-theme="dark"] [style*="background-color:#f8f9fa"],
        [data-theme="dark"] div[style*="#e9ecef"],
        [data-theme="dark"] [style*="background-color: #e9ecef"],
        [data-theme="dark"] [style*="background-color:#e9ecef"] {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }

        /* Override text colors */
        [data-theme="dark"] [style*="color: #666"],
        [data-theme="dark"] [style*="color:#666"],
        [data-theme="dark"] span[style*="color: #666"],
        [data-theme="dark"] span[style*="color:#666"] {
            color: var(--text-secondary) !important;
        }

        [data-theme="dark"] h3[style*="color: #198754"],
        [data-theme="dark"] h3[style*="color:#198754"],
        [data-theme="dark"] [style*="color: #198754"] {
            color: var(--text-success) !important;
        }

        [data-theme="dark"] h3[style*="color: #dc3545"],
        [data-theme="dark"] h3[style*="color:#dc3545"],
        [data-theme="dark"] [style*="color: #dc3545"] {
            color: var(--text-danger) !important;
        }

        /* Border colors */
        [data-theme="dark"] [style*="border-left: 4px solid #198754"],
        [data-theme="dark"] [style*="border-left:4px solid #198754"] {
            border-left-color: var(--text-success) !important;
        }
        [data-theme="dark"] [style*="border-left: 4px solid #dc3545"],
        [data-theme="dark"] [style*="border-left:4px solid #dc3545"] {
            border-left-color: var(--text-danger) !important;
        }
        [data-theme="dark"] [style*="border-left: 4px solid #0d6efd"],
        [data-theme="dark"] [style*="border-left:4px solid #0d6efd"] {
            border-left-color: var(--text-accent) !important;
        }
        [data-theme="dark"] [style*="border-left: 4px solid #ffc107"],
        [data-theme="dark"] [style*="border-left:4px solid #ffc107"] {
            border-left-color: var(--text-warning) !important;
        }

        /* HR lines */
        [data-theme="dark"] hr[style*="border-top: 1px solid #dee2e6"],
        [data-theme="dark"] hr[style*="border-top:1px solid #dee2e6"],
        [data-theme="dark"] hr {
            border-color: var(--border-color) !important;
        }

        /* Input with white background */
        [data-theme="dark"] input[style*="width"],
        [data-theme="dark"] input[style*="padding"] {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-input) !important;
        }

        /* Table header backgrounds */
        [data-theme="dark"] th[style*="background-color"],
        [data-theme="dark"] th[style*="background"] {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
        }

        /* Table cell backgrounds */
        [data-theme="dark"] td[style*="background-color: white"],
        [data-theme="dark"] td[style*="background-color:white"],
        [data-theme="dark"] td[style*="background: white"] {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
        }

        /* Blue accent color text */
        [data-theme="dark"] [style*="color: #0d6efd"],
        [data-theme="dark"] [style*="color:#0d6efd"] {
            color: var(--text-accent) !important;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INPUT FIELDS - Comprehensive override
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        [data-theme="dark"] input,
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] input[type="number"],
        [data-theme="dark"] .query-inputs input,
        [data-theme="dark"] .query-section input {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-input) !important;
        }

        [data-theme="dark"] select,
        [data-theme="dark"] .query-inputs select,
        [data-theme="dark"] .query-section select {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-input) !important;
        }

        /* Buttons with specific colors */
        [data-theme="dark"] button[style*="background-color: #0d6efd"] {
            background-color: var(--text-accent) !important;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MORE SPECIFIC WHITE BACKGROUND OVERRIDES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* Any element with white background inside output */
        [data-theme="dark"] #output [style*="background-color: white"],
        [data-theme="dark"] #output [style*="background:white"],
        [data-theme="dark"] #output [style*="background-color:white"],
        [data-theme="dark"] #output [style*="background: white"] {
            background-color: var(--bg-secondary) !important;
            background: var(--bg-secondary) !important;
        }

        /* Common wrapper divs */
        [data-theme="dark"] #output > div > div[style*="background"],
        [data-theme="dark"] .section div[style*="background-color: white"],
        [data-theme="dark"] .section div[style*="background:white"] {
            background-color: var(--bg-secondary) !important;
            background: var(--bg-secondary) !important;
        }

        /* Ensure nested divs inside sections are themed */
        [data-theme="dark"] .section > div {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* Matrix table cells with monospace code */
        [data-theme="dark"] td[style*="font-family: monospace"] {
            color: var(--text-primary) !important;
        }

        /* Buttons in dark mode */
        [data-theme="dark"] button {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        [data-theme="dark"] button:hover {
            background-color: var(--bg-info);
        }

        /* Links in dark mode */
        [data-theme="dark"] a {
            color: var(--text-accent);
        }

        /* Pre and code blocks */
        [data-theme="dark"] pre,
        [data-theme="dark"] code {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* h4 headings with color */
        [data-theme="dark"] h4[style*="color"] {
            color: var(--text-accent) !important;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STATISTICS SECTION - Dynamic JS elements override
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* Statistics section */
        [data-theme="dark"] #statisticsSection,
        [data-theme="dark"] div#statisticsSection,
        [data-theme="dark"] [id="statisticsSection"] {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
            color: var(--text-primary) !important;
        }

        /* Stats grid container divs with white bg */
        [data-theme="dark"] #statisticsSection div[style*="background-color: white"],
        [data-theme="dark"] #statisticsSection div[style*="background:white"],
        [data-theme="dark"] #statisticsSection [style*="background-color: white"],
        [data-theme="dark"] #statisticsSection [style*="background: white"] {
            background-color: var(--bg-secondary) !important;
            background: var(--bg-secondary) !important;
        }

        /* All direct children divs inside statistics section that have inline bg */
        [data-theme="dark"] #statisticsSection div[style*="display: grid"] div[style*="background"],
        [data-theme="dark"] #statisticsSection [style*="display: grid"] > div {
            background-color: var(--bg-secondary) !important;
        }

        /* All table header rows */
        [data-theme="dark"] #output tr[style*="background-color: #e9ecef"],
        [data-theme="dark"] #output tr[style*="background-color:#e9ecef"],
        [data-theme="dark"] #output tr[style*="background: #e9ecef"],
        [data-theme="dark"] tr[style*="background-color: #e9ecef"],
        [data-theme="dark"] tr[style*="background:#e9ecef"],
        [data-theme="dark"] thead tr {
            background-color: var(--bg-tertiary) !important;
            background: var(--bg-tertiary) !important;
        }

        /* All table cells */
        [data-theme="dark"] #output th,
        [data-theme="dark"] #output td,
        [data-theme="dark"] #statisticsSection th,
        [data-theme="dark"] #statisticsSection td {
            border-color: var(--border-color) !important;
            color: var(--text-primary) !important;
        }

        /* Table cells and borders */
        [data-theme="dark"] th[style*="border: 1px solid #dee2e6"],
        [data-theme="dark"] td[style*="border: 1px solid #dee2e6"],
        [data-theme="dark"] th[style*="border:1px solid #dee2e6"],
        [data-theme="dark"] td[style*="border:1px solid #dee2e6"] {
            border-color: var(--border-color) !important;
        }

        /* Summary elements with cursor */
        [data-theme="dark"] summary[style*="color: #0d6efd"],
        [data-theme="dark"] summary[style*="color:#0d6efd"] {
            color: var(--text-accent) !important;
        }

        /* Details elements inside output */
        [data-theme="dark"] #output details,
        [data-theme="dark"] #statisticsSection details {
            background-color: var(--bg-secondary);
            border-color: var(--border-color);
        }

        /* Divs with border-top solid #dee2e6 */
        [data-theme="dark"] div[style*="border-top: 1px solid #dee2e6"],
        [data-theme="dark"] div[style*="border-top:1px solid #dee2e6"] {
            border-color: var(--border-color) !important;
        }

        /* Strong elements with color */
        [data-theme="dark"] strong[style*="color: #0d6efd"],
        [data-theme="dark"] strong[style*="color:#0d6efd"] {
            color: var(--text-accent) !important;
        }
        [data-theme="dark"] strong[style*="color: #198754"],
        [data-theme="dark"] strong[style*="color:#198754"] {
            color: var(--text-success) !important;
        }
        [data-theme="dark"] strong[style*="color: #dc3545"],
        [data-theme="dark"] strong[style*="color:#dc3545"] {
            color: var(--text-danger) !important;
        }

        /* h2 headings with color */
        [data-theme="dark"] h2[style*="color: #0d6efd"],
        [data-theme="dark"] h2[style*="color:#0d6efd"] {
            color: var(--text-accent) !important;
        }

        /* h3 headings with color */
        [data-theme="dark"] h3[style*="color: #0d6efd"],
        [data-theme="dark"] h3[style*="color:#0d6efd"] {
            color: var(--text-accent) !important;
        }

        /* Spans with color #666 */
        [data-theme="dark"] span[style*="color: #666"],
        [data-theme="dark"] span[style*="color:#666"] {
            color: var(--text-secondary) !important;
        }

        /* VÃ¡noÄnÃ­ svÄ›tÃ½lka - Christmas Lights */
        .christmas-lights {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            z-index: 1000;
            overflow: hidden;
            pointer-events: none;
        }

        .wire {
            position: absolute;
            top: 8px;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                #2a2a2a 0%, #3a3a3a 50%, #2a2a2a 100%);
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .lights-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 10px;
        }

        .light {
            position: relative;
            width: 12px;
            height: 20px;
            margin-top: 8px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            animation: swing 2s ease-in-out infinite;
        }

        .light::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 8px;
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            border-radius: 2px 2px 0 0;
        }

        .light::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 8px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            filter: blur(1px);
        }

        .light.red {
            background: radial-gradient(ellipse at 30% 20%, #ff6b6b, #e63946);
            box-shadow: 0 0 15px 5px rgba(230, 57, 70, 0.6),
                        0 0 30px 10px rgba(230, 57, 70, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite, glow-red 1.5s ease-in-out infinite alternate;
        }

        .light.green {
            background: radial-gradient(ellipse at 30% 20%, #51cf66, #2d9e42);
            box-shadow: 0 0 15px 5px rgba(45, 158, 66, 0.6),
                        0 0 30px 10px rgba(45, 158, 66, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.3s, glow-green 1.5s ease-in-out infinite alternate 0.5s;
        }

        .light.blue {
            background: radial-gradient(ellipse at 30% 20%, #74c0fc, #339af0);
            box-shadow: 0 0 15px 5px rgba(51, 154, 240, 0.6),
                        0 0 30px 10px rgba(51, 154, 240, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.6s, glow-blue 1.5s ease-in-out infinite alternate 1s;
        }

        .light.yellow {
            background: radial-gradient(ellipse at 30% 20%, #ffe066, #fab005);
            box-shadow: 0 0 15px 5px rgba(250, 176, 5, 0.6),
                        0 0 30px 10px rgba(250, 176, 5, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.9s, glow-yellow 1.5s ease-in-out infinite alternate 1.5s;
        }

        .light.purple {
            background: radial-gradient(ellipse at 30% 20%, #da77f2, #be4bdb);
            box-shadow: 0 0 15px 5px rgba(190, 75, 219, 0.6),
                        0 0 30px 10px rgba(190, 75, 219, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 1.2s, glow-purple 1.5s ease-in-out infinite alternate 2s;
        }

        .light.orange {
            background: radial-gradient(ellipse at 30% 20%, #ffa94d, #fd7e14);
            box-shadow: 0 0 15px 5px rgba(253, 126, 20, 0.6),
                        0 0 30px 10px rgba(253, 126, 20, 0.3),
                        inset 0 -5px 10px rgba(0,0,0,0.2);
            animation: swing 2s ease-in-out infinite 0.15s, glow-orange 1.5s ease-in-out infinite alternate 0.75s;
        }

        @keyframes swing {
            0%, 100% { transform: rotate(-3deg); }
            50% { transform: rotate(3deg); }
        }

        @keyframes glow-red {
            0% { box-shadow: 0 0 10px 3px rgba(230, 57, 70, 0.4), 0 0 20px 6px rgba(230, 57, 70, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(230, 57, 70, 0.8), 0 0 40px 15px rgba(230, 57, 70, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-green {
            0% { box-shadow: 0 0 10px 3px rgba(45, 158, 66, 0.4), 0 0 20px 6px rgba(45, 158, 66, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(45, 158, 66, 0.8), 0 0 40px 15px rgba(45, 158, 66, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-blue {
            0% { box-shadow: 0 0 10px 3px rgba(51, 154, 240, 0.4), 0 0 20px 6px rgba(51, 154, 240, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(51, 154, 240, 0.8), 0 0 40px 15px rgba(51, 154, 240, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-yellow {
            0% { box-shadow: 0 0 10px 3px rgba(250, 176, 5, 0.4), 0 0 20px 6px rgba(250, 176, 5, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(250, 176, 5, 0.8), 0 0 40px 15px rgba(250, 176, 5, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-purple {
            0% { box-shadow: 0 0 10px 3px rgba(190, 75, 219, 0.4), 0 0 20px 6px rgba(190, 75, 219, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(190, 75, 219, 0.8), 0 0 40px 15px rgba(190, 75, 219, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        @keyframes glow-orange {
            0% { box-shadow: 0 0 10px 3px rgba(253, 126, 20, 0.4), 0 0 20px 6px rgba(253, 126, 20, 0.2), inset 0 -5px 10px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 20px 8px rgba(253, 126, 20, 0.8), 0 0 40px 15px rgba(253, 126, 20, 0.4), inset 0 -5px 10px rgba(0,0,0,0.2); }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           INSTANT SEASON ENGINE - All decorations pre-rendered
           Switching = just body class change, 0ms, GPU only
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        
        /* All decorations hidden by default */
        .deco { 
            opacity: 0; 
            pointer-events: none;
            transition: opacity 200ms ease;
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 999;
        }
        
        /* Show decoration based on body class */
        body.season-christmas .deco-christmas,
        body.season-winter .deco-winter,
        body.season-spring .deco-spring,
        body.season-summer .deco-summer,
        body.season-autumn .deco-autumn,
        body.season-halloween .deco-halloween,
        body.season-valentine .deco-valentine { opacity: 1; }

        /* â„ï¸ WINTER - Snowflakes */
        .deco-winter { height: 100%; overflow: hidden; }
        .snowflake {
            position: absolute;
            color: #fff;
            text-shadow: 0 0 5px rgba(255,255,255,0.8);
            animation: snowfall linear infinite;
            will-change: transform;
        }
        @keyframes snowfall {
            0% { transform: translateY(-5vh) rotate(0deg); }
            100% { transform: translateY(105vh) rotate(360deg); }
        }

        /* ğŸŒ¸ SPRING - Sakura */
        .deco-spring { height: 100%; overflow: hidden; }
        .sakura {
            position: absolute;
            animation: sakura-fall linear infinite;
            will-change: transform;
        }
        @keyframes sakura-fall {
            0% { transform: translateY(-5vh) rotate(0deg) translateX(0); }
            50% { transform: translateY(50vh) rotate(180deg) translateX(30px); }
            100% { transform: translateY(105vh) rotate(360deg) translateX(-20px); }
        }

        /* â˜€ï¸ SUMMER - Bubbles */
        .deco-summer { height: 100%; overflow: hidden; }
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(135,206,250,0.3));
            box-shadow: inset 0 0 8px rgba(255,255,255,0.6);
            animation: bubble-rise linear infinite;
            will-change: transform;
        }
        @keyframes bubble-rise {
            0% { transform: translateY(105vh) scale(1); opacity: 0.8; }
            100% { transform: translateY(-10vh) scale(0.5); opacity: 0; }
        }

        /* ğŸ‚ AUTUMN - Leaves */
        .deco-autumn { height: 100%; overflow: hidden; }
        .leaf {
            position: absolute;
            animation: leaf-fall linear infinite;
            will-change: transform;
        }
        @keyframes leaf-fall {
            0% { transform: translateY(-5vh) rotate(0deg) translateX(0); }
            25% { transform: translateY(25vh) rotate(90deg) translateX(40px); }
            50% { transform: translateY(50vh) rotate(180deg) translateX(-20px); }
            75% { transform: translateY(75vh) rotate(270deg) translateX(30px); }
            100% { transform: translateY(105vh) rotate(360deg) translateX(0); }
        }

        /* ğŸƒ HALLOWEEN */
        .deco-halloween { height: 60px; overflow: visible; }
        .bat {
            position: absolute;
            animation: bat-fly 3s ease-in-out infinite;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            will-change: transform;
        }
        .pumpkin {
            position: absolute;
            animation: pumpkin-glow 2s ease-in-out infinite alternate;
            will-change: filter;
        }
        @keyframes bat-fly {
            0%, 100% { transform: translateY(0) scaleX(1); }
            25% { transform: translateY(-8px) scaleX(0.9); }
            50% { transform: translateY(4px) scaleX(1); }
            75% { transform: translateY(-4px) scaleX(0.95); }
        }
        @keyframes pumpkin-glow {
            0% { filter: drop-shadow(0 0 5px orange); }
            100% { filter: drop-shadow(0 0 15px orange) brightness(1.1); }
        }

        /* ğŸ’• VALENTINE */
        .deco-valentine { height: 100%; overflow: hidden; }
        .heart {
            position: absolute;
            animation: heart-fall linear infinite;
            will-change: transform;
        }
        @keyframes heart-fall {
            0% { transform: translateY(-5vh) scale(1) rotate(-10deg); }
            50% { transform: translateY(50vh) scale(1.15) rotate(10deg); }
            100% { transform: translateY(105vh) scale(0.9) rotate(-5deg); }
        }
    </style>
</head>
<body>
<!-- Theme Toggle Button -->
<button class="theme-toggle" onclick="toggleTheme()" title="PÅ™epnout svÄ›tlÃ½/tmavÃ½ reÅ¾im">
    <span class="icon" id="themeIcon">ğŸŒ™</span>
</button>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SEASONAL DECORATIONS - All pre-rendered, instant switching
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

<!-- ğŸ„ Christmas Lights -->
<div class="deco deco-christmas christmas-lights">
    <div class="wire"></div>
    <div class="lights-container" id="lightsContainer"></div>
</div>

<!-- â„ï¸ Winter Snowflakes -->
<div class="deco deco-winter" id="winterDeco"></div>

<!-- ğŸŒ¸ Spring Sakura -->
<div class="deco deco-spring" id="springDeco"></div>

<!-- â˜€ï¸ Summer Bubbles -->
<div class="deco deco-summer" id="summerDeco"></div>

<!-- ğŸ‚ Autumn Leaves -->
<div class="deco deco-autumn" id="autumnDeco"></div>

<!-- ğŸƒ Halloween -->
<div class="deco deco-halloween" id="halloweenDeco"></div>

<!-- ğŸ’• Valentine -->
<div class="deco deco-valentine" id="valentineDeco"></div>
<div id="matrix-stats-tooltip" style="position: absolute; display: none; background-color: var(--tooltip-bg); color: var(--tooltip-text); padding: 8px 12px; border-radius: 5px; pointer-events: none; z-index: 1000; font-size: 0.9em; line-height: 1.5;"></div>
<h1>Graph Analyzer</h1>
<p>Zadejte definici grafu ve formÃ¡tu uvedenÃ©m v zadÃ¡nÃ­. KaÅ¾dÃ½ uzel se definuje
pomocÃ­ Å™Ã¡dku zaÄÃ­najÃ­cÃ­ho <code>u</code> a kaÅ¾dÃ¡ hrana pomocÃ­ Å™Ã¡dku zaÄÃ­najÃ­cÃ­ho
<code>h</code>. Orientace hrany se urÄuje Å¡ipkami <code>&lt;</code>, <code>&gt;</code> nebo
pomlÄkou <code>-</code>. OhodnocenÃ­ je volitelnÃ©.</p>
<textarea id="graphInput">u A;
u B;
h A &gt; B 1 :h1;
u C;
h B &gt; C 1 :h2;
u D;
h A &gt; D 2 :h3;
u E;
h A &lt; E 2 :h4;
h B &lt; E 3 :h5;
h C &gt; E 3 :h6;
h D &gt; E 4 :h8;
u F;
h C &gt; F 4 :h7;
h E &gt; F 5 :h9;
u G;
h D &lt; G 5 :h10;
h E &gt; G 6 :h11;
u H;
h H &gt; E 6 :h12;
h F &gt; H 7 :h13;
h G &lt; H 7 :h14;</textarea>
<button id="parseBtn">Analyzovat graf</button>

<div id="counters" class="counters-box" style="display: none;">
    <h3>ğŸ“Š ZÃ¡kladnÃ­ statistiky</h3>
    <div style="display: flex; gap: 2rem; font-size: 1.1rem; flex-wrap: wrap;">
        <div><strong>PoÄet uzlÅ¯:</strong> <span id="nodeCount" class="stat-value">0</span></div>
        <div><strong>PoÄet hran:</strong> <span id="edgeCount" class="stat-value">0</span></div>
        <div><strong>PoÄet komponent:</strong> <span id="componentCount" class="stat-value">0</span></div>
    </div>
    <div class="info-footer">
        ğŸ’¡ <strong>Komponenta</strong> = oddÄ›lenÃ¡ ÄÃ¡st grafu (1 komponenta = graf je souvislÃ½)
    </div>
</div>

<div id="output"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// THEME TOGGLE - Light/Dark Mode
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initTheme() {
    const savedTheme = localStorage.getItem('graph-analyzer-theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (savedTheme) {
        setTheme(savedTheme);
    } else if (prefersDark) {
        setTheme('dark');
    } else {
        setTheme('light');
    }
    
    // Listen for system preference changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        if (!localStorage.getItem('graph-analyzer-theme')) {
            setTheme(e.matches ? 'dark' : 'light');
        }
    });
}

function setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    const icon = document.getElementById('themeIcon');
    if (icon) {
        icon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
    }
}

function toggleTheme() {
    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    localStorage.setItem('graph-analyzer-theme', newTheme);
    setTheme(newTheme);
}

// Graph analyzer with optimizations for large graphs
class Graph {
    constructor() {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        this._cachedProperties = null; // âš¡ CACHE pro properties()
    }

    parse(text) {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        this._cachedProperties = null; // Invalidate cache on change

        const lines = text.split(/[;\r\n]+/);
        const nodePattern = /^u\s+([^\s;]+)(?:\s+([-+]?[0-9]*\.?[0-9]+))?/;
        const edgePattern = /^h\s+([^\s<>-]+)\s*([<>-])\s*([^\s<>-]+)\s*(?:([-+]?[0-9]*\.?[0-9]+))?\s*(?::([^;]+))?/;

        // First pass: add all nodes
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            let m;
            if ((m = nodePattern.exec(trimmed))) {
                const id = m[1];
                if (id === '*') continue;
                if (!this.nodes.includes(id)) {
                    this.nodes.push(id);
                    const weight = m[2] !== undefined ? parseFloat(m[2]) : null;
                    this.nodeWeights[id] = weight;
                }
            }
        }

        // Second pass: add all edges
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            let m;
            if ((m = edgePattern.exec(trimmed))) {
                const u = m[1];
                const direction = m[2];
                const v = m[3];
                // Ensure nodes exist before adding an edge
                if (this.nodes.includes(u) && this.nodes.includes(v)) {
                    const weight = m[4] !== undefined ? parseFloat(m[4]) : 1; // Default weight to 1
                    const label = m[5] ? m[5].trim() : null;
                    this.edges.push({ u, v, direction, weight, label });
                }
            }
        }
    }

    adjacencyMatrix(binary = false) {
        if (!binary && this._cachedAdjMatrix) return this._cachedAdjMatrix;
        
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const mat = Array.from({ length: n }, () => Array(n).fill(0));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                mat[i][j] += 1;
            } else if (e.direction === '<') {
                mat[j][i] += 1;
            } else {
                mat[i][j] += 1;
                mat[j][i] += 1;
            }
        }
        
        if (binary) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    mat[i][j] = mat[i][j] > 0 ? 1 : 0;
                }
            }
        } else {
            this._cachedAdjMatrix = mat;
        }
        
        return mat;
    }

    // Optimized: query single cell instead of computing full matrix
    adjacencyValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) count++;
            else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) count++;
            else if (e.direction === '-' && 
                     ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) count++;
        }
        return count;
    }

    lengthMatrix() {
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const INF = Infinity;
        const mat = Array.from({ length: n }, (_, i) => 
            Array.from({ length: n }, (__, j) => i === j ? 0 : INF));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                if (w < mat[i][j]) mat[i][j] = w;
            } else if (e.direction === '<') {
                if (w < mat[j][i]) mat[j][i] = w;
            } else {
                if (w < mat[i][j]) mat[i][j] = w;
                if (w < mat[j][i]) mat[j][i] = w;
            }
        }
        return mat;
    }

    // Optimized: query single cell
    lengthValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        if (nodeU === nodeV) return 0;
        
        let minWeight = Infinity;
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '-' && 
                       ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) {
                minWeight = Math.min(minWeight, w);
            }
        }
        return minWeight;
    }

    signMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const S = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                S[i][j] = A[i][j] - A[j][i];
            }
        }
        return S;
    }

    signValue(nodeU, nodeV) {
        const adjUV = this.adjacencyValue(nodeU, nodeV);
        const adjVU = this.adjacencyValue(nodeV, nodeU);
        if (adjUV === null || adjVU === null) return null;
        return adjUV - adjVU;
    }

    static multiplyMatrices(X, Y) {
        const n = X.length;
        const result = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let k = 0; k < n; k++) {
                if (X[i][k] === 0) continue;
                for (let j = 0; j < n; j++) {
                    if (Y[k][j] === 0) continue;
                    result[i][j] += X[i][k] * Y[k][j];
                }
            }
        }
        return result;
    }

    adjacencyPower(k) {
        let A = this.adjacencyMatrix();
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result;
    }

    // Optimized: compute power for specific cell
    adjacencyPowerValue(nodeU, nodeV, k) {
        const A = this.adjacencyMatrix();
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result[uIdx][vIdx];
    }

    // Laplacian matrix L = D - A
    laplacianMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const L = Array.from({ length: n }, () => Array(n).fill(0));
        
        // âš¡ OPRAVA: Pro orientovanÃ© grafy pouÅ¾ij OUT-degree!
        const props = this.properties();
        const isDirected = props.oriented === 'orientovanÃ½';
        
        // Compute degree for each node
        for (let i = 0; i < n; i++) {
            let degree = 0;
            
            if (isDirected) {
                // âœ… OUT-degree pro orientovanÃ© (jen hrany ven)
                for (let j = 0; j < n; j++) {
                    degree += A[i][j]; // SouÄet Å™Ã¡dku = out-degree
                }
            } else {
                // âœ… CelkovÃ½ stupeÅˆ pro neorientovanÃ©
                for (let j = 0; j < n; j++) {
                    degree += A[i][j];
                }
            }
            
            L[i][i] = degree; // Diagonal: degree
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    L[i][j] = -A[i][j]; // Off-diagonal: -A[i][j]
                }
            }
        }
        return L;
    }

    // Get single value from Laplacian matrix
    laplacianValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        if (uIdx === vIdx) {
            // âš¡ OPRAVA: Diagonal = out-degree pro orientovanÃ© grafy
            const props = this.properties();
            const isDirected = props.oriented === 'orientovanÃ½';
            
            let degree = 0;
            for (const e of this.edges) {
                if (isDirected) {
                    // âœ… PoÄÃ­tej jen hrany VYCHÃZEJÃCÃ z nodeU
                    if (e.direction === '>' && e.u === nodeU) degree++;
                    else if (e.direction === '<' && e.v === nodeU) degree++;
                    // SmyÄka v orientovanÃ©m grafu
                    else if (e.direction === '-' && e.u === nodeU && e.v === nodeU) degree += 2;
                    else if (e.direction === '-' && (e.u === nodeU || e.v === nodeU)) degree++;
                } else {
                    // âœ… Pro neorientovanÃ© poÄÃ­tej vÅ¡echny dotÃ½kajÃ­cÃ­ se hrany
                    if (e.u === nodeU || e.v === nodeU) {
                        if (e.u === e.v) degree += 2; // Loop counts twice
                        else degree += 1;
                    }
                }
            }
            return degree;
        } else {
            // Off-diagonal: -A[i][j]
            return -this.adjacencyValue(nodeU, nodeV);
        }
    }

    // Sum of all walks from length 1 to k
    sumWalksValue(nodeU, nodeV, k) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        const A = this.adjacencyMatrix();
        let sum = 0;
        let currentPower = A;
        
        for (let i = 1; i <= k; i++) {
            sum += currentPower[uIdx][vIdx];
            if (i < k) {
                currentPower = Graph.multiplyMatrices(currentPower, A);
            }
        }
        return sum;
    }

    // Multiplicity: count all edges between U and V (regardless of direction for undirected)
    multiplicityValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            // Count all edges connecting these two nodes
            if ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU)) {
                count++;
            }
        }
        return count;
    }

    // Reachability matrix (transitive closure)
    reachability() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const R = A.map(row => row.map(v => v > 0 ? 1 : 0));
        
        // Floyd-Warshall on binary matrix
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                if (R[i][k] === 1) {
                    for (let j = 0; j < n; j++) {
                        if (R[k][j] === 1) R[i][j] = 1;
                    }
                }
            }
        }
        return R;
    }

    // BFS Layers from start node
    bfsLayers(startNode) {
        const idx = this.nodes.indexOf(startNode);
        if (idx === -1) return {};
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const layers = { 0: [startNode] };
        const seen = new Set([idx]);
        let frontier = [idx];
        let k = 0;
        
        while (frontier.length) {
            const next = [];
            for (const u of frontier) {
                for (const v of adjList[u]) {
                    if (!seen.has(v)) {
                        seen.add(v);
                        next.push(v);
                    }
                }
            }
            if (!next.length) break;
            k++;
            layers[k] = next.map(i => this.nodes[i]).sort();
            frontier = next;
        }
        return layers;
    }

    // All shortest paths (unweighted BFS)
    allShortestPathsUnweighted(src, dst) {
        const srcIdx = this.nodes.indexOf(src);
        const dstIdx = this.nodes.indexOf(dst);
        if (srcIdx === -1 || dstIdx === -1) return [];
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list (outgoing edges)
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const dist = Array(n).fill(Infinity);
        dist[srcIdx] = 0;
        const parents = Array.from({ length: n }, () => []);
        const queue = [srcIdx];
        
        while (queue.length) {
            const u = queue.shift();
            for (const v of adjList[u]) {
                if (dist[v] === Infinity) {
                    dist[v] = dist[u] + 1;
                    parents[v].push(u);
                    queue.push(v);
                } else if (dist[v] === dist[u] + 1) {
                    parents[v].push(u);
                }
            }
        }
        
        if (dist[dstIdx] === Infinity) return [];
        
        // Reconstruct all paths
        const paths = [];
        const stack = [dstIdx];
        
        const reconstruct = (v) => {
            if (v === srcIdx) {
                paths.push(stack.slice().reverse().map(i => this.nodes[i]));
                return;
            }
            for (const p of parents[v]) {
                stack.push(p);
                reconstruct(p);
                stack.pop();
            }
        };
        
        reconstruct(dstIdx);
        return paths;
    }

    // Simple paths up to length K (no repeated nodes)
    simplePathsUpTo(srcNode, dstNode, K = null, cap = 10000) {
        const srcIdx = this.nodes.indexOf(srcNode);
        const dstIdx = this.nodes.indexOf(dstNode);
        if (srcIdx === -1 || dstIdx === -1) return { count: 0, paths: [] };
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const maxLen = (K === null) ? (n - 1) : K;
        const paths = [];
        let count = 0;
        const visited = new Set();
        
        const dfs = (u, depth, acc) => {
            if (count >= cap) return;
            if (u === dstIdx) {
                paths.push(acc.map(i => this.nodes[i]));
                count++;
                return;
            }
            if (depth === 0) return;
            
            for (const w of adjList[u]) {
                if (visited.has(w)) continue;
                visited.add(w);
                acc.push(w);
                dfs(w, depth - 1, acc);
                acc.pop();
                visited.delete(w);
            }
        };
        
        visited.add(srcIdx);
        dfs(srcIdx, maxLen, [srcIdx]);
        visited.delete(srcIdx);
        
        return { count, paths };
    }

    // Neighbor sets by direction
    neighborSets(nodeU) {
        const out = new Set();
        const inn = new Set();
        const und = new Set();
        
        for (const e of this.edges) {
            if (e.direction === '>') {
                if (e.u === nodeU) out.add(e.v);
                if (e.v === nodeU) inn.add(e.u);
            } else if (e.direction === '<') {
                if (e.v === nodeU) out.add(e.u);
                if (e.u === nodeU) inn.add(e.v);
            } else {
                if (e.u === nodeU) und.add(e.v);
                if (e.v === nodeU) und.add(e.u);
            }
        }
        
        return {
            out: [...out].sort(),
            inn: [...inn].sort(),
            und: [...und].sort()
        };
    }

    incidenceMatrix(signed = true) {
        const n = this.nodes.length;
        const m = this.edges.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const inc = Array.from({ length: n }, () => Array(m).fill(0));
        
        this.edges.forEach((e, ci) => {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                if (signed) {
                    inc[i][ci] = -1;
                    inc[j][ci] = 1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else if (e.direction === '<') {
                if (signed) {
                    inc[j][ci] = 1;
                    inc[i][ci] = -1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else {
                inc[i][ci] = 1;
                inc[j][ci] = 1;
            }
        });
        return inc;
    }

    floydWarshall() {
        const n = this.nodes.length;
        const dist = this.lengthMatrix().map(row => row.slice());
        const pred = Array.from({ length: n }, () => Array(n).fill(null));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    pred[i][j] = i;
                }
            }
        }
        
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const alt = dist[i][k] + dist[k][j];
                    if (alt < dist[i][j]) {
                        dist[i][j] = alt;
                        pred[i][j] = pred[k][j];
                    }
                }
            }
        }
        return { dist, pred };
    }

    // Optimized: compute shortest path for specific pair
    shortestPath(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        // Dijkstra nepracuje se zÃ¡pornÃ½mi hranami
        const stats = this.edgeWeightStats();
        if (stats && stats.min < 0) {
            return { error: 'Graf obsahuje zÃ¡pornÃ© hrany â€“ DijkstrÅ¯v algoritmus nelze pouÅ¾Ã­t. PouÅ¾ijte Bellman-Ford.' };
        }
        
        // Simple Dijkstra for single source-target
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const visited = Array(n).fill(false);
        const pred = Array(n).fill(null);
        dist[uIdx] = 0;
        
        for (let count = 0; count < n; count++) {
            let minDist = Infinity;
            let u = -1;
            for (let i = 0; i < n; i++) {
                if (!visited[i] && dist[i] < minDist) {
                    minDist = dist[i];
                    u = i;
                }
            }
            if (u === -1 || u === vIdx) break;
            visited[u] = true;
            
            for (const e of this.edges) {
                const w = e.weight !== null ? e.weight : 1;
                let vNeighbor = -1;
                if (e.direction === '>' && e.u === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.v);
                } else if (e.direction === '<' && e.v === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.u);
                } else if (e.direction === '-') {
                    if (e.u === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.v);
                    else if (e.v === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.u);
                }
                
                if (vNeighbor !== -1 && !visited[vNeighbor]) {
                    const alt = dist[u] + w;
                    if (alt < dist[vNeighbor]) {
                        dist[vNeighbor] = alt;
                        pred[vNeighbor] = u;
                    }
                }
            }
        }
        
        // Reconstruct path
        const path = [];
        if (dist[vIdx] < Infinity) {
            let current = vIdx;
            while (current !== null) {
                path.unshift(this.nodes[current]);
                current = pred[current];
            }
        }
        
        return {
            distance: dist[vIdx],
            predecessor: pred[vIdx] !== null ? this.nodes[pred[vIdx]] : null,
            path: path
        };
    }

    incidentEdges() {
        const map = {};
        this.nodes.forEach(id => { map[id] = []; });
        this.edges.forEach(e => {
            const desc = e.label ? e.label : `${e.u}${e.direction}${e.v}`;
            map[e.u].push(desc);
            map[e.v].push(desc);
        });
        return map;
    }

    neighbours() {
        const map = {};
        this.nodes.forEach(id => { map[id] = new Set(); });
        this.edges.forEach(e => {
            map[e.u].add(e.v);
            map[e.v].add(e.u);
        });
        const result = {};
        for (const id of this.nodes) {
            result[id] = Array.from(map[id]);
        }
        return result;
    }

    // Compute and cache degrees
    degrees() {
        if (this._cachedDegrees) return this._cachedDegrees;
        
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            if (e.u === e.v) {
                degrees[e.u] += 2;
            } else {
                degrees[e.u] += 1;
                degrees[e.v] += 1;
            }
        }
        this._cachedDegrees = degrees;
        return degrees;
    }

    // Check if directed graph is strongly connected using Kosaraju's algorithm
    // âš¡ VYLEPÅ ENÃ 12: OptimalizovanÃ¡ strongly connected detection
    isStronglyConnected() {
        const n = this.nodes.length;
        if (n === 0) return true;
        if (n === 1) return true; // âš¡ Single node is trivially strongly connected
        
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        
        // âš¡ Build adjacency list AND reverse graph v jednom prÅ¯chodu!
        const adjList = Array.from({ length: n }, () => []);
        const reverseAdj = Array.from({ length: n }, () => []);
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                adjList[i].push(j);
                reverseAdj[j].push(i); // âš¡ Build reverse souÄasnÄ›
            } else if (e.direction === '<') {
                adjList[j].push(i);
                reverseAdj[i].push(j);
            } else {
                // Undirected edge - add both directions
                adjList[i].push(j);
                adjList[j].push(i);
                reverseAdj[i].push(j);
                reverseAdj[j].push(i);
            }
        }
        
        // DFS from first node - inline pro rychlost
        const visited = new Array(n).fill(false);
        const stack = [0];
        visited[0] = true;
        let count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of adjList[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        if (count !== n) return false; // âš¡ Early exit
        
        // DFS on reverse graph - jiÅ¾ mÃ¡me reverseAdj!
        visited.fill(false);
        stack.length = 0; // âš¡ Reuse array
        stack.push(0);
        visited[0] = true;
        count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of reverseAdj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        return count === n;
    }

    // âš¡ VYLEPÅ ENÃ 14: PoÄÃ­tÃ¡nÃ­ komponent grafu (slabÃ© komponenty)
    countComponents() {
        const n = this.nodes.length;
        if (n === 0) return 0;
        
        const visited = new Set();
        let components = 0;
        
        // Build adjacency list (ignoruj orientaci hran)
        const adj = {};
        this.nodes.forEach(id => adj[id] = new Set());
        for (const e of this.edges) {
            adj[e.u].add(e.v);
            adj[e.v].add(e.u); // ObousmÄ›rnÄ› pro slabÃ© komponenty
        }
        
        // BFS pro kaÅ¾dou komponentu
        for (const start of this.nodes) {
            if (visited.has(start)) continue;
            
            components++;
            const queue = [start];
            visited.add(start);
            
            while (queue.length) {
                const u = queue.shift();
                for (const v of adj[u]) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                    }
                }
            }
        }
        
        return components;
    }
    
    // VracÃ­ detailnÃ­ informace o komponentÃ¡ch (reprezentant + seznam uzlÅ¯)
    getComponents() {
        const n = this.nodes.length;
        if (n === 0) return [];
        
        const visited = new Set();
        const components = [];
        
        // Build adjacency list (ignoruj orientaci hran)
        const adj = {};
        this.nodes.forEach(id => adj[id] = new Set());
        for (const e of this.edges) {
            adj[e.u].add(e.v);
            adj[e.v].add(e.u); // ObousmÄ›rnÄ› pro slabÃ© komponenty
        }
        
        // BFS pro kaÅ¾dou komponentu
        for (const start of this.nodes) {
            if (visited.has(start)) continue;
            
            const componentNodes = [];
            const queue = [start];
            visited.add(start);
            componentNodes.push(start);
            
            while (queue.length) {
                const u = queue.shift();
                for (const v of adj[u]) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                        componentNodes.push(v);
                    }
                }
            }
            
            components.push({
                root: start,  // PrvnÃ­ nalezenÃ½ uzel (reprezentant)
                nodes: componentNodes.sort(),
                size: componentNodes.length
            });
        }
        
        return components.sort((a, b) => b.size - a.size); // SeÅ™aÄ podle velikosti
    }

    // Find all multiple edges in the graph
    findMultipleEdges() {
        const edgeMap = new Map();
        const multipleEdges = [];
        
        for (const e of this.edges) {
            // Create key based on nodes and direction
            let key;
            if (e.direction === '>') {
                key = `${e.u}>${e.v}`;
            } else if (e.direction === '<') {
                key = `${e.v}>${e.u}`;
            } else {
                // For undirected edges, normalize the key
                key = e.u <= e.v ? `${e.u}-${e.v}` : `${e.v}-${e.u}`;
            }
            
            if (!edgeMap.has(key)) {
                edgeMap.set(key, []);
            }
            edgeMap.get(key).push(e);
        }
        
        // Find groups with multiple edges
        for (const [key, edges] of edgeMap.entries()) {
            if (edges.length > 1) {
                multipleEdges.push({
                    key: key,
                    count: edges.length,
                    edges: edges
                });
            }
        }
        
        return multipleEdges;
    }

    
    properties() {
        // âš¡ VYLEPÅ ENÃ 10: Memoizace properties() - obrovskÃ½ speedup!
        if (this._cachedProperties) return this._cachedProperties;
        
        const props = {};
        const n = this.nodes.length;
        
        // Weighted: any edge weight specified and different from 1, or any node has weight
        let weightedEdge = false;
        for (const e of this.edges) {
            if (e.weight !== null && e.weight !== undefined && e.weight !== 1) {
                weightedEdge = true;
                break;
            }
        }
        let weightedNode = false;
        for (const id of this.nodes) {
            const w = this.nodeWeights[id];
            if (w !== null && w !== undefined) {
                weightedNode = true;
                break;
            }
        }
        props.weighted = weightedEdge || weightedNode;
        
        // Orientation: determine if graph is directed, undirected or mixed
        let hasDirected = false;
        let hasUndirected = false;
        for (const e of this.edges) {
            if (e.direction === '-' || e.direction === 'â€“') hasUndirected = true;
            else hasDirected = true;
        }
        if (hasDirected && !hasUndirected) props.oriented = 'orientovanÃ½';
        else if (!hasDirected && hasUndirected) props.oriented = 'neorientovanÃ½';
        else props.oriented = 'smÃ­Å¡enÃ½';
        
        // Connectivity: BFS on underlying undirected graph
        const visited = new Array(n).fill(false);
        if (n > 0) {
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            const neighbours = this.neighbours();
            const queue = [0];
            visited[0] = true;
            while (queue.length > 0) {
                const i = queue.shift();
                const u = this.nodes[i];
                for (const v of neighbours[u]) {
                    const j = idx[v];
                    if (!visited[j]) {
                        visited[j] = true;
                        queue.push(j);
                    }
                }
            }
        }
        props.connected = visited.every(v => v);
        
        // âš¡ OPRAVA: Strong a weak connectivity pro orientovanÃ© grafy
        // Pokud je silnÄ› souvislÃ½ â†’ automaticky slabÄ› souvislÃ½ (zobrazÃ­me jen "silnÄ›")
        // Pokud nenÃ­ silnÄ›, ale je weakly â†’ zobrazÃ­me "slabÄ›"
        if (props.oriented === 'orientovanÃ½') {
            props.stronglyConnected = this.isStronglyConnected();
            // Weakly connected = connected v podkladovÃ©m neorientovanÃ©m grafu
            // ALE zobrazÃ­me jen pokud nenÃ­ strongly connected
            props.weaklyConnected = !props.stronglyConnected && props.connected;
        }
        
        // Finite: always true for parsed input
        props.finite = true;
        
        // âš¡ VYLEPÅ ENÃ 11: Loops + multiple edges + degrees v JEDNOM prÅ¯chodu
        let loops = 0;
        const edgeSet = new Set();
        let multiEdges = false;
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            // PoÄÃ­tej stupnÄ› souÄasnÄ›
            if (e.u === e.v) {
                loops++;
                degrees[e.u] += 2; // SmyÄka pÅ™idÃ¡ stupeÅˆ 2
                continue;
            }
            
            degrees[e.u] += 1;
            degrees[e.v] += 1;
            
            // Check multiple edges
            const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
            if (edgeSet.has(key)) {
                multiEdges = true;
                // NekonÄÃ­me - musÃ­me dopoÄÃ­tat degrees!
            } else {
                edgeSet.add(key);
            }
        }
        
        props.prosty = !multiEdges;
        props.jednoduchy = !multiEdges && loops === 0;
        
        // âš¡ NOVÃ‰: Multigraf (existujÃ­ nÃ¡sobnÃ© hrany)
        props.multigraph = multiEdges;
        
        // âš¡ NOVÃ‰: DiskrÃ©tnÃ­ graf (Å¾Ã¡dnÃ© hrany)
        props.discrete = this.edges.length === 0;
        
        // âš¡ VYLEPÅ ENÃ 13: Complete graph - vyuÅ¾ij uÅ¾ existujÃ­cÃ­ edgeSet!
        if (n > 50) {
            props.complete = false;
        } else {
            // edgeSet uÅ¾ mÃ¡me z vÃ½poÄtu multiple edges vÃ½Å¡e!
            const expectedEdges = (n * (n - 1)) / 2;
            props.complete = (edgeSet.size === expectedEdges) && !multiEdges && loops === 0;
        }
        
        // âš¡ Regular: degrees uÅ¾ mÃ¡me spoÄÃ­tanÃ© vÃ½Å¡e!
        const degValues = Object.values(degrees);
        const firstDeg = degValues[0];
        props.regular = degValues.every(d => d === firstDeg);
        
        // Bipartite: OPTIMIZED - early exit on odd cycle
        props.bipartite = (() => {
            if (n === 0) return true;
            const colours = new Array(n).fill(-1);
            const neighbours = this.neighbours();
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            
            for (let start = 0; start < n; start++) {
                if (colours[start] !== -1) continue;
                const queue = [start];
                colours[start] = 0;
                
                while (queue.length > 0) {
                    const uIdx = queue.shift();
                    const u = this.nodes[uIdx];
                    const currentColour = colours[uIdx];
                    
                    for (const v of neighbours[u]) {
                        const vIdx = idx[v];
                        if (colours[vIdx] === -1) {
                            colours[vIdx] = 1 - currentColour;
                            queue.push(vIdx);
                        } else if (colours[vIdx] === currentColour) {
                            return false;
                        }
                    }
                }
            }
            return true;
        })();
        
        // Planar: OPTIMIZED for ALL graph sizes using fast heuristics
        props.planar = (() => {
            // Count unique undirected edges efficiently
            const uniqueEdges = new Set();
            for (const e of this.edges) {
                const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
                uniqueEdges.add(key);
            }
            const m = uniqueEdges.size;
            
            // Trivial cases
            if (n <= 4) return true;
            if (m === 0) return true;
            if (m <= 1) return true; // âš¡ Single edge is always planar
            
            // âš¡ VYLEPÅ ENÃ 1: PÅ™esnÄ›jÅ¡Ã­ Eulerova formule pro nesouvislÃ© grafy
            // Pro nesouvislÃ½ graf: m â‰¤ 3n - 6k, kde k = poÄet komponent
            if (props.prosty) {
                // PoÄet komponent pomocÃ­ BFS
                const visited = new Set();
                let components = 0;
                const adj = {};
                this.nodes.forEach(id => adj[id] = new Set());
                for (const e of this.edges) {
                    adj[e.u].add(e.v);
                    adj[e.v].add(e.u);
                }
                
                for (const start of this.nodes) {
                    if (visited.has(start)) continue;
                    components++;
                    const queue = [start];
                    visited.add(start);
                    while (queue.length) {
                        const u = queue.shift();
                        for (const v of adj[u]) {
                            if (!visited.has(v)) {
                                visited.add(v);
                                queue.push(v);
                            }
                        }
                    }
                }
                
                // Eulerova formule: m â‰¤ 3n - 6k (pro k komponent)
                if (m > 3 * n - 6 * components) {
                    return false;
                }
            }
            
            // âš¡ VYLEPÅ ENÃ 2: ZpÅ™esnÄ›nÃ­ pro bipartitnÃ­ grafy
            if (props.bipartite) {
                // Pro bipartitnÃ­ graf: m â‰¤ 2n - 4 (pokud souvislÃ½)
                // Pro nesouvislÃ½: pouÅ¾ij podobnou formuli jako vÃ½Å¡e
                if (props.connected && m > 2 * n - 4) {
                    return false;
                }
            }
            
            // âš¡ VYLEPÅ ENÃ 3: Kontrola prÅ¯mÄ›rnÃ©ho stupnÄ› (zpÅ™esnÄ›nÃ­)
            const avgDegree = (2 * m) / n;
            if (avgDegree > 6) { // ZmÄ›na z >= na > (6.0 je jeÅ¡tÄ› moÅ¾nÃ©)
                return false;
            }
            
            // âš¡ VYLEPÅ ENÃ 4: Kontrola maximÃ¡lnÃ­ho stupnÄ›
            // RovinnÃ½ graf nemÅ¯Å¾e mÃ­t uzel se stupnÄ›m > 5 u malÃ½ch grafÅ¯
            const maxDegree = Math.max(...Object.values(degrees));
            if (n <= 10 && maxDegree > n - 1) {
                // Pokud mÃ¡ uzel stupeÅˆ n-1, je to hvÄ›zda â†’ rovinnÃ©
                // Jinak pokraÄuj v kontrolÃ¡ch
            }
            
            // âš¡ VYLEPÅ ENÃ 5: SpeciÃ¡lnÃ­ pÅ™Ã­pady - stromy a lesy
            if (m === n - 1 && props.connected) {
                return true; // Strom je vÅ¾dy rovinnÃ½!
            }
            if (m < n) {
                return true; // Les (m < n) je vÅ¾dy rovinnÃ½!
            }
            
            // âš¡ VYLEPÅ ENÃ 6: OptimalizovanÃ¡ detekce K5 s lepÅ¡Ã­m targeting
            if (n >= 5 && m >= 10) {
                // K5 potÅ™ebuje 10 hran mezi 5 uzly
                // Nejprve najdi uzly s vysokÃ½m stupnÄ›m (â‰¥4)
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 4) { // K5 mÃ¡ vÅ¡echny uzly se stupnÄ›m 4
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                // Zkontroluj jen high-degree uzly (vÃ½raznÄ› rychlejÅ¡Ã­!)
                if (highDegreeNodes.length >= 5) {
                    const maxSamples = Math.min(50, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        // Random sampling z high-degree uzlÅ¯
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 5);
                        
                        let isK5 = true;
                        let edgeCount = 0;
                        
                        // Check if these 5 nodes form K5
                        for (let i = 0; i < 5 && isK5; i++) {
                            for (let j = i + 1; j < 5; j++) {
                                const u = candidateNodes[i];
                                const v = candidateNodes[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgeCount++;
                                } else {
                                    isK5 = false;
                                    break;
                                }
                            }
                        }
                        
                        // K5 mÃ¡ pÅ™esnÄ› 10 hran
                        if (isK5 && edgeCount === 10) return false;
                    }
                }
            }
            
            // âš¡ VYLEPÅ ENÃ 7: OptimalizovanÃ¡ detekce K3,3 s bipartitnÃ­ analÃ½zou
            if (n >= 6 && m >= 9) {
                // K3,3 potÅ™ebuje 9 hran a je bipartitnÃ­
                // Pokud graf nenÃ­ bipartitnÃ­, zkontroluj subgrafy
                
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 3) { // K3,3 mÃ¡ vÅ¡echny uzly se stupnÄ›m pÅ™esnÄ› 3
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                if (highDegreeNodes.length >= 6) {
                    const maxSamples = Math.min(30, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 6);
                        
                        // âš¡ Optimalizace: Zkus jen logickÃ© partitiony
                        // NamÃ­sto vÅ¡ech 2^6 = 64 kombinacÃ­, zkus jen validnÃ­
                        const partitions = [
                            [[0,1,2], [3,4,5]],
                            [[0,1,3], [2,4,5]],
                            [[0,1,4], [2,3,5]],
                            [[0,1,5], [2,3,4]],
                            [[0,2,3], [1,4,5]],
                            [[0,2,4], [1,3,5]],
                            [[0,2,5], [1,3,4]],
                            [[0,3,4], [1,2,5]],
                            [[0,3,5], [1,2,4]],
                            [[0,4,5], [1,2,3]]
                        ];
                        
                        for (const [setAIdx, setBIdx] of partitions) {
                            const setA = setAIdx.map(i => candidateNodes[i]);
                            const setB = setBIdx.map(i => candidateNodes[i]);
                            
                            // Check if complete bipartite
                            let isK33 = true;
                            let edgeCount = 0;
                            
                            // Kontroluj jen hrany mezi mnoÅ¾inami (ne uvnitÅ™!)
                            for (const ua of setA) {
                                for (const vb of setB) {
                                    const key = ua <= vb ? `${ua}|${vb}` : `${vb}|${ua}`;
                                    if (uniqueEdges.has(key)) {
                                        edgeCount++;
                                    } else {
                                        isK33 = false;
                                        break;
                                    }
                                }
                                if (!isK33) break;
                            }
                            
                            // K3,3 mÃ¡ pÅ™esnÄ› 9 hran a Å¾Ã¡dnÃ© hrany uvnitÅ™ mnoÅ¾in
                            if (isK33 && edgeCount === 9) {
                                // OvÄ›Å™, Å¾e nejsou hrany uvnitÅ™ setA a setB
                                let hasInternalEdge = false;
                                for (let i = 0; i < 3; i++) {
                                    for (let j = i + 1; j < 3; j++) {
                                        const keyA = setA[i] <= setA[j] ? `${setA[i]}|${setA[j]}` : `${setA[j]}|${setA[i]}`;
                                        const keyB = setB[i] <= setB[j] ? `${setB[i]}|${setB[j]}` : `${setB[j]}|${setB[i]}`;
                                        if (uniqueEdges.has(keyA) || uniqueEdges.has(keyB)) {
                                            hasInternalEdge = true;
                                            break;
                                        }
                                    }
                                    if (hasInternalEdge) break;
                                }
                                
                                if (!hasInternalEdge) return false; // K3,3 found!
                            }
                        }
                    }
                }
            }
            
            // âš¡ VYLEPÅ ENÃ 8: Kontrola hustoty subgrafÅ¯
            // RovinnÃ½ graf nemÅ¯Å¾e obsahovat "lokÃ¡lnÄ› hustÃ½" subgraf
            if (n >= 10 && m >= 20) {
                // Vyber nÃ¡hodnÃ© uzly a kontroluj jejich okolÃ­
                const samples = Math.min(10, n);
                for (let s = 0; s < samples; s++) {
                    const centerIdx = Math.floor(Math.random() * n);
                    const center = this.nodes[centerIdx];
                    
                    // Najdi sousedy centra
                    const neighbors = new Set();
                    for (const e of this.edges) {
                        if (e.u === center) neighbors.add(e.v);
                        if (e.v === center) neighbors.add(e.u);
                    }
                    
                    if (neighbors.size >= 6) {
                        // SpoÄÃ­tej hrany mezi sousedy
                        const neighborsList = Array.from(neighbors);
                        let edgesInNeighborhood = 0;
                        for (let i = 0; i < neighborsList.length; i++) {
                            for (let j = i + 1; j < neighborsList.length; j++) {
                                const u = neighborsList[i];
                                const v = neighborsList[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgesInNeighborhood++;
                                }
                            }
                        }
                        
                        // Pokud mÃ¡ okolÃ­ pÅ™Ã­liÅ¡ mnoho hran, nenÃ­ rovinnÃ½
                        const k = neighbors.size;
                        const maxEdgesInNeighborhood = 3 * k - 6;
                        if (edgesInNeighborhood > maxEdgesInNeighborhood) {
                            return false;
                        }
                    }
                }
            }
            
            // âš¡ VYLEPÅ ENÃ 9: ZpÅ™esnÄ›nÃ­ odpovÄ›di podle jistoty
            if (n > 100) {
                // Pro velmi velkÃ© grafy pouÅ¾ij disclaimer
                return 'pravdÄ›podobnÄ› ano (heuristika)';
            } else if (n > 50 && (m > 2.5 * n)) {
                // Pro stÅ™ednÄ› velkÃ© hustÅ¡Ã­ grafy buÄ opatrnÄ›jÅ¡Ã­
                return 'pravdÄ›podobnÄ› ano (heuristika)';
            } else if (m <= n + 3) {
                // Å˜Ã­dkÃ© grafy (m â‰¤ n+3) jsou tÃ©mÄ›Å™ jistÄ› rovinnÃ©
                return true;
            }
            
            return true;
        })();
        
        // âš¡ NOVÃ‰: Symetrizace (vÅ¡echny orientovanÃ© hrany majÃ­ i opaÄnou hranu)
        props.symmetric = (() => {
            if (!props.oriented) return true; // NeorientovanÃ½ graf je vÅ¾dy symetrickÃ½
            
            // Pro orientovanÃ© grafy: kontrola, Å¾e kaÅ¾dÃ¡ hrana mÃ¡ protÄ›jÅ¡ek
            for (const e of this.edges) {
                if (e.direction === '-') continue; // NeorientovanÃ© hrany ignoruj
                
                // Hledej opaÄnou hranu
                const oppositeExists = this.edges.some(e2 => 
                    e2.u === e.v && e2.v === e.u && (e2.direction === '<' || e2.direction === '>' || e2.direction === '-')
                );
                
                if (!oppositeExists) {
                    return false; // NaÅ¡li jsme hranu bez protÄ›jÅ¡ku
                }
            }
            return true;
        })();
        
        // âš¡ Cachuj vÃ½sledek pro budoucÃ­ volÃ¡nÃ­
        this._cachedProperties = props;
        return props;
    }

    // ğŸ“Š KompletnÃ­ statistickÃ½ pÅ™ehled grafu
    getStatistics() {
        const stats = {};
        const n = this.nodes.length;
        const m = this.edges.length;
        
        // ZÃ¡kladnÃ­ poÄty
        stats.nodeCount = n;
        stats.edgeCount = m;
        stats.componentCount = this.countComponents();
        
        // StupnÄ› uzlÅ¯
        const degrees = this.degrees();
        const degreeValues = Object.values(degrees);
        stats.degrees = {
            min: Math.min(...degreeValues),
            max: Math.max(...degreeValues),
            avg: degreeValues.reduce((a, b) => a + b, 0) / n,
            median: this._median(degreeValues),
            distribution: this._degreeDistribution(degreeValues)
        };
        
        // âš¡ NOVÃ‰: Pro orientovanÃ© grafy pÅ™idej IN/OUT stupnÄ›
        const props = this.properties();
        if (props.oriented === 'orientovanÃ½') {
            const inDegrees = {};
            const outDegrees = {};
            this.nodes.forEach(id => { inDegrees[id] = 0; outDegrees[id] = 0; });
            
            for (const e of this.edges) {
                if (e.direction === '>') {
                    outDegrees[e.u]++;
                    inDegrees[e.v]++;
                } else if (e.direction === '<') {
                    inDegrees[e.u]++;
                    outDegrees[e.v]++;
                }
            }
            
            const inValues = Object.values(inDegrees);
            const outValues = Object.values(outDegrees);
            
            stats.inDegrees = {
                min: Math.min(...inValues),
                max: Math.max(...inValues),
                avg: inValues.reduce((a, b) => a + b, 0) / n
            };
            
            stats.outDegrees = {
                min: Math.min(...outValues),
                max: Math.max(...outValues),
                avg: outValues.reduce((a, b) => a + b, 0) / n
            };
        }
        
        // IzolovanÃ© uzly (stupeÅˆ 0)
        stats.isolatedNodes = this.nodes.filter(id => degrees[id] === 0);

        // Rozklad hran podle typu (orientovanÃ© / neorientovanÃ© / smyÄky)
        const edgeBreakdown = this.edges.reduce((acc, edge) => {
            const isLoop = edge.u === edge.v;
            if (isLoop) {
                acc.loops++;
            } else if (edge.direction === '-') {
                acc.undirected++;
            } else {
                acc.directed++;
            }
            return acc;
        }, { directed: 0, undirected: 0, loops: 0 });

        // SmyÄky (self-loops)
        stats.loops = edgeBreakdown.loops;
        
        // NÃ¡sobnÃ© hrany
        const multipleEdges = this.findMultipleEdges();
        stats.multipleEdgeGroups = multipleEdges.length;
        stats.totalMultipleEdges = multipleEdges.reduce((sum, g) => sum + g.count, 0);
        
        // Hustota grafu (0 = Å™Ã­dkÃ½, 1 = ÃºplnÃ½) s ohledem na orientovanÃ©/mixovanÃ© hrany a smyÄky
        const pairCount = n > 1 ? n * (n - 1) : 0;
        let maxDirectedCapacity = 0;
        let maxUndirectedCapacity = 0;

        // Pokud graf obsahuje nebo umoÅ¾Åˆuje orientovanÃ© hrany, uvaÅ¾uj n*(n-1) moÅ¾nostÃ­
        if ((props.oriented === 'orientovanÃ½' || props.oriented === 'smÃ­Å¡enÃ½') && pairCount > 0) {
            maxDirectedCapacity = pairCount;
        } else if (edgeBreakdown.directed > 0 && pairCount > 0) {
            maxDirectedCapacity = pairCount;
        }

        // Pokud graf obsahuje nebo umoÅ¾Åˆuje neorientovanÃ© hrany, uvaÅ¾uj n*(n-1)/2 moÅ¾nostÃ­
        if ((props.oriented === 'neorientovanÃ½' || props.oriented === 'smÃ­Å¡enÃ½') && pairCount > 0) {
            maxUndirectedCapacity = pairCount / 2;
        } else if (edgeBreakdown.undirected > 0 && pairCount > 0) {
            maxUndirectedCapacity = pairCount / 2;
        }

        // SmyÄky â€“ maximÃ¡lnÄ› jedna smyÄka na uzel pro normalizaci
        const maxLoopCapacity = edgeBreakdown.loops > 0 ? n : 0;

        const densityDenominator = maxDirectedCapacity + maxUndirectedCapacity + maxLoopCapacity;
        stats.density = densityDenominator > 0 ? Math.min(1, m / densityDenominator) : 0;
        stats.densityModel = {
            directedSlots: maxDirectedCapacity,
            undirectedSlots: maxUndirectedCapacity,
            loopSlots: maxLoopCapacity,
            usedDirected: edgeBreakdown.directed,
            usedUndirected: edgeBreakdown.undirected,
            usedLoops: edgeBreakdown.loops
        };
        
        // PrÅ¯mÄ›r a polomÄ›r grafu (pokud je souvislÃ½ a ne moc velkÃ½)
        if (n > 0 && n <= 100 && this.properties().connected) {
            const diameterInfo = this._computeDiameterAndRadius();
            stats.diameter = diameterInfo.diameter;
            stats.radius = diameterInfo.radius;
            stats.centerNodes = diameterInfo.centerNodes;
            stats.peripheralNodes = diameterInfo.peripheralNodes;
        } else {
            stats.diameter = null;
            stats.radius = null;
        }
        
        // Komponenty
        const components = this.getComponents();
        if (components.length > 0) {
            stats.largestComponent = Math.max(...components.map(c => c.size));
            stats.smallestComponent = Math.min(...components.map(c => c.size));
            stats.componentSizes = components.map(c => c.size).sort((a, b) => b - a);
        }
        
        // Orientace hran
        let directedCount = 0;
        let undirectedCount = 0;
        for (const e of this.edges) {
            if (e.direction === '-') undirectedCount++;
            else directedCount++;
        }
        stats.directedEdges = directedCount;
        stats.undirectedEdges = undirectedCount;
        
        // OhodnocenÃ­
        stats.weightedEdges = this.edges.filter(e => e.weight !== null && e.weight !== undefined).length;
        stats.weightedNodes = this.nodes.filter(id => this.nodeWeights[id] !== null && this.nodeWeights[id] !== undefined).length;

        // Edge weight stats
        if (stats.weightedEdges > 0) {
            const weights = this.edges.map(e => e.weight).filter(w => w !== null && w !== undefined);
            stats.edgeWeights = {
                min: Math.min(...weights),
                max: Math.max(...weights),
                avg: weights.reduce((a, b) => a + b, 0) / weights.length,
                distribution: weights.reduce((acc, val) => {
                    acc[val] = (acc[val] || 0) + 1;
                    return acc;
                }, {})
            };
        }

        // âš¡ NOVÃ‰: Statistiky nejdelÅ¡Ã­ch a nejkratÅ¡Ã­ch hran
        if (this.edges.length > 0) {
            let shortestEdge = null;
            let longestEdge = null;
            let minWeight = Infinity;
            let maxWeight = -Infinity;

            for (const edge of this.edges) {
                const weight = edge.weight !== null && edge.weight !== undefined ? edge.weight : 1;
                if (weight < minWeight) {
                    minWeight = weight;
                    shortestEdge = edge;
                }
                if (weight > maxWeight) {
                    maxWeight = weight;
                    longestEdge = edge;
                }
            }
            stats.shortestEdge = shortestEdge;
            stats.longestEdge = longestEdge;
        }
        
        return stats;
    }

    _median(arr) {
        if (arr.length === 0) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    _degreeDistribution(degreeValues) {
        const dist = {};
        for (const deg of degreeValues) {
            dist[deg] = (dist[deg] || 0) + 1;
        }
        return dist;
    }

    _computeDiameterAndRadius() {
        const n = this.nodes.length;
        const fw = this.floydWarshall();
        const dist = fw.dist;
        
        // Excentricita kaÅ¾dÃ©ho uzlu = max vzdÃ¡lenost k ostatnÃ­m
        const eccentricities = [];
        for (let i = 0; i < n; i++) {
            let maxDist = 0;
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    maxDist = Math.max(maxDist, dist[i][j]);
                }
            }
            eccentricities.push(maxDist);
        }
        
        const diameter = Math.max(...eccentricities); // max excentricita
        const radius = Math.min(...eccentricities);   // min excentricita
        
        // CentrÃ¡lnÃ­ uzly (excentricita = polomÄ›r)
        const centerNodes = [];
        const peripheralNodes = [];
        for (let i = 0; i < n; i++) {
            if (eccentricities[i] === radius) centerNodes.push(this.nodes[i]);
            if (eccentricities[i] === diameter) peripheralNodes.push(this.nodes[i]);
        }
        
        return { diameter, radius, centerNodes, peripheralNodes };
    }

    countSpanningTrees() {
        const n = this.nodes.length;
        if (n === 0) return 0;
        if (n === 1) return 1;

        // Pokud graf nenÃ­ souvislÃ½, neexistuje Å¾Ã¡dnÃ¡ spanning tree
        if (this.countComponents() !== 1) {
            return 0;
        }

        const L = this.laplacianMatrix();
        const cofactor = [];
        for (let i = 1; i < n; i++) {
            const row = [];
            for (let j = 1; j < n; j++) {
                row.push(L[i][j]);
            }
            cofactor.push(row);
        }

        const det = this._determinantGaussian(cofactor);
        if (!Number.isFinite(det)) {
            return det;
        }
        return Math.max(0, Math.round(det));
    }

    // PoÄet spanning forests (souÄin poÄtu koster vÅ¡ech komponent)
    countSpanningForests() {
        const components = this.getComponents();
        if (components.length === 0) return { total: 0, perComponent: [], componentCount: 0 };
        if (components.length === 1) {
            const count = this.countSpanningTrees();
            return { total: count, perComponent: [{ nodes: components[0].nodes, count }], componentCount: 1 };
        }

        // Pro kaÅ¾dou komponentu vytvoÅ™Ã­me subgraf a spoÄÃ­tÃ¡me kostry
        const perComponent = [];
        let totalProduct = 1;
        let overflow = false;

        for (const comp of components) {
            if (comp.nodes.length === 1) {
                // IzolovanÃ½ uzel mÃ¡ 1 kostru (prÃ¡zdnou)
                perComponent.push({ nodes: comp.nodes, count: 1 });
                continue;
            }

            // VytvoÅ™ subgraf pro tuto komponentu
            const subGraph = new Graph();
            subGraph.nodes = [...comp.nodes];
            subGraph.nodeIndex = {};
            comp.nodes.forEach((node, idx) => subGraph.nodeIndex[node] = idx);
            
            // PÅ™idej hrany, kterÃ© jsou uvnitÅ™ tÃ©to komponenty
            const nodeSet = new Set(comp.nodes);
            subGraph.edges = this.edges.filter(e => nodeSet.has(e.u) && nodeSet.has(e.v));

            const count = subGraph.countSpanningTrees();
            perComponent.push({ nodes: comp.nodes, count });

            if (!Number.isFinite(count)) {
                overflow = true;
            } else {
                totalProduct *= count;
                if (!Number.isFinite(totalProduct)) {
                    overflow = true;
                }
            }
        }

        return {
            total: overflow ? Infinity : totalProduct,
            perComponent,
            componentCount: components.length
        };
    }

    _determinantGaussian(matrix) {
        const n = matrix.length;
        if (n === 0) return 1;
        const mat = matrix.map(row => row.map(value => {
            const num = typeof value === 'number' ? value : Number(value);
            return Number.isFinite(num) ? num : 0;
        }));
        const EPS = 1e-9;
        let swapCount = 0;
        for (let i = 0; i < n; i++) {
            let pivot = i;
            for (let j = i + 1; j < n; j++) {
                if (Math.abs(mat[j][i]) > Math.abs(mat[pivot][i])) {
                    pivot = j;
                }
            }
            if (Math.abs(mat[pivot][i]) < EPS) {
                return 0;
            }
            if (pivot !== i) {
                [mat[i], mat[pivot]] = [mat[pivot], mat[i]];
                swapCount++;
            }
            for (let j = i + 1; j < n; j++) {
                const factor = mat[j][i] / mat[i][i];
                if (Math.abs(factor) < EPS) continue;
                for (let k = i; k < n; k++) {
                    mat[j][k] -= factor * mat[i][k];
                }
            }
        }
        let det = swapCount % 2 === 0 ? 1 : -1;
        for (let i = 0; i < n; i++) {
            det *= mat[i][i];
        }
        return det;
    }

    _spanningForest(order = 'asc') {
        const n = this.nodes.length;
        if (n === 0) {
            return { tree: [], totalWeight: 0, componentTrees: [], componentCount: 0 };
        }

        const parent = {};
        const rank = {};
        this.nodes.forEach(node => {
            parent[node] = node;
            rank[node] = 0;
        });

        const find = (node) => {
            if (parent[node] !== node) {
                parent[node] = find(parent[node]);
            }
            return parent[node];
        };

        const union = (a, b) => {
            const rootA = find(a);
            const rootB = find(b);
            if (rootA === rootB) return false;
            if (rank[rootA] < rank[rootB]) {
                parent[rootA] = rootB;
            } else if (rank[rootA] > rank[rootB]) {
                parent[rootB] = rootA;
            } else {
                parent[rootB] = rootA;
                rank[rootA]++;
            }
            return true;
        };

        const edges = this.edges
            .filter(e => e.u !== e.v)
            .map((edge, index) => {
                const weight = (edge.weight !== null && edge.weight !== undefined && !Number.isNaN(edge.weight)) ? edge.weight : 1;
                return {
                    index,
                    u: edge.u,
                    v: edge.v,
                    weight,
                    ref: edge,
                };
            });

        edges.sort((a, b) => order === 'asc' ? a.weight - b.weight : b.weight - a.weight);

        const selectedEdges = [];
        let totalWeight = 0;
        for (const edge of edges) {
            if (union(edge.u, edge.v)) {
                selectedEdges.push(edge);
                totalWeight += edge.weight;
            }
        }

        const components = {};
        this.nodes.forEach(node => {
            const root = find(node);
            if (!components[root]) {
                components[root] = { nodes: [], edges: [], totalWeight: 0 };
            }
            components[root].nodes.push(node);
        });

        selectedEdges.forEach(edge => {
            const root = find(edge.u);
            components[root].edges.push(edge.ref);
            components[root].totalWeight += edge.weight;
        });

        const componentTrees = Object.values(components).map(component => ({
            nodes: [...component.nodes],
            edges: [...component.edges],
            totalWeight: component.totalWeight,
        })).sort((a, b) => b.nodes.length - a.nodes.length);

        return {
            tree: selectedEdges.map(edge => edge.ref),
            totalWeight,
            componentTrees,
            componentCount: componentTrees.length,
        };
    }

    minimumSpanningTree() {
        return this._spanningForest('asc');
    }

    maximumSpanningTree() {
        return this._spanningForest('desc');
    }

    edgeWeightStats() {
        if (this.edges.length === 0) return null;
        let min = Infinity;
        let max = -Infinity;
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (w < min) min = w;
            if (w > max) max = w;
        }
        return { min, max };
    }

    edgeWeightsBetween(nodeU, nodeV) {
        const weights = [];
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                if (e.u === nodeU && e.v === nodeV) weights.push(w);
            } else if (e.direction === '<') {
                if (e.v === nodeU && e.u === nodeV) weights.push(w);
            } else if ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU)) {
                weights.push(w);
            }
        }
        return weights;
    }

    pathWeightFromNodes(nodePath, strategy = 'min') {
        if (!nodePath || nodePath.length < 2) return 0;
        let total = 0;
        for (let i = 0; i < nodePath.length - 1; i++) {
            const weights = this.edgeWeightsBetween(nodePath[i], nodePath[i + 1]);
            if (!weights.length) return null;
            const value = strategy === 'max' ? Math.max(...weights) : Math.min(...weights);
            total += value;
        }
        return total;
    }

    _buildDirectedGraph(includeUndirected = true) {
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const edges = [];
        const addEdge = (from, to, weight, rawEdge, rawIndex) => {
            if (!(from in idx) || !(to in idx)) return;
            edges.push({
                from: idx[from],
                to: idx[to],
                weight,
                fromId: from,
                toId: to,
                label: rawEdge && rawEdge.label ? rawEdge.label : `${from}â†’${to}`,
                rawIndex,
            });
        };
        for (let rawIndex = 0; rawIndex < this.edges.length; rawIndex++) {
            const e = this.edges[rawIndex];
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                addEdge(e.u, e.v, w, e, rawIndex);
            } else if (e.direction === '<') {
                addEdge(e.v, e.u, w, e, rawIndex);
            } else if (includeUndirected) {
                addEdge(e.u, e.v, w, e, rawIndex);
                addEdge(e.v, e.u, w, e, rawIndex);
            }
        }
        const adj = Array.from({ length: this.nodes.length }, () => []);
        edges.forEach((edge, idxEdge) => {
            adj[edge.from].push({ to: edge.to, weight: edge.weight, edgeIndex: idxEdge });
        });
        return { idx, edges, adj };
    }

    topologicalSort(includeUndirected = true, graphData = null) {
        const data = graphData || this._buildDirectedGraph(includeUndirected);
        const n = this.nodes.length;
        const indegree = Array(n).fill(0);
        for (const edge of data.edges) {
            indegree[edge.to]++;
        }
        const queue = [];
        for (let i = 0; i < n; i++) {
            if (indegree[i] === 0) queue.push(i);
        }
        const order = [];
        while (queue.length) {
            const u = queue.shift();
            order.push(u);
            for (const edge of data.adj[u]) {
                indegree[edge.to]--;
                if (indegree[edge.to] === 0) queue.push(edge.to);
            }
        }
        return { order, isDAG: order.length === n, data };
    }

    _reconstructPath(startIdx, endIdx, predecessors) {
        if (startIdx === undefined || startIdx === null || endIdx === undefined || endIdx === null) return [];
        
        const path = [];
        let current = endIdx;
        const visited = new Set(); // Ochrana proti zacyklenÃ­
        
        // Pojistka: MaximÃ¡lnÄ› tolik krokÅ¯, kolik je uzlÅ¯ (cesta nemÅ¯Å¾e bÃ½t delÅ¡Ã­)
        let safeCounter = 0;
        const maxSteps = this.nodes.length + 1; 

        while (current !== null && current !== undefined && current !== -1) {
            // Pokud jsme narazili na cyklus nebo pÅ™ekroÄili limit
            if (visited.has(current) || safeCounter > maxSteps) {
                return []; // VracÃ­me prÃ¡zdnou cestu, protoÅ¾e cesta je nekoneÄnÃ¡/cyklickÃ¡
            }
            visited.add(current);
            safeCounter++;

            path.unshift(this.nodes[current]);
            
            if (current === startIdx) break;
            current = predecessors[current];
        }
        
        if (!path.length || path[0] !== this.nodes[startIdx]) return [];
        return path;
    }

    mooreShortestPath(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const pred = Array(n).fill(null);
        const queue = [];
        dist[startIdx] = 0;
        queue.push(startIdx);
        while (queue.length) {
            const u = queue.shift();
            if (u === endIdx) break;
            for (const edge of graphData.adj[u]) {
                if (dist[edge.to] === Infinity) {
                    dist[edge.to] = dist[u] + 1;
                    pred[edge.to] = u;
                    queue.push(edge.to);
                }
            }
        }
        if (dist[endIdx] === Infinity) {
            return { distance: Infinity, path: [] };
        }
        return { distance: dist[endIdx], path: this._reconstructPath(startIdx, endIdx, pred) };
    }

    bellmanFordAll(startNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const pred = Array(n).fill(null);
        dist[startIdx] = 0;
        for (let i = 0; i < n - 1; i++) {
            let updated = false;
            for (const edge of graphData.edges) {
                if (dist[edge.from] === Infinity) continue;
                const candidate = dist[edge.from] + edge.weight;
                if (candidate < dist[edge.to]) {
                    dist[edge.to] = candidate;
                    pred[edge.to] = edge.from;
                    updated = true;
                }
            }
            if (!updated) break;
        }
        let negativeCycle = false;
        for (const edge of graphData.edges) {
            if (dist[edge.from] !== Infinity && dist[edge.from] + edge.weight < dist[edge.to]) {
                negativeCycle = true;
                break;
            }
        }
        return { dist, pred, negativeCycle, startIdx };
    }

    bellmanFordPath(startNode, endNode) {
        const result = this.bellmanFordAll(startNode);
        if (!result) return null;
        const endIdx = this.nodes.indexOf(endNode);
        if (endIdx === -1) return null;
        const path = this._reconstructPath(result.startIdx, endIdx, result.pred);
        return { distance: result.dist[endIdx], path, negativeCycle: result.negativeCycle };
    }

    widestPath(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        
        // âš¡ Kontrola zÃ¡pornÃ½ch kapacit - nejÅ¡irÅ¡Ã­ cesta vyÅ¾aduje nezÃ¡pornÃ© kapacity
        let hasNegativeCapacity = false;
        for (const edge of graphData.edges) {
            if (edge.weight < 0) {
                hasNegativeCapacity = true;
                break;
            }
        }
        if (hasNegativeCapacity) {
            return { path: [], width: null, error: 'Graf obsahuje zÃ¡pornÃ© kapacity â€“ nejÅ¡irÅ¡Ã­ cesta nenÃ­ definovÃ¡na.' };
        }
        
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        if (startIdx === endIdx) return { path: [startNode], width: Infinity, segments: [], bottleneck: null, widestSegment: null };
        const n = this.nodes.length;
        const width = Array(n).fill(0);
        const visited = Array(n).fill(false);
        const pred = Array(n).fill(null);
        const predEdge = Array(n).fill(null); // UloÅ¾Ã­me si hranu, kterÃ¡ vedla do uzlu
        width[startIdx] = Infinity;
        
        for (let count = 0; count < n; count++) {
            let u = -1;
            let best = 0;
            for (let i = 0; i < n; i++) {
                if (!visited[i] && width[i] > best) {
                    best = width[i];
                    u = i;
                }
            }
            if (u === -1) break;
            visited[u] = true;
            if (u === endIdx) break;
            for (const edge of graphData.adj[u]) {
                const candidate = Math.min(width[u], edge.weight);
                if (candidate > width[edge.to]) {
                    width[edge.to] = candidate;
                    pred[edge.to] = u;
                    predEdge[edge.to] = edge; // UloÅ¾Ã­me hranu
                }
            }
        }
        
        if (width[endIdx] === 0) return { path: [], width: 0, segments: [], bottleneck: null, widestSegment: null };
        
        // Rekonstrukce cesty a sbÄ›r segmentÅ¯
        const path = this._reconstructPath(startIdx, endIdx, pred);
        const segments = [];
        
        // Projdi cestu a sbÃ­rej informace o segmentech
        let current = endIdx;
        while (pred[current] !== null) {
            const prevIdx = pred[current];
            const edge = predEdge[current];
            if (edge) {
                segments.unshift({
                    from: this.nodes[prevIdx],
                    to: this.nodes[current],
                    capacity: edge.weight
                });
            }
            current = prevIdx;
        }
        
        // Najdi bottleneck (nejmenÅ¡Ã­ kapacita) a nejÅ¡irÅ¡Ã­ segment
        let bottleneck = null;
        let widestSegment = null;
        
        if (segments.length > 0) {
            let minCapacity = Infinity;
            let maxCapacity = -Infinity;
            
            for (const seg of segments) {
                if (seg.capacity < minCapacity) {
                    minCapacity = seg.capacity;
                    bottleneck = seg;
                }
                if (seg.capacity > maxCapacity) {
                    maxCapacity = seg.capacity;
                    widestSegment = seg;
                }
            }
        }
        
        return { 
            path, 
            width: width[endIdx], 
            segments,
            bottleneck,      // Ãšsek s nejmenÅ¡Ã­ kapacitou (nejvÄ›tÅ¡Ã­ bottleneck)
            widestSegment    // Ãšsek s nejvÄ›tÅ¡Ã­ kapacitou
        };
    }

    // âš¡ Spolehlivost hrany podle standardnÃ­ho vzorce: r = exp(-w)
    // Pro w > 0: r âˆˆ (0, 1) - ÄÃ­m vyÅ¡Å¡Ã­ vÃ¡ha, tÃ­m niÅ¾Å¡Ã­ spolehlivost
    // Pro w = 0: r = 1 (maximÃ¡lnÃ­ spolehlivost)
    // Pro w < 0: r > 1 (nenÃ­ standardnÃ­ interpretace, ale matematicky platnÃ©)
    _edgeReliability(weight) {
        return Math.exp(-weight);
    }

    safestPath(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        if (startIdx === endIdx) return { path: [startNode], reliability: 1 };

        // 1. ZMÄšNA: OkamÅ¾itÃ¡ kontrola zÃ¡pornÃ½ch vah
        // Pokud najdeme zÃ¡pornou vÃ¡hu, pro vÃ½poÄet pravdÄ›podobnosti to nedÃ¡vÃ¡ smysl.
        for (const edge of graphData.edges) {
            if (edge.weight < 0) {
                return { 
                    path: [], 
                    reliability: null, 
                    error: 'Graf obsahuje zÃ¡pornÃ© hrany. Pro vÃ½poÄet spolehlivosti (pravdÄ›podobnosti) musÃ­ bÃ½t vÃ¡hy nezÃ¡pornÃ© (0 = 100%, >0 = <100%).' 
                };
            }
        }

        // 2. Pokud jsme tady, vÅ¡echny vÃ¡hy jsou >= 0. MÅ¯Å¾eme bezpeÄnÄ› pouÅ¾Ã­t Dijkstru.
        // Dijkstra je mnohem rychlejÅ¡Ã­ neÅ¾ Bellman-Ford a "nezdechne".
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const pred = Array(n).fill(null);
        dist[startIdx] = 0;
        
        const visited = Array(n).fill(false);
        for (let iter = 0; iter < n; iter++) {
            let u = -1;
            let best = Infinity;
            // Najdi nejbliÅ¾Å¡Ã­ nenavÅ¡tÃ­venÃ½ uzel
            for (let i = 0; i < n; i++) {
                if (!visited[i] && dist[i] < best) {
                    best = dist[i];
                    u = i;
                }
            }
            
            if (u === -1 || dist[u] === Infinity) break;
            visited[u] = true;
            if (u === endIdx) break;

            for (const edge of graphData.adj[u]) {
                const candidate = dist[u] + edge.weight;
                if (candidate < dist[edge.to]) {
                    dist[edge.to] = candidate;
                    pred[edge.to] = u;
                }
            }
        }

        if (dist[endIdx] === Infinity) return { path: [], reliability: 0 };

        return {
            path: this._reconstructPath(startIdx, endIdx, pred),
            reliability: Math.exp(-dist[endIdx]), // e^(-vzdÃ¡lenost)
            totalWeight: dist[endIdx]
        };
    }

    longestPathInfo(startNode, endNode) {
        const graphData = this._buildDirectedGraph(true);
        if (!(startNode in graphData.idx) || !(endNode in graphData.idx)) return null;
        const startIdx = graphData.idx[startNode];
        const endIdx = graphData.idx[endNode];
        const topo = this.topologicalSort(true, graphData);
        
        // Graf obsahuje cyklus - nejdelÅ¡Ã­ cesta nenÃ­ definovÃ¡na (mÅ¯Å¾e bÃ½t nekoneÄnÃ¡)
        if (!topo.isDAG) {
            return { 
                path: [], 
                weight: null, 
                mode: 'cyclic',
                error: 'Graf obsahuje cyklus â€“ nejdelÅ¡Ã­ cesta nenÃ­ definovÃ¡na (mÅ¯Å¾e bÃ½t nekoneÄnÄ› dlouhÃ¡).'
            };
        }
        
        if (topo.isDAG) {
            const dist = Array(this.nodes.length).fill(-Infinity);
            const pred = Array(this.nodes.length).fill(null);
            dist[startIdx] = 0;
            for (const u of topo.order) {
                if (dist[u] === -Infinity) continue;
                for (const edge of graphData.adj[u]) {
                    const candidate = dist[u] + edge.weight;
                    if (candidate > dist[edge.to]) {
                        dist[edge.to] = candidate;
                        pred[edge.to] = u;
                    }
                }
            }
            if (dist[endIdx] === -Infinity) {
                return { path: [], weight: null, mode: 'dag' };
            }
            return {
                path: this._reconstructPath(startIdx, endIdx, pred),
                weight: dist[endIdx],
                mode: 'dag'
            };
        }
        // Tento kÃ³d by se nemÄ›l nikdy zavolat, protoÅ¾e vÃ½Å¡e je zachycen cyklickÃ½ graf
        // PonechÃ¡no pro zpÄ›tnou kompatibilitu
        return { 
            path: [], 
            weight: null, 
            mode: 'cyclic',
            error: 'Graf obsahuje cyklus â€“ nejdelÅ¡Ã­ cesta nenÃ­ definovÃ¡na.'
        };
    }

    cpmAnalysis() {
        const graphData = this._buildDirectedGraph(false);
        if (graphData.edges.length === 0) {
            return { error: 'Pro CPM analÃ½zu jsou potÅ™eba orientovanÃ© hrany (operace).' };
        }
        const topo = this.topologicalSort(false, graphData);
        if (!topo.isDAG) {
            return { error: 'SÃ­Å¥ovÃ½ graf obsahuje cyklus â€“ kritickou cestu lze hledat jen v acyklickÃ©m grafu.' };
        }
        const order = topo.order;
        const n = this.nodes.length;
        const earliest = Array(n).fill(0);
        for (const u of order) {
            for (const edge of graphData.adj[u]) {
                const candidate = earliest[u] + edge.weight;
                if (candidate > earliest[edge.to]) {
                    earliest[edge.to] = candidate;
                }
            }
        }
        const projectDuration = Math.max(...earliest);
        const latest = Array(n).fill(projectDuration);
        for (let i = order.length - 1; i >= 0; i--) {
            const u = order[i];
            if (!graphData.adj[u].length) {
                latest[u] = Math.min(latest[u], projectDuration);
                continue;
            }
            let minCandidate = Infinity;
            for (const edge of graphData.adj[u]) {
                const candidate = latest[edge.to] - edge.weight;
                if (candidate < minCandidate) minCandidate = candidate;
            }
            if (minCandidate !== Infinity) {
                latest[u] = Math.min(latest[u], minCandidate);
            }
        }
        // Pro uzly potÅ™ebujeme vypoÄÃ­tat ES, EF, LS, LF
        // ES (Early Start) = nejdÅ™Ã­ve moÅ¾nÃ½ start = earliest[idx]
        // EF (Early Finish) = nejdÅ™Ã­ve moÅ¾nÃ© ukonÄenÃ­ = max(EF vÅ¡ech pÅ™Ã­chozÃ­ch hran) = earliest[idx]
        // LS (Late Start) = nejpozdÄ›ji pÅ™Ã­pustnÃ½ start = min(LS vÅ¡ech odchozÃ­ch hran - duration) 
        // LF (Late Finish) = nejpozdÄ›ji pÅ™Ã­pustnÃ© ukonÄenÃ­ = latest[idx]
        // Pro uzlovÃ½ graf: ES = EF (uzel je okamÅ¾ik, ne Äinnost)
        const nodeSummaries = this.nodes.map((id, idx) => {
            const es = earliest[idx];  // Early Start = Early Finish pro uzel
            const ef = earliest[idx];  // Early Finish
            const ls = latest[idx];    // Late Start = Late Finish pro uzel  
            const lf = latest[idx];    // Late Finish
            const slack = lf - ef;     // Rezerva = LF - EF (nebo LS - ES)
            return {
                id,
                es,
                ef,
                ls,
                lf,
                earliest: earliest[idx],
                latest: latest[idx],
                slack,
                isCritical: Math.abs(slack) < 1e-6
            };
        });
        const activities = graphData.edges.map(edge => {
            const earlyStart = earliest[edge.from];
            const duration = edge.weight;
            const earlyFinish = earlyStart + duration;
            const lateFinish = latest[edge.to];
            const lateStart = lateFinish - duration;
            const slack = lateStart - earlyStart;
            return {
                id: edge.label || `${edge.fromId}â†’${edge.toId}`,
                from: edge.fromId,
                to: edge.toId,
                duration,
                earlyStart,
                earlyFinish,
                lateStart,
                lateFinish,
                slack,
                isCritical: Math.abs(slack) < 1e-6
            };
        });
        const criticalActivities = activities.filter(a => a.isCritical);
        const criticalPath = this._extractCriticalPath(criticalActivities);
        return {
            projectDuration,
            nodeSummaries,
            activities,
            criticalPath,
            criticalEdgesCount: criticalActivities.length
        };
    }

    _extractCriticalPath(criticalActivities) {
        if (!criticalActivities.length) return [];
        const adjacency = {};
        const indegree = {};
        for (const act of criticalActivities) {
            if (!adjacency[act.from]) adjacency[act.from] = [];
            adjacency[act.from].push(act);
            indegree[act.to] = (indegree[act.to] || 0) + 1;
            indegree[act.from] = indegree[act.from] || 0;
        }
        const startCandidates = Object.keys(adjacency).filter(node => (indegree[node] || 0) === 0);
        const start = startCandidates[0] || criticalActivities[0].from;
        const stack = [[start, [start]]];
        let bestPath = [];
        while (stack.length) {
            const [node, path] = stack.pop();
            const nextEdges = adjacency[node] || [];
            if (!nextEdges.length) {
                if (path.length > bestPath.length) {
                    bestPath = path.slice();
                }
            } else {
                for (const edge of nextEdges) {
                    stack.push([edge.to, [...path, edge.to]]);
                }
            }
        }
        return bestPath;
    }

    _buildCapacityMatrixForFlows() {
        if (!this.nodes.length) return null;
        const data = this._buildDirectedGraph(true);
        const n = this.nodes.length;
        const capacity = Array.from({ length: n }, () => Array(n).fill(0));
        data.edges.forEach(edge => {
            capacity[edge.from][edge.to] += edge.weight;
        });
        return { capacity, idx: data.idx };
    }

    _flowEdgesFrom(capacity, residual) {
        const edges = [];
        const n = capacity.length;
        const EPS = 1e-9;
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                const cap = capacity[i][j];
                if (cap <= EPS) continue;
                const flow = cap - residual[i][j];
                if (flow > EPS) {
                    edges.push({
                        from: this.nodes[i],
                        to: this.nodes[j],
                        flow,
                        capacity: cap,
                        utilization: cap ? flow / cap : 0
                    });
                }
            }
        }
        edges.sort((a, b) => b.flow - a.flow);
        return edges;
    }

    _capacitySummary(capacity, sourceIdx, sinkIdx) {
        const outFromSource = capacity[sourceIdx].reduce((a, b) => a + b, 0);
        let intoSink = 0;
        for (let i = 0; i < capacity.length; i++) {
            intoSink += capacity[i][sinkIdx];
        }
        return { outFromSource, intoSink };
    }

    _deriveMinCut(capacity, residual, sourceIdx) {
        const n = capacity.length;
        const visited = Array(n).fill(false);
        const stack = [sourceIdx];
        const EPS = 1e-9;
        while (stack.length) {
            const u = stack.pop();
            if (visited[u]) continue;
            visited[u] = true;
            for (let v = 0; v < n; v++) {
                if (visited[v]) continue;
                if (residual[u][v] > EPS) {
                    stack.push(v);
                }
            }
        }
        const S = [];
        const T = [];
        const edges = [];
        for (let i = 0; i < n; i++) {
            if (visited[i]) S.push(this.nodes[i]);
            else T.push(this.nodes[i]);
            for (let j = 0; j < n; j++) {
                if (visited[i] && !visited[j] && capacity[i][j] > EPS) {
                    edges.push({
                        from: this.nodes[i],
                        to: this.nodes[j],
                        capacity: capacity[i][j]
                    });
                }
            }
        }
        const value = edges.reduce((acc, e) => acc + e.capacity, 0);
        return { value, S, T, edges };
    }

    _augmentingPathMaxFlow(baseCapacity, sourceIdx, sinkIdx, useBfs) {
        const n = baseCapacity.length;
        const capacity = baseCapacity.map(row => row.slice());
        const residual = capacity.map(row => row.slice());
        const parent = Array(n).fill(-1);
        const augmentingPaths = [];
        const EPS = 1e-9;
        const findPath = () => {
            parent.fill(-1);
            parent[sourceIdx] = sourceIdx;
            if (useBfs) {
                const queue = [sourceIdx];
                while (queue.length) {
                    const u = queue.shift();
                    for (let v = 0; v < n; v++) {
                        if (parent[v] !== -1) continue;
                        if (residual[u][v] <= EPS) continue;
                        parent[v] = u;
                        if (v === sinkIdx) return true;
                        queue.push(v);
                    }
                }
            } else {
                const stack = [sourceIdx];
                while (stack.length) {
                    const u = stack.pop();
                    for (let v = 0; v < n; v++) {
                        if (parent[v] !== -1) continue;
                        if (residual[u][v] <= EPS) continue;
                        parent[v] = u;
                        if (v === sinkIdx) return true;
                        stack.push(v);
                    }
                }
            }
            return false;
        };
        let maxFlow = 0;
        let iterations = 0;
        while (findPath()) {
            iterations++;
            let pathFlow = Infinity;
            let v = sinkIdx;
            const pathNodes = [];
            while (v !== sourceIdx) {
                const u = parent[v];
                pathFlow = Math.min(pathFlow, residual[u][v]);
                pathNodes.push(this.nodes[v]);
                v = u;
            }
            pathNodes.push(this.nodes[sourceIdx]);
            pathNodes.reverse();
            augmentingPaths.push({
                path: pathNodes,
                bottleneck: pathFlow
            });
            v = sinkIdx;
            while (v !== sourceIdx) {
                const u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow;
                v = u;
            }
            maxFlow += pathFlow;
            if (iterations > 10000) break;
        }
        const minCut = this._deriveMinCut(capacity, residual, sourceIdx);
        return {
            maxFlow,
            augmentingPaths,
            iterations,
            minCut,
            flowEdges: this._flowEdgesFrom(capacity, residual),
            residual
        };
    }

    _pushRelabelMaxFlow(baseCapacity, sourceIdx, sinkIdx) {
        const n = baseCapacity.length;
        const capacity = baseCapacity.map(row => row.slice());
        const flow = Array.from({ length: n }, () => Array(n).fill(0));
        const height = Array(n).fill(0);
        const excess = Array(n).fill(0);
        const neighborSets = Array.from({ length: n }, () => new Set());
        for (let u = 0; u < n; u++) {
            for (let v = 0; v < n; v++) {
                if (capacity[u][v] > 0 || capacity[v][u] > 0) {
                    neighborSets[u].add(v);
                }
            }
        }
        const neighbors = neighborSets.map(set => Array.from(set));
        height[sourceIdx] = n;
        for (let v = 0; v < n; v++) {
            if (capacity[sourceIdx][v] > 0) {
                const cap = capacity[sourceIdx][v];
                flow[sourceIdx][v] = cap;
                flow[v][sourceIdx] = -cap;
                excess[v] += cap;
                excess[sourceIdx] -= cap;
            }
        }
        const nodes = [];
        for (let i = 0; i < n; i++) {
            if (i !== sourceIdx && i !== sinkIdx) nodes.push(i);
        }
        const seen = Array(n).fill(0);
        let relabelCount = 0;
        let pushCount = 0;
        const residualCapacity = (u, v) => capacity[u][v] - flow[u][v];
        const push = (u, v) => {
            const send = Math.min(excess[u], residualCapacity(u, v));
            if (send <= 0) return false;
            flow[u][v] += send;
            flow[v][u] -= send;
            excess[u] -= send;
            excess[v] += send;
            pushCount++;
            return true;
        };
        const relabel = (u) => {
            let minHeight = Infinity;
            neighbors[u].forEach(v => {
                if (residualCapacity(u, v) > 1e-9) {
                    minHeight = Math.min(minHeight, height[v]);
                }
            });
            if (minHeight < Infinity) {
                height[u] = minHeight + 1;
            } else {
                height[u] = Infinity;
            }
            relabelCount++;
        };
        let p = 0;
        while (p < nodes.length) {
            const u = nodes[p];
            const oldHeight = height[u];
            while (excess[u] > 1e-9) {
                const neighborList = neighbors[u];
                if (!neighborList.length) break;
                if (seen[u] >= neighborList.length) {
                    relabel(u);
                    seen[u] = 0;
                    continue;
                }
                const v = neighborList[seen[u]];
                if (residualCapacity(u, v) > 1e-9 && height[u] === height[v] + 1) {
                    push(u, v);
                } else {
                    seen[u]++;
                }
            }
            if (height[u] > oldHeight) {
                nodes.splice(0, 0, nodes.splice(p, 1)[0]);
                p = 0;
            } else {
                p++;
            }
        }
        const maxFlow = Math.max(0, excess[sinkIdx]);
        const residual = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                residual[i][j] = capacity[i][j] - flow[i][j];
            }
        }
        const minCut = this._deriveMinCut(capacity, residual, sourceIdx);
        const flowEdges = [];
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (capacity[i][j] > 0) {
                    const val = Math.max(0, flow[i][j]);
                    if (val > 1e-9) {
                        flowEdges.push({
                            from: this.nodes[i],
                            to: this.nodes[j],
                            flow: val,
                            capacity: capacity[i][j],
                            utilization: capacity[i][j] ? val / capacity[i][j] : 0
                        });
                    }
                }
            }
        }
        flowEdges.sort((a, b) => b.flow - a.flow);
        const heightProfile = this.nodes.map((node, idx) => ({
            node,
            height: height[idx]
        }));
        return {
            maxFlow,
            relabelCount,
            pushCount,
            heightProfile,
            minCut,
            flowEdges,
            residual
        };
    }

    flowNetworkAnalysis(sourceNode, sinkNode) {
        const structures = this._buildCapacityMatrixForFlows();
        if (!structures) {
            return { error: 'Graf neobsahuje Å¾Ã¡dnou sÃ­Å¥ pro vÃ½poÄet toku.' };
        }
        const { capacity, idx } = structures;
        if (!(sourceNode in idx) || !(sinkNode in idx)) {
            return { error: 'Zadejte prosÃ­m existujÃ­cÃ­ uzly jako zdroj (s) i cÃ­l (t).' };
        }
        const sourceIdx = idx[sourceNode];
        const sinkIdx = idx[sinkNode];
        if (sourceIdx === sinkIdx) {
            return { error: 'Zdroj a cÃ­l musÃ­ bÃ½t rÅ¯znÃ© uzly.' };
        }
        const copyMatrix = () => capacity.map(row => row.slice());
        const ford = this._augmentingPathMaxFlow(copyMatrix(), sourceIdx, sinkIdx, false);
        const edmonds = this._augmentingPathMaxFlow(copyMatrix(), sourceIdx, sinkIdx, true);
        const goldberg = this._pushRelabelMaxFlow(copyMatrix(), sourceIdx, sinkIdx);
        const bestFlow = Math.max(ford.maxFlow || 0, edmonds.maxFlow || 0, goldberg.maxFlow || 0);
        const representativeCut = edmonds.minCut || ford.minCut || goldberg.minCut;
        return {
            source: sourceNode,
            sink: sinkNode,
            fordFulkerson: ford,
            edmondsKarp: edmonds,
            goldberg,
            bestFlow,
            minCut: representativeCut,
            capacitySummary: this._capacitySummary(capacity, sourceIdx, sinkIdx)
        };
    }

    dfsTraversal(startNode) {
        const result = [];
        const visited = new Set();
        const adj = this.neighbours();

        function dfs(node) {
            if (!node || visited.has(node)) {
                return;
            }
            visited.add(node);
            result.push(node);
            const neighbors = adj[node] || [];
            for (const neighbor of neighbors) {
                dfs(neighbor);
            }
        }

        dfs(startNode);
        return result;
    }

    bfsTraversal(startNode) {
        const result = [];
        const visited = new Set();
        const queue = [startNode];
        const adj = this.neighbours();

        if (!this.nodes.includes(startNode)) {
            return [];
        }

        visited.add(startNode);

        while (queue.length > 0) {
            const node = queue.shift();
            result.push(node);

            const neighbors = adj[node] || [];
            for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                    visited.add(neighbor);
                    queue.push(neighbor);
                }
            }
        }
        return result;
    }
}


function createMatrixTable(matrix, rowLabels, colLabels) {
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th'));
    for (const label of colLabels) {
        const th = document.createElement('th');
        th.textContent = label;
        headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (let i = 0; i < matrix.length; i++) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = rowLabels[i];
        tr.appendChild(th);
        for (let j = 0; j < matrix[i].length; j++) {
            const td = document.createElement('td');
            const val = matrix[i][j];
            td.textContent = (val === Infinity ? 'âˆ' : val);
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    table.addEventListener('mouseover', handleMatrixMouseOver(matrix));
    table.addEventListener('mouseout', handleMatrixMouseOut);
    return table;
}

function handleMatrixMouseOver(matrix) {
    return function(event) {
        const cell = event.target.closest('td');
        if (!cell) return;

        const rowIndex = cell.parentNode.rowIndex - 1;
        const colIndex = cell.cellIndex - 1;

        // Row stats
        const row = matrix[rowIndex];
        const rowSum = row.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
        const rowCounts = row.reduce((acc, val) => {
            if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});

        // Column stats
        const col = matrix.map(r => r[colIndex]);
        const colSum = col.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
        const colCounts = col.reduce((acc, val) => {
            if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});

        let statsHTML = `<strong>Å˜Ã¡dek ${rowIndex + 1}:</strong> SouÄet = ${rowSum}<br>`;
        statsHTML += `<strong>Sloupec ${colIndex + 1}:</strong> SouÄet = ${colSum}<br>`;

        // Diagonal stats
        if (rowIndex === colIndex) {
            const mainDiag = matrix.map((r, i) => r[i]);
            const mainDiagSum = mainDiag.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            statsHTML += `<strong>HlavnÃ­ diagonÃ¡la:</strong> SouÄet = ${mainDiagSum}<br>`;
        }
        if (rowIndex + colIndex === matrix.length - 1) {
            const antiDiag = matrix.map((r, i) => r[matrix.length - 1 - i]);
            const antiDiagSum = antiDiag.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            statsHTML += `<strong>VedlejÅ¡Ã­ diagonÃ¡la:</strong> SouÄet = ${antiDiagSum}<br>`;
        }

        const tooltip = document.getElementById('matrix-stats-tooltip');
        tooltip.innerHTML = statsHTML;
        tooltip.style.display = 'block';
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY + 10}px`;
    };
}

function handleMatrixMouseOut(event) {
    const tooltip = document.getElementById('matrix-stats-tooltip');
    tooltip.style.display = 'none';
}

function calculateMatrixStats(matrix, rowLabels = null, colLabels = null) {
    const n = matrix.length;
    if (n === 0) return {
        positiveCount: 0, negativeCount: 0, zeroCount: 0, infinityCount: 0,
        totalCount: 0, totalSum: 0, rowSums: [], colSums: [], valueCounts: {},
        diagonalSum: 0, diagonalCounts: {}, antiDiagonalSum: 0, antiDiagonalCounts: {},
        mainDiagonalStats: [], antiDiagonalStats: [],
        rowStats: [], colStats: [], rowLabels: [], colLabels: []
    };
    const m = matrix[0].length;

    let positiveCount = 0;
    let negativeCount = 0;
    let zeroCount = 0;
    let infinityCount = 0;
    let totalSum = 0;
    const rowSums = Array(n).fill(0);
    const colSums = Array(m).fill(0);
    const valueCounts = {};
    let diagonalSum = 0;
    const diagonalCounts = {};
    let antiDiagonalSum = 0;
    const antiDiagonalCounts = {};
    
    // Statistiky pro kaÅ¾dÃ½ Å™Ã¡dek a sloupec
    const rowStats = Array(n).fill(null).map(() => ({ sum: 0, counts: {}, positive: 0, negative: 0, zero: 0 }));
    const colStats = Array(m).fill(null).map(() => ({ sum: 0, counts: {}, positive: 0, negative: 0, zero: 0 }));
    
    // Statistiky pro diagonÃ¡ly (detailnÃ­ pro kaÅ¾dÃ½ prvek)
    const mainDiagonalStats = [];
    const antiDiagonalStats = [];

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            const val = matrix[i][j];

            if (val > 0 && isFinite(val)) {
                positiveCount++;
                rowStats[i].positive++;
                colStats[j].positive++;
            } else if (val < 0 && isFinite(val)) {
                negativeCount++;
                rowStats[i].negative++;
                colStats[j].negative++;
            } else if (val === 0) {
                zeroCount++;
                rowStats[i].zero++;
                colStats[j].zero++;
            } else if (!isFinite(val)) {
                infinityCount++;
            }

            if (isFinite(val)) {
                rowSums[i] += val;
                colSums[j] += val;
                totalSum += val;
                rowStats[i].sum += val;
                colStats[j].sum += val;
            }

            const key = !isFinite(val) ? 'âˆ' : val;
            valueCounts[key] = (valueCounts[key] || 0) + 1;
            rowStats[i].counts[key] = (rowStats[i].counts[key] || 0) + 1;
            colStats[j].counts[key] = (colStats[j].counts[key] || 0) + 1;
        }
    }

    // HlavnÃ­ diagonÃ¡la (i == j)
    if (n === m) {
        for (let i = 0; i < n; i++) {
            const val = matrix[i][i];
            if (isFinite(val)) {
                diagonalSum += val;
            }
            const key = !isFinite(val) ? 'âˆ' : val;
            diagonalCounts[key] = (diagonalCounts[key] || 0) + 1;
            
            // DetailnÃ­ statistika pro kaÅ¾dÃ½ prvek hlavnÃ­ diagonÃ¡ly
            const rLabel = rowLabels ? rowLabels[i] : `R${i+1}`;
            const cLabel = colLabels ? colLabels[i] : `C${i+1}`;
            mainDiagonalStats.push({
                rowLabel: rLabel,
                colLabel: cLabel,
                value: val,
                position: i
            });
        }
        
        // VedlejÅ¡Ã­ diagonÃ¡la (i + j == n - 1)
        for (let i = 0; i < n; i++) {
            const j = n - 1 - i;
            const val = matrix[i][j];
            if (isFinite(val)) {
                antiDiagonalSum += val;
            }
            const key = !isFinite(val) ? 'âˆ' : val;
            antiDiagonalCounts[key] = (antiDiagonalCounts[key] || 0) + 1;
            
            // DetailnÃ­ statistika pro kaÅ¾dÃ½ prvek vedlejÅ¡Ã­ diagonÃ¡ly
            const rLabel = rowLabels ? rowLabels[i] : `R${i+1}`;
            const cLabel = colLabels ? colLabels[j] : `C${j+1}`;
            antiDiagonalStats.push({
                rowLabel: rLabel,
                colLabel: cLabel,
                value: val,
                position: i
            });
        }
    }

    return {
        positiveCount, negativeCount, zeroCount, infinityCount,
        totalCount: n * m, totalSum, rowSums, colSums, valueCounts,
        diagonalSum, diagonalCounts, antiDiagonalSum, antiDiagonalCounts,
        mainDiagonalStats, antiDiagonalStats,
        rowStats, colStats,
        rowLabels: rowLabels || Array(n).fill(null).map((_, i) => `R${i+1}`),
        colLabels: colLabels || Array(m).fill(null).map((_, i) => `C${i+1}`)
    };
}

function createMatrixStatsHTML(stats, options = {}) {
    let html = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
    const hasPosNeg = stats.positiveCount > 0 || stats.negativeCount > 0;

    if (hasPosNeg) {
        html += `<div style="display: flex; gap: 1.5rem; margin-bottom: 0.75rem; font-size: 1rem;">`;
        if (stats.positiveCount > 0) html += `<div><span class="text-success" style="font-weight: bold;">âœ” KladnÃ©:</span> ${stats.positiveCount}</div>`;
        if (stats.negativeCount > 0) html += `<div><span class="text-danger" style="font-weight: bold;">âœ– ZÃ¡pornÃ©:</span> ${stats.negativeCount}</div>`;
        if (stats.zeroCount > 0) html += `<div><span class="text-muted" style="font-weight: bold;">_ NulovÃ©:</span> ${stats.zeroCount}</div>`;
        html += `</div>`;
    }

    const toggleId = `toggle-${Math.random().toString(36).substr(2, 9)}`;
    const filterId = `filter-${Math.random().toString(36).substr(2, 9)}`;
    html += `
        <div style="margin-bottom: 1rem;">
            <input type="checkbox" id="${toggleId}" class="matrix-stats-toggle" style="display: none;">
            <label for="${toggleId}" class="text-accent" style="cursor: pointer; text-decoration: underline;">Zobrazit/skrÃ½t pokroÄilÃ© statistiky (souÄty)</label>
            <div class="advanced-stats bg-secondary" style="display: none; margin-top: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid var(--border-color);">
    `;
    
    if (options.showRowColSums && stats.rowStats && stats.colStats) {
        // PomocnÃ¡ funkce pro formÃ¡tovÃ¡nÃ­ poÄtÅ¯ hodnot
        const formatCounts = (counts) => {
            const sortedKeys = Object.keys(counts).sort((a, b) => (a === 'âˆ' ? 1 : (b === 'âˆ' ? -1 : a - b)));
            return sortedKeys.map(key => `${key}Ã—${counts[key]}`).join(', ');
        };
        
        // Filtr pro rychlÃ© vyhledÃ¡nÃ­ uzlu
        html += `<div class="bg-info" style="margin-bottom: 0.75rem; padding: 0.5rem; border-radius: 0.25rem;">
            <strong class="text-accent">ğŸ” Filtr uzlÅ¯:</strong>
            <input type="text" id="${filterId}" placeholder="Zadejte nÃ¡zev uzlu pro filtrovÃ¡nÃ­..." 
                   style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; border: 1px solid var(--border-input); border-radius: 0.25rem; width: 200px; background-color: var(--bg-secondary); color: var(--text-primary);"
                   oninput="filterMatrixStatsTables(this.value, '${filterId}')">
            <button onclick="document.getElementById('${filterId}').value=''; filterMatrixStatsTables('', '${filterId}')" 
                    style="margin-left: 0.25rem; padding: 0.25rem 0.5rem; font-size: 0.85em;">Vymazat</button>
        </div>`;
        
        // Å˜Ã¡dky s podrobnÃ½mi statistikami
        html += `<div style="margin-bottom: 0.75rem;">
            <strong style="color: #0d6efd;">ğŸ“Š Statistiky Å™Ã¡dkÅ¯ (uzly):</strong>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 0.5rem; font-size: 0.9em;">
                <table class="stats-table-rows-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.95em;">
                    <thead>
                        <tr style="background-color: #e9ecef;">
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">Uzel</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: right; border: 1px solid #dee2e6;">SouÄet</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: center; border: 1px solid #dee2e6;">+ / âˆ’ / 0</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">PoÄty hodnot</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${stats.rowStats.map((rs, i) => `
                            <tr data-node="${stats.rowLabels[i]}">
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${stats.rowLabels[i]}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right;">${rs.sum}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">
                                    <span style="color: #198754;">${rs.positive}</span> / 
                                    <span style="color: #dc3545;">${rs.negative}</span> / 
                                    <span style="color: #6c757d;">${rs.zero}</span>
                                </td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-size: 0.9em;">${formatCounts(rs.counts)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>`;
        
        // Sloupce s podrobnÃ½mi statistikami
        html += `<div style="margin-bottom: 0.75rem;">
            <strong style="color: #0d6efd;">ğŸ“Š Statistiky sloupcÅ¯ (uzly):</strong>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 0.5rem; font-size: 0.9em;">
                <table class="stats-table-cols-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.95em;">
                    <thead>
                        <tr style="background-color: #e9ecef;">
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">Uzel</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: right; border: 1px solid #dee2e6;">SouÄet</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: center; border: 1px solid #dee2e6;">+ / âˆ’ / 0</th>
                            <th style="padding: 0.25rem 0.5rem; text-align: left; border: 1px solid #dee2e6;">PoÄty hodnot</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${stats.colStats.map((cs, i) => `
                            <tr data-node="${stats.colLabels[i]}">
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${stats.colLabels[i]}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right;">${cs.sum}</td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">
                                    <span style="color: #198754;">${cs.positive}</span> / 
                                    <span style="color: #dc3545;">${cs.negative}</span> / 
                                    <span style="color: #6c757d;">${cs.zero}</span>
                                </td>
                                <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-size: 0.9em;">${formatCounts(cs.counts)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        </div>`;
        
        html += `<hr style="margin: 0.5rem 0;"/>`;
    }
    
    const sortedKeys = Object.keys(stats.valueCounts).sort((a, b) => (a === 'âˆ' ? 1 : (b === 'âˆ' ? -1 : a - b)));
    const valueCountsHTML = sortedKeys.map(key => {
        const count = stats.valueCounts[key];
        const percentage = ((count / stats.totalCount) * 100).toFixed(1);
        return `<div style="display: inline-block; margin: 0.25rem 1rem 0.25rem 0;">
            <strong>${key}:</strong> ${count}Ã— <span style="color: #6c757d;">(${percentage}%)</span>
        </div>`;
    }).join('');

    html += `
            <div>${valueCountsHTML}</div>
            <div style="margin-top: 0.5rem; border-top: 1px solid #dee2e6; padding-top: 0.5rem;">
                <strong>CelkovÃ½ souÄet (koneÄnÃ© hodnoty):</strong> ${stats.totalSum.toFixed(2)} |
                <strong>Celkem hodnot:</strong> ${stats.totalCount}
            </div>
    `;

    // HlavnÃ­ diagonÃ¡la s detaily
    if (stats.mainDiagonalStats && stats.mainDiagonalStats.length > 0) {
        const diagonalCountsHTML = Object.keys(stats.diagonalCounts).map(key => {
            const count = stats.diagonalCounts[key];
            return `<strong>${key}:</strong> ${count}Ã—`;
        }).join(', ');

        html += `
            <div style="margin-top: 0.5rem; border-top: 1px solid #dee2e6; padding-top: 0.5rem;">
                <strong style="color: #0d6efd;">â†˜ï¸ HlavnÃ­ diagonÃ¡la:</strong><br>
                <div style="margin-left: 1rem;">
                    <strong>SouÄet:</strong> ${stats.diagonalSum.toFixed(2)} | 
                    <strong>PoÄty hodnot:</strong> ${diagonalCountsHTML}
                </div>
                <details style="margin-top: 0.25rem;">
                    <summary style="cursor: pointer; color: #0d6efd;">Zobrazit jednotlivÃ© prvky diagonÃ¡ly</summary>
                    <div style="max-height: 150px; overflow-y: auto; margin-top: 0.25rem;">
                        <table class="stats-table-diag-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Pozice</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Å˜Ã¡dek (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Sloupec (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Hodnota</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${stats.mainDiagonalStats.map((d, idx) => `
                                    <tr data-node="${d.rowLabel}">
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">[${idx},${idx}]</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.rowLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.colLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right; ${d.value > 0 ? 'color: #198754;' : d.value < 0 ? 'color: #dc3545;' : ''}">${isFinite(d.value) ? d.value : 'âˆ'}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </details>
            </div>
        `;
    }

    // VedlejÅ¡Ã­ diagonÃ¡la s detaily
    if (stats.antiDiagonalStats && stats.antiDiagonalStats.length > 0) {
        const antiDiagonalCountsHTML = Object.keys(stats.antiDiagonalCounts).map(key => {
            const count = stats.antiDiagonalCounts[key];
            return `<strong>${key}:</strong> ${count}Ã—`;
        }).join(', ');

        html += `
            <div style="margin-top: 0.5rem; border-top: 1px solid #dee2e6; padding-top: 0.5rem;">
                <strong style="color: #0d6efd;">â†™ï¸ VedlejÅ¡Ã­ diagonÃ¡la:</strong><br>
                <div style="margin-left: 1rem;">
                    <strong>SouÄet:</strong> ${stats.antiDiagonalSum.toFixed(2)} | 
                    <strong>PoÄty hodnot:</strong> ${antiDiagonalCountsHTML}
                </div>
                <details style="margin-top: 0.25rem;">
                    <summary style="cursor: pointer; color: #0d6efd;">Zobrazit jednotlivÃ© prvky vedlejÅ¡Ã­ diagonÃ¡ly</summary>
                    <div style="max-height: 150px; overflow-y: auto; margin-top: 0.25rem;">
                        <table class="stats-table-antidiag-${filterId}" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <thead>
                                <tr style="background-color: #e9ecef;">
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Pozice</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Å˜Ã¡dek (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Sloupec (uzel)</th>
                                    <th style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6;">Hodnota</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${stats.antiDiagonalStats.map((d, idx) => {
                                    const n = stats.antiDiagonalStats.length;
                                    return `
                                    <tr data-node="${d.rowLabel}">
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: center;">[${idx},${n - 1 - idx}]</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.rowLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; font-weight: bold;">${d.colLabel}</td>
                                        <td style="padding: 0.25rem 0.5rem; border: 1px solid #dee2e6; text-align: right; ${d.value > 0 ? 'color: #198754;' : d.value < 0 ? 'color: #dc3545;' : ''}">${isFinite(d.value) ? d.value : 'âˆ'}</td>
                                    </tr>
                                `}).join('')}
                            </tbody>
                        </table>
                    </div>
                </details>
            </div>
        `;
    }

    html += `</div></div>`;

    return html;
}

// Funkce pro filtrovÃ¡nÃ­ tabulek statistik podle uzlu
function filterMatrixStatsTables(filterValue, filterId) {
    const filter = filterValue.toLowerCase().trim();
    const tables = document.querySelectorAll(`.stats-table-rows-${filterId}, .stats-table-cols-${filterId}, .stats-table-diag-${filterId}, .stats-table-antidiag-${filterId}`);
    
    tables.forEach(table => {
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            const nodeName = row.getAttribute('data-node');
            if (!filter || (nodeName && nodeName.toLowerCase().includes(filter))) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
    });
}

function createListTable(map) {
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');
    for (const key of Object.keys(map)) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = key;
        tr.appendChild(th);
        const td = document.createElement('td');
        td.textContent = map[key].join(', ');
        tr.appendChild(td);
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
}

let currentGraph = null;

document.getElementById('parseBtn').addEventListener('click', () => {
    const input = document.getElementById('graphInput').value;
    const graph = new Graph();
    graph.parse(input);
    currentGraph = graph;
    
    const output = document.getElementById('output');
    output.innerHTML = '';
    
    if (graph.nodes.length === 0) {
        output.textContent = 'Nebyl rozpoznÃ¡n Å¾Ã¡dnÃ½ uzel. Zkontrolujte prosÃ­m vstup.';
        document.getElementById('counters').style.display = 'none';
        return;
    }

    // âš¡ DÅ®LEÅ½ITÃ‰: ZÃ­skej properties() hned na zaÄÃ¡tku, pouÅ¾Ã­vÃ¡ se to vÅ¡ude!
    const props = graph.properties();

    // Update counters
    document.getElementById('nodeCount').textContent = graph.nodes.length;
    document.getElementById('edgeCount').textContent = graph.edges.length;
    document.getElementById('componentCount').textContent = graph.countComponents();
    document.getElementById('counters').style.display = 'block';

    // ğŸ“Š STATISTICKÃ SEKCE - KompletnÃ­ pÅ™ehled grafu
    const statsSection = document.createElement('div');
    statsSection.id = 'statisticsSection';
    statsSection.className = 'stats-box';
    statsSection.style.margin = '1rem 0';
    statsSection.style.padding = '1rem';
    statsSection.style.backgroundColor = '#f8f9fa';
    statsSection.style.border = '1px solid #dee2e6';
    statsSection.style.borderRadius = '0.25rem';
    
    const statsHeader = document.createElement('h2');
    statsHeader.style.marginTop = '0';
    statsHeader.style.color = '#0d6efd';
    statsHeader.innerHTML = 'ğŸ“Š KompletnÃ­ statistickÃ½ pÅ™ehled';
    statsSection.appendChild(statsHeader);
    
    const statsBtn = document.createElement('button');
    statsBtn.textContent = 'Zobrazit statistiky';
    statsBtn.style.marginBottom = '1rem';
    
    const statsContent = document.createElement('div');
    statsContent.style.display = 'none';
    
    statsBtn.addEventListener('click', () => {
        if (statsContent.style.display === 'none') {
            const stats = graph.getStatistics();
            const degrees = graph.degrees();
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">';
            
            // ğŸ“ˆ ZÃ¡kladnÃ­ metriky
            html += `
                <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #0d6efd;">
                    <h3 style="margin-top: 0; color: #0d6efd;">ğŸ“ˆ ZÃ¡kladnÃ­ metriky</h3>
                    <div style="line-height: 1.8;">
                        <strong>Uzly:</strong> ${stats.nodeCount}<br>
                        <strong>Hrany:</strong> ${stats.edgeCount}<br>
                        <strong>Komponenty:</strong> ${stats.componentCount}<br>
                        <strong>IzolovanÃ© uzly:</strong> ${stats.isolatedNodes.length}${stats.isolatedNodes.length > 0 ? ` (${stats.isolatedNodes.slice(0, 5).join(', ')}${stats.isolatedNodes.length > 5 ? '...' : ''})` : ''}<br>
                        <strong>SmyÄky:</strong> ${stats.loops}<br>
                        <strong>Hustota grafu:</strong> ${(stats.density * 100).toFixed(2)}%
                    </div>
                </div>
            `;

            // ğŸ“ NejkratÅ¡Ã­ a nejdelÅ¡Ã­ hrana
            if (stats.shortestEdge) {
                const shortest = stats.shortestEdge;
                const longest = stats.longestEdge;
                const shortestWeight = shortest.weight !== null && shortest.weight !== undefined ? shortest.weight : 1;
                const longestWeight = longest.weight !== null && longest.weight !== undefined ? longest.weight : 1;
                html += `
                    <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #6f42c1;">
                        <h3 style="margin-top: 0; color: #6f42c1;">ğŸ“ NejkratÅ¡Ã­ a nejdelÅ¡Ã­ hrana</h3>
                        <div style="line-height: 1.8;">
                            <strong>NejkratÅ¡Ã­:</strong> ${shortest.u} â†’ ${shortest.v} (vÃ¡ha: ${shortestWeight})<br>
                            <strong>NejdelÅ¡Ã­:</strong> ${longest.u} â†’ ${longest.v} (vÃ¡ha: ${longestWeight})
                        </div>
                    </div>
                `;
            }
            if (stats.edgeWeights) {
                html += `
                    <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #fd7e14;">
                        <h3 style="margin-top: 0; color: #fd7e14;">âš–ï¸ Statistiky vah hran</h3>
                        <div style="line-height: 1.8;">
                            <strong>Min vÃ¡ha:</strong> ${stats.edgeWeights.min}<br>
                            <strong>Max vÃ¡ha:</strong> ${stats.edgeWeights.max}<br>
                            <strong>PrÅ¯mÄ›rnÃ¡ vÃ¡ha:</strong> ${stats.edgeWeights.avg.toFixed(2)}<br>
                            <strong>Distribuce:</strong> ${Object.entries(stats.edgeWeights.distribution).map(([w, c]) => `${w}: ${c}Ã—`).join(', ')}
                        </div>
                    </div>
                `;
            }
            
            // ğŸ¯ StupnÄ› uzlÅ¯
            const degDistKeys = Object.keys(stats.degrees.distribution).map(Number).sort((a, b) => a - b);
            const degDistStr = degDistKeys.slice(0, 10).map(deg => `${deg}: ${stats.degrees.distribution[deg]}Ã—`).join(', ');
            
            // âš¡ NOVÃ‰: Pro orientovanÃ© grafy zobraz IN/OUT stupnÄ›
            let degreeDetailsHTML = '';
            if (stats.inDegrees && stats.outDegrees) {
                degreeDetailsHTML = `
                    <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid #dee2e6;">
                    <strong style="color: #0d6efd;">IN-degree:</strong><br>
                    <span style="margin-left: 1rem;">Min: ${stats.inDegrees.min} | Max: ${stats.inDegrees.max} | Ã˜ ${stats.inDegrees.avg.toFixed(2)}</span><br>
                    <strong style="color: #dc3545;">OUT-degree:</strong><br>
                    <span style="margin-left: 1rem;">Min: ${stats.outDegrees.min} | Max: ${stats.outDegrees.max} | Ã˜ ${stats.outDegrees.avg.toFixed(2)}</span>
                `;
            }
            
            html += `
                <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #198754;">
                    <h3 style="margin-top: 0; color: #198754;">ğŸ¯ StupnÄ› uzlÅ¯</h3>
                    <div style="line-height: 1.8;">
                        <strong>Min:</strong> ${stats.degrees.min}<br>
                        <strong>Max:</strong> ${stats.degrees.max}<br>
                        <strong>PrÅ¯mÄ›r:</strong> ${stats.degrees.avg.toFixed(2)}<br>
                        <strong>MediÃ¡n:</strong> ${stats.degrees.median}<br>
                        ${degreeDetailsHTML}
                        <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid #dee2e6;">
                        <strong>Distribuce:</strong><br>
                        <span style="font-size: 0.9rem; color: #666;">${degDistStr}${degDistKeys.length > 10 ? '...' : ''}</span>
                    </div>
                </div>
            `;
            
            // ğŸ”— Hrany
            html += `
                <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #dc3545;">
                    <h3 style="margin-top: 0; color: #dc3545;">ğŸ”— Hrany</h3>
                    <div style="line-height: 1.8;">
                        <strong>OrientovanÃ©:</strong> ${stats.directedEdges}<br>
                        <strong>NeorientovanÃ©:</strong> ${stats.undirectedEdges}<br>
                        <strong>S vahami:</strong> ${stats.weightedEdges}<br>
                        <strong>NÃ¡sobnÃ© hrany:</strong> ${stats.multipleEdgeGroups} skupin (${stats.totalMultipleEdges} hran)<br>
                        <strong>SmyÄky:</strong> ${stats.loops}
                    </div>
                </div>
            `;
            
            // ğŸŒ³ Komponenty
            if (stats.componentSizes) {
                html += `
                    <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #ffc107;">
                        <h3 style="margin-top: 0; color: #f59f00;">ğŸŒ³ Komponenty</h3>
                        <div style="line-height: 1.8;">
                            <strong>PoÄet komponent:</strong> ${stats.componentCount}<br>
                            <strong>NejvÄ›tÅ¡Ã­:</strong> ${stats.largestComponent} uzlÅ¯<br>
                            <strong>NejmenÅ¡Ã­:</strong> ${stats.smallestComponent} uzlÅ¯<br>
                            <strong>Velikosti:</strong> ${stats.componentSizes.slice(0, 10).join(', ')}${stats.componentSizes.length > 10 ? '...' : ''}
                        </div>
                    </div>
                `;
            }
            
            // ğŸ“ PrÅ¯mÄ›r a polomÄ›r (pokud vypoÄÃ­tÃ¡no)
            if (stats.diameter !== null) {
                html += `
                    <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #6f42c1;">
                        <h3 style="margin-top: 0; color: #6f42c1;">ğŸ“ PrÅ¯mÄ›r a polomÄ›r</h3>
                        <div style="line-height: 1.8;">
                            <strong>PrÅ¯mÄ›r grafu:</strong> ${stats.diameter}<br>
                            <strong>PolomÄ›r grafu:</strong> ${stats.radius}<br>
                            <strong>CentrÃ¡lnÃ­ uzly:</strong> ${stats.centerNodes.slice(0, 10).join(', ')}${stats.centerNodes.length > 10 ? '...' : ''}<br>
                            <strong>PerifernÃ­ uzly:</strong> ${stats.peripheralNodes.slice(0, 10).join(', ')}${stats.peripheralNodes.length > 10 ? '...' : ''}
                        </div>
                    </div>
                `;
            } else if (stats.nodeCount > 100) {
                html += `
                    <div style="background-color: #fff3cd; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #ffc107;">
                        <h3 style="margin-top: 0; color: #856404;">ğŸ“ PrÅ¯mÄ›r a polomÄ›r</h3>
                        <div style="line-height: 1.8;">
                            <em>PÅ™Ã­liÅ¡ velkÃ½ graf pro vÃ½poÄet prÅ¯mÄ›ru (> 100 uzlÅ¯)</em>
                        </div>
                    </div>
                `;
            }
            
            // ğŸ† TOP uzly podle stupnÄ›
            const topNodes = Object.entries(degrees)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
            
            html += `
                <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #20c997; grid-column: span 1;">
                    <h3 style="margin-top: 0; color: #20c997;">ğŸ† TOP uzly (nejvyÅ¡Å¡Ã­ stupeÅˆ)</h3>
                    <div style="line-height: 1.6; font-size: 0.9rem;">
                        ${topNodes.map(([node, deg], i) => `${i + 1}. <strong>${node}</strong> (${deg})`).join('<br>')}
                    </div>
                </div>
            `;
            
            // ğŸ“‰ Histogram stupÅˆÅ¯ (pokud ne moc uzlÅ¯)
            if (stats.nodeCount <= 50) {
                const maxFreq = Math.max(...Object.values(stats.degrees.distribution));
                html += `
                    <div class="stats-card" style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #0dcaf0; grid-column: span 2;">
                        <h3 style="margin-top: 0; color: #0dcaf0;">ğŸ“‰ Histogram stupÅˆÅ¯</h3>
                        <div style="font-family: monospace; font-size: 0.85rem; line-height: 1.4;">
                `;
                
                for (const deg of degDistKeys) {
                    const count = stats.degrees.distribution[deg];
                    const barWidth = Math.round((count / maxFreq) * 40);
                    const bar = 'â–ˆ'.repeat(barWidth);
                    html += `StupeÅˆ ${deg.toString().padStart(2)}: ${bar} ${count}<br>`;
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // Legenda
            html += `
                <div style="margin-top: 1rem; padding: 0.75rem; background-color: #e7f3ff; border-radius: 0.25rem; border: 1px solid #0d6efd;">
                    <strong>ğŸ’¡ VysvÄ›tlenÃ­ pojmÅ¯:</strong><br>
                    <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; line-height: 1.6;">
                        â€¢ <strong>Hustota:</strong> PomÄ›r skuteÄnÃ½ch hran k max. moÅ¾nÃ½m (0% = Å¾Ã¡dnÃ© hrany, 100% = ÃºplnÃ½ graf)<br>
                        â€¢ <strong>PrÅ¯mÄ›r:</strong> MaximÃ¡lnÃ­ excentricita = nejdelÅ¡Ã­ nejkratÅ¡Ã­ cesta mezi libovolnÃ½mi uzly<br>
                        â€¢ <strong>PolomÄ›r:</strong> MinimÃ¡lnÃ­ excentricita = centrum grafu<br>
                        â€¢ <strong>CentrÃ¡lnÃ­ uzly:</strong> Uzly s nejmenÅ¡Ã­ excentricitou (nejblÃ­Å¾ ke vÅ¡em ostatnÃ­m)<br>
                        â€¢ <strong>PerifernÃ­ uzly:</strong> Uzly s nejvÄ›tÅ¡Ã­ excentricitou (nejdÃ¡l od ostatnÃ­ch)
                    </div>
                </div>
            `;
            
            statsContent.innerHTML = html;
            statsContent.style.display = 'block';
            statsBtn.textContent = 'SkrÃ½t statistiky';
        } else {
            statsContent.style.display = 'none';
            statsBtn.textContent = 'Zobrazit statistiky';
        }
    });
    
    statsSection.appendChild(statsBtn);
    statsSection.appendChild(statsContent);
    output.appendChild(statsSection);

    // Query sections for each matrix type
    const createQuerySection = (title, matrixType) => {
    const section = document.createElement('div');
    section.className = 'query-section';
    section.innerHTML = `<h3>${title}</h3>`;
    
    const inputDiv = document.createElement('div');
    inputDiv.className = 'query-inputs';
    
    const datalistId = `nodes-datalist-${matrixType}`;
    const datalist = document.createElement('datalist');
    datalist.id = datalistId;
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        datalist.appendChild(option);
    });
    section.appendChild(datalist);

    const selectU = document.createElement('input');
    selectU.setAttribute('list', datalistId);
    selectU.className = 'node-input';
    const selectV = document.createElement('input');
    selectV.setAttribute('list', datalistId);
    selectV.className = 'node-input';
    
    const queryBtn = document.createElement('button');
    queryBtn.textContent = 'Dotaz';
    
    const resultDiv = document.createElement('div');
    resultDiv.className = 'query-result';
    resultDiv.style.display = 'none';
    
    queryBtn.addEventListener('click', () => {
        const u = selectU.value;
        const v = selectV.value;
        let result;
        
        switch(matrixType) {
            case 'adjacency':
                result = graph.adjacencyValue(u, v);
                resultDiv.textContent = `A[${u}, ${v}] = ${result}`;
                break;
            case 'sign':
                result = graph.signValue(u, v);
                resultDiv.textContent = `S[${u}, ${v}] = ${result}`;
                break;
            case 'length':
                result = graph.lengthValue(u, v);
                resultDiv.textContent = `L[${u}, ${v}] = ${result === Infinity ? 'âˆ' : result}`;
                break;
            case 'power2':
                result = graph.adjacencyPowerValue(u, v, 2);
                resultDiv.textContent = `AÂ²[${u}, ${v}] = ${result}`;
                break;
            case 'power3':
                result = graph.adjacencyPowerValue(u, v, 3);
                resultDiv.textContent = `AÂ³[${u}, ${v}] = ${result}`;
                break;
            case 'laplacian':
                result = graph.laplacianValue(u, v);
                resultDiv.innerHTML = `LaplaciÃ¡nskÃ¡ matice <strong>L[${u}, ${v}] = ${result}</strong><br>
                    <small>L = D - A (D = matice stupÅˆÅ¯, A = matice sousednosti)</small>`;
                break;
            case 'multiplicity':
                result = graph.multiplicityValue(u, v);
                resultDiv.innerHTML = `Multiplicita hran mezi <strong>${u}</strong> a <strong>${v}</strong>: <strong>${result}</strong><br>
                    <small>PoÄet vÅ¡ech hran (vÄetnÄ› paralelnÃ­ch) spojujÃ­cÃ­ch tyto uzly</small>`;
                break;
            case 'shortest':
                result = graph.shortestPath(u, v);
                if (result.distance === Infinity) {
                    resultDiv.textContent = `NejkratÅ¡Ã­ cesta z ${u} do ${v}: neexistuje`;
                } else {
                    const pathStr = result.path.join(' â†’ ');
                    resultDiv.innerHTML = `NejkratÅ¡Ã­ cesta z <strong>${u}</strong> do <strong>${v}</strong>:<br>
                        DÃ©lka: <strong>${result.distance}</strong><br>
                        Sled: <strong>${pathStr}</strong>`;
                }
                break;
        }
        resultDiv.style.display = 'block';
    });
    
    // âœ… OPRAVA: SprÃ¡vnÃ© vytvÃ¡Å™enÃ­ labelu a pÅ™idÃ¡nÃ­ elementÅ¯
    const labelU = document.createElement('span');
    labelU.textContent = 'Od uzlu: ';
    inputDiv.appendChild(labelU);
    inputDiv.appendChild(selectU);
    
    const labelV = document.createElement('span');
    labelV.textContent = ' Do uzlu: ';
    inputDiv.appendChild(labelV);
    inputDiv.appendChild(selectV);
    
    inputDiv.appendChild(queryBtn);
    
    section.appendChild(inputDiv);
    section.appendChild(resultDiv);
    return section;
};

    // Node and edge list with degrees (scrollable)
    const listSection = document.createElement('div');
    listSection.className = 'section';
    listSection.innerHTML = '<h2>Seznam uzlÅ¯ a hran</h2>';
    
    const degrees = graph.degrees();
    const nodeListDiv = document.createElement('div');
    nodeListDiv.className = 'scrollable-list';
    const nodeList = document.createElement('ul');
    nodeList.style.listStyle = 'none';
    nodeList.style.padding = '0';
    
    // âš¡ VYLEPÅ ENÃ: Pro orientovanÃ© grafy zobraz IN/OUT stupnÄ›
    const showDirectedDegrees = props.oriented === 'orientovanÃ½';
    
    graph.nodes.forEach(id => {
        const li = document.createElement('li');
        const w = graph.nodeWeights[id];
        const deg = degrees[id];
        
        let degreeInfo = '';
        if (showDirectedDegrees) {
            // Pro orientovanÃ©: spoÄÃ­tej in/out degree
            let inDegree = 0;
            let outDegree = 0;
            for (const e of graph.edges) {
                if (e.direction === '>' && e.u === id) outDegree++;
                else if (e.direction === '>' && e.v === id) inDegree++;
                else if (e.direction === '<' && e.u === id) inDegree++;
                else if (e.direction === '<' && e.v === id) outDegree++;
                else if (e.direction === '-') {
                    // NeorientovanÃ© hrany v mixed grafu
                    if (e.u === id || e.v === id) {
                        if (e.u === e.v) { inDegree++; outDegree++; } // SmyÄka
                        else { inDegree++; outDegree++; }
                    }
                }
            }
            degreeInfo = `<span class="degree-info">in: ${inDegree} | out: ${outDegree} | celkem: ${deg}</span>`;
        } else {
            degreeInfo = `<span class="degree-info">stupeÅˆ: ${deg}</span>`;
        }
        
        li.innerHTML = `<strong>Uzel ${id}</strong>${w !== null && w !== undefined ? ` (hodnota: ${w})` : ''}${degreeInfo}`;
        nodeList.appendChild(li);
    });
    nodeListDiv.appendChild(nodeList);
    listSection.appendChild(nodeListDiv);
    
    const edgeListDiv = document.createElement('div');
    edgeListDiv.className = 'scrollable-list';
    const edgeList = document.createElement('ul');
    edgeList.style.listStyle = 'none';
    edgeList.style.padding = '0';
    graph.edges.forEach(e => {
        const li = document.createElement('li');
        const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
        const label = e.label ? ` [${e.label}]` : '';
        let orientation;
        if (e.direction === '>') orientation = 'â†’';
        else if (e.direction === '<') orientation = 'â†';
        else orientation = 'â€”';
        li.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
        edgeList.appendChild(li);
    });
    edgeListDiv.appendChild(edgeList);
    listSection.appendChild(edgeListDiv);
    output.appendChild(listSection);

    // Adjacency matrix with query and binary/count toggle
    const adjSection = document.createElement('div');
    adjSection.className = 'section';
    adjSection.innerHTML = '<h2>Matice sousednosti</h2>';
    
    const adjLegendDiv = document.createElement('div');
    adjLegendDiv.className = 'info-box';
    adjLegendDiv.style.backgroundColor = '#e7f3ff';
    adjLegendDiv.style.padding = '0.75rem';
    adjLegendDiv.style.borderRadius = '0.25rem';
    adjLegendDiv.style.marginBottom = '1rem';
    adjLegendDiv.style.border = '1px solid #0d6efd';
    adjLegendDiv.innerHTML = `
        <strong>ğŸ“Š Matice sousednosti A[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>A[i,j] = 0:</strong> Bez hrany z i do j<br>
            â€¢ <strong>A[i,j] = 1:</strong> Existuje hrana z i do j<br>
            â€¢ <strong>A[i,j] â‰¥ 2:</strong> VÃ­ce paralelnÃ­ch hran (multigraf)<br>
            â€¢ <strong>SymetrickÃ¡ matice:</strong> Graf je neorientovanÃ½
        </div>
    `;
    adjSection.appendChild(adjLegendDiv);
    
    const adjToggleDiv = document.createElement('div');
    adjToggleDiv.style.marginBottom = '1rem';
    adjToggleDiv.innerHTML = '<label><input type="checkbox" id="adjBinary" /> BinÃ¡rnÃ­ verze (0/1)</label>';
    adjSection.appendChild(adjToggleDiv);
    
    adjSection.appendChild(createQuerySection('Dotaz na hodnotu', 'adjacency'));

    
    const showAdjBtn = document.createElement('button');
    showAdjBtn.textContent = 'Zobrazit celou matici';
    const adjMatrixDiv = document.createElement('div');
    adjMatrixDiv.className = 'matrix';
    adjMatrixDiv.style.display = 'none';
    const adjStatsDiv = document.createElement('div');
    adjStatsDiv.style.display = 'none';
    adjStatsDiv.style.marginTop = '1rem';
    adjStatsDiv.style.padding = '1rem';
    adjStatsDiv.className = 'info-box';
    adjStatsDiv.style.backgroundColor = '#e7f3ff';
    adjStatsDiv.style.borderRadius = '0.25rem';
    
    showAdjBtn.addEventListener('click', () => {
        if (adjMatrixDiv.style.display === 'none') {
            const binary = document.getElementById('adjBinary').checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            const stats = calculateMatrixStats(adjMat, graph.nodes, graph.nodes);
            adjStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });
            
            adjMatrixDiv.style.display = 'block';
            adjStatsDiv.style.display = 'block';
            showAdjBtn.textContent = 'SkrÃ½t matici';
        } else {
            adjMatrixDiv.style.display = 'none';
            adjStatsDiv.style.display = 'none';
            showAdjBtn.textContent = 'Zobrazit celou matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'adjBinary' && adjMatrixDiv.style.display === 'block') {
            const binary = e.target.checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            const { colStats, totalZeros, totalOnes } = countBinaryMatrix(adjMat);
            adjStatsDiv.innerHTML = '<h4 style="margin-top: 0;">CelkovÃ¡ statistika hodnot 0 a 1:</h4>';
            adjStatsDiv.innerHTML += `<div style="display: flex; gap: 2rem; margin-top: 0.5rem;">`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #0b5ed7; font-weight: bold;">PoÄet 1:</span> ${totalOnes}Ã—</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #dc3545; font-weight: bold;">PoÄet 0:</span> ${totalZeros}Ã—</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="font-weight: bold;">Celkem:</span> ${totalOnes + totalZeros}</div>`;
            adjStatsDiv.innerHTML += `</div>`;
        }
    });
    
    adjSection.appendChild(showAdjBtn);
    adjSection.appendChild(adjMatrixDiv);
    adjSection.appendChild(adjStatsDiv);
    output.appendChild(adjSection);

    // Sign matrix with query
    const signSection = document.createElement('div');
    signSection.className = 'section';
    signSection.innerHTML = '<h2>ZnamÃ©nkovÃ¡ matice</h2>';
    
    // PÅ™idej vysvÄ›tlivku
    const signLegendDiv = document.createElement('div');
    signLegendDiv.className = 'info-box';
    signLegendDiv.style.backgroundColor = '#e7f3ff';
    signLegendDiv.style.padding = '0.75rem';
    signLegendDiv.style.borderRadius = '0.25rem';
    signLegendDiv.style.marginBottom = '1rem';
    signLegendDiv.style.border = '1px solid #0d6efd';
    signLegendDiv.innerHTML = `
        <strong>ğŸ“Š ZnamÃ©nkovÃ¡ matice S[i,j] = A[i,j] - A[j,i]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>S[i,j] > 0:</strong> VÃ­ce hran z i do j neÅ¾ z j do i<br>
            â€¢ <strong>S[i,j] < 0:</strong> VÃ­ce hran z j do i neÅ¾ z i do j<br>
            â€¢ <strong>S[i,j] = 0:</strong> Symetricky nebo bez hran<br>
            â€¢ <strong>ZjiÅ¡Å¥ujeÅ¡:</strong> Asymetrii a vyvÃ¡Å¾enÃ­ smÄ›rÅ¯ v grafu
        </div>
    `;
    signSection.appendChild(signLegendDiv);
    
    signSection.appendChild(createQuerySection('Dotaz na hodnotu', 'sign'));
    
    const showSignBtn = document.createElement('button');
    showSignBtn.textContent = 'Zobrazit celou matici';
    const signMatrixDiv = document.createElement('div');
    signMatrixDiv.className = 'matrix';
    signMatrixDiv.style.display = 'none';
    const signStatsDiv = document.createElement('div');
    signStatsDiv.style.display = 'none';
    signStatsDiv.style.marginTop = '1rem';
    signStatsDiv.style.padding = '1rem';
    signStatsDiv.className = 'info-box';
    signStatsDiv.style.backgroundColor = '#e7f3ff';
    signStatsDiv.style.borderRadius = '0.25rem';
    
    showSignBtn.addEventListener('click', () => {
        if (signMatrixDiv.style.display === 'none') {
            const signMat = graph.signMatrix();
            signMatrixDiv.innerHTML = '';
            signMatrixDiv.appendChild(createMatrixTable(signMat, graph.nodes, graph.nodes));
            
            const stats = calculateMatrixStats(signMat, graph.nodes, graph.nodes);
            signStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });
            
            signMatrixDiv.style.display = 'block';
            signStatsDiv.style.display = 'block';
            showSignBtn.textContent = 'SkrÃ½t matici';
        } else {
            signMatrixDiv.style.display = 'none';
            signStatsDiv.style.display = 'none';
            showSignBtn.textContent = 'Zobrazit celou matici';
        }
    });
    signSection.appendChild(showSignBtn);
    signSection.appendChild(signMatrixDiv);
    signSection.appendChild(signStatsDiv);
    output.appendChild(signSection);

    // Laplacian matrix with query
    const laplacianSection = document.createElement('div');
    laplacianSection.className = 'section';
    laplacianSection.innerHTML = '<h2>LaplaciÃ¡nskÃ¡ matice (L = D - A)</h2>';
    
    // PÅ™idej vysvÄ›tlivku
    const laplacianLegendDiv = document.createElement('div');
    laplacianLegendDiv.className = 'info-box';
    laplacianLegendDiv.style.backgroundColor = '#e7f3ff';
    laplacianLegendDiv.style.padding = '0.75rem';
    laplacianLegendDiv.style.borderRadius = '0.25rem';
    laplacianLegendDiv.style.marginBottom = '1rem';
    laplacianLegendDiv.style.border = '1px solid #0d6efd';
    
    // âš¡ DYNAMICKÃ vysvÄ›tlivka podle typu grafu
    const isDirected = props.oriented === 'orientovanÃ½';
    laplacianLegendDiv.innerHTML = `
        <strong>ğŸ“Š LaplaciÃ¡nskÃ¡ matice L = D - A:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>L[U,V] = 0:</strong> Uzly U a V nejsou spojeny<br>
            â€¢ <strong>L[U,V] = -1:</strong> Uzly U a V jsou pÅ™Ã­mo spojeny hranou<br>
            â€¢ <strong>L[U,U]:</strong> ${isDirected ? '<strong style="color: #0d6efd;">VÃ½stupnÃ­ stupeÅˆ</strong> (poÄet hran VYCHÃZEJÃCÃCH z U)' : '<strong>StupeÅˆ uzlu</strong> (poÄet hran dotÃ½kajÃ­cÃ­ch se U)'}<br>
            â€¢ <strong>Vlastnost:</strong> SouÄet kaÅ¾dÃ©ho Å™Ã¡dku = 0
        </div>
    `;
    laplacianSection.appendChild(laplacianLegendDiv);
    
    laplacianSection.appendChild(createQuerySection('Dotaz na hodnotu L[U,V]', 'laplacian'));
    
    const showLaplacianBtn = document.createElement('button');
    showLaplacianBtn.textContent = 'Zobrazit celou matici';
    const laplacianMatrixDiv = document.createElement('div');
    laplacianMatrixDiv.className = 'matrix';
    laplacianMatrixDiv.style.display = 'none';
    const laplacianStatsDiv = document.createElement('div');
    laplacianStatsDiv.style.display = 'none';
    laplacianStatsDiv.style.marginTop = '1rem';
    laplacianStatsDiv.style.padding = '1rem';
    laplacianStatsDiv.className = 'info-box';
    laplacianStatsDiv.style.backgroundColor = '#e7f3ff';
    laplacianStatsDiv.style.borderRadius = '0.25rem';
    
    showLaplacianBtn.addEventListener('click', () => {
        if (laplacianMatrixDiv.style.display === 'none') {
            const laplacianMat = graph.laplacianMatrix();
            laplacianMatrixDiv.innerHTML = '';
            laplacianMatrixDiv.appendChild(createMatrixTable(laplacianMat, graph.nodes, graph.nodes));

            const stats = calculateMatrixStats(laplacianMat, graph.nodes, graph.nodes);
            laplacianStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });

            laplacianMatrixDiv.style.display = 'block';
            laplacianStatsDiv.style.display = 'block';
            showLaplacianBtn.textContent = 'SkrÃ½t matici';
        } else {
            laplacianMatrixDiv.style.display = 'none';
            laplacianStatsDiv.style.display = 'none';
            showLaplacianBtn.textContent = 'Zobrazit celou matici';
        }
    });
    laplacianSection.appendChild(showLaplacianBtn);
    laplacianSection.appendChild(laplacianMatrixDiv);
    laplacianSection.appendChild(laplacianStatsDiv);
    output.appendChild(laplacianSection);

    // Multiplicity query section
    const multiplicitySection = document.createElement('div');
    multiplicitySection.className = 'section';
    multiplicitySection.innerHTML = '<h2>Multiplicita hran (poÄet paralelnÃ­ch hran)</h2>';
    
    // PÅ™idej vysvÄ›tlivku
    const multiplicityLegendDiv = document.createElement('div');
    multiplicityLegendDiv.className = 'info-box';
    multiplicityLegendDiv.style.backgroundColor = '#e7f3ff';
    multiplicityLegendDiv.style.padding = '0.75rem';
    multiplicityLegendDiv.style.borderRadius = '0.25rem';
    multiplicityLegendDiv.style.marginBottom = '1rem';
    multiplicityLegendDiv.style.border = '1px solid #0d6efd';
    multiplicityLegendDiv.innerHTML = `
        <strong>ğŸ“Š Multiplicita hran:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>Multiplicita = 1:</strong> PrÃ¡vÄ› 1 hrana (nebo vÃ­ce v jednom smÄ›ru)<br>
            â€¢ <strong>Multiplicita > 1:</strong> VÃ­ce paralelnÃ­ch hran (multigraf)<br>
            â€¢ <strong>PoÄÃ­tÃ¡ obÄ› strany:</strong> Hrany Uâ†’V a Vâ†’U se sÄÃ­tajÃ­<br>
            â€¢ <strong>Bez ohledu na vÃ¡hu:</strong> PoÄÃ­tÃ¡ jen existenci hran, ne jejich vÃ¡hu
        </div>
    `;
    multiplicitySection.appendChild(multiplicityLegendDiv);
    
    multiplicitySection.appendChild(createQuerySection('Dotaz na multiplicitu', 'multiplicity'));
    output.appendChild(multiplicitySection);

    // Power matrices with queries
    const powerSection = document.createElement('div');
    powerSection.className = 'section';
    powerSection.innerHTML = '<h2>DruhÃ¡ a tÅ™etÃ­ mocnina matice sousednosti (poÄet sledÅ¯ dÃ©lky N)</h2>';
    
    // PÅ™idej legend
    const powerLegendDiv = document.createElement('div');
    powerLegendDiv.className = 'info-box';
    powerLegendDiv.style.backgroundColor = '#e7f3ff';
    powerLegendDiv.style.padding = '0.75rem';
    powerLegendDiv.style.borderRadius = '0.25rem';
    powerLegendDiv.style.marginBottom = '1rem';
    powerLegendDiv.style.border = '1px solid #0d6efd';
    powerLegendDiv.innerHTML = `
        <strong>ğŸ“Š Mocnina matice A<sup>k</sup>[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>A<sup>k</sup>[i,j] = ÄÃ­slo:</strong> PoÄet prochÃ¡zek dÃ©lky k z i do j<br>
            â€¢ <strong>AÂ²:</strong> Cesty s 2 hranami (zprostÅ™edkovanÃ­ sousedÃ©)<br>
            â€¢ <strong>AÂ³:</strong> Cesty s 3 hranami atd.<br>
            â€¢ <strong>ZjiÅ¡Å¥ujeÅ¡:</strong> Kolik zpÅ¯sobÅ¯ jÃ­t z i do j pÅ™esnÄ› k kroky
        </div>
    `;
    powerSection.appendChild(powerLegendDiv);
    
    powerSection.appendChild(createQuerySection('Dotaz na AÂ²', 'power2'));
    powerSection.appendChild(createQuerySection('Dotaz na AÂ³', 'power3'));
    
    // Custom power query section
    const customPowerDiv = document.createElement('div');
    customPowerDiv.className = 'query-section';
    customPowerDiv.innerHTML = '<h3>LibovolnÃ¡ mocnina matice sousednosti</h3>';
    
    // Add legend
    const customPowerLegendDiv = document.createElement('div');
    customPowerLegendDiv.className = 'warning-box';
    customPowerLegendDiv.style.backgroundColor = '#fff3cd';
    customPowerLegendDiv.style.padding = '0.75rem';
    customPowerLegendDiv.style.borderRadius = '0.25rem';
    customPowerLegendDiv.style.marginBottom = '1rem';
    customPowerLegendDiv.style.border = '1px solid #ffc107';
    customPowerLegendDiv.innerHTML = `
        <strong>ğŸ“– VysvÄ›tlenÃ­:</strong><br>
        <span style="margin-left: 1rem;">â€¢ <strong>A<sup>k</sup>[u, v]</strong> udÃ¡vÃ¡ poÄet cest <strong>dÃ©lky k</strong> z uzlu <strong>u</strong> do uzlu <strong>v</strong></span><br>
        <span style="margin-left: 1rem;">â€¢ NapÅ™Ã­klad A<sup>3</sup>[A, C] = 5 znamenÃ¡, Å¾e existuje <strong>5 rÅ¯znÃ½ch cest dÃ©lky 3</strong> z uzlu A do uzlu C</span><br>
        <span style="margin-left: 1rem;">â€¢ DÃ©lka cesty = poÄet hran v cestÄ› (ne poÄet uzlÅ¯!)</span>
    `;
    customPowerDiv.appendChild(customPowerLegendDiv);
    
    const customPowerInputDiv = document.createElement('div');
    customPowerInputDiv.className = 'query-inputs';

    const powerDatalist = document.createElement('datalist');
    powerDatalist.id = 'nodes-datalist-power';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        powerDatalist.appendChild(option);
    });
    customPowerDiv.appendChild(powerDatalist);

    const selectPowerU = document.createElement('input');
    selectPowerU.setAttribute('list', 'nodes-datalist-power');
    const selectPowerV = document.createElement('input');
    selectPowerV.setAttribute('list', 'nodes-datalist-power');
    
    const powerInput = document.createElement('input');
    powerInput.type = 'number';
    powerInput.min = '1';
    powerInput.max = '20';
    powerInput.value = '4';
    powerInput.style.width = '80px';
    powerInput.style.padding = '0.5rem';
    powerInput.style.border = '1px solid #ced4da';
    powerInput.style.borderRadius = '0.25rem';
    
    const customPowerBtn = document.createElement('button');
    customPowerBtn.textContent = 'VypoÄÃ­tat';
    
    const customPowerResultDiv = document.createElement('div');
    customPowerResultDiv.className = 'query-result';
    customPowerResultDiv.style.display = 'none';
    
    customPowerBtn.addEventListener('click', () => {
        const u = selectPowerU.value;
        const v = selectPowerV.value;
        const k = parseInt(powerInput.value);
        
        if (k < 1 || k > 20) {
            customPowerResultDiv.textContent = 'Mocnina musÃ­ bÃ½t mezi 1 a 20';
            customPowerResultDiv.style.display = 'block';
            return;
        }
        
        customPowerBtn.disabled = true;
        customPowerBtn.textContent = 'PoÄÃ­tÃ¡m...';
        
        setTimeout(() => {
            const result = graph.adjacencyPowerValue(u, v, k);
            customPowerResultDiv.textContent = `A^${k}[${u}, ${v}] = ${result}`;
            customPowerResultDiv.style.display = 'block';
            customPowerBtn.disabled = false;
            customPowerBtn.textContent = 'VypoÄÃ­tat';
        }, 50);
    });
    
    const labelPowerU = document.createElement('span');
    labelPowerU.textContent = 'Od uzlu: ';
    customPowerInputDiv.appendChild(labelPowerU);
    customPowerInputDiv.appendChild(selectPowerU);
    
    const labelPowerV = document.createElement('span');
    labelPowerV.textContent = ' Do uzlu: ';
    customPowerInputDiv.appendChild(labelPowerV);
    customPowerInputDiv.appendChild(selectPowerV);
    
    const labelPower = document.createElement('span');
    labelPower.textContent = ' Mocnina: ';
    customPowerInputDiv.appendChild(labelPower);
    customPowerInputDiv.appendChild(powerInput);
    customPowerInputDiv.appendChild(customPowerBtn);
    
    customPowerDiv.appendChild(customPowerInputDiv);
    customPowerDiv.appendChild(customPowerResultDiv);
    powerSection.appendChild(customPowerDiv);
    
    const showPowerBtn = document.createElement('button');
    showPowerBtn.textContent = 'Zobrazit celÃ© matice';
    const powerMatrixDiv = document.createElement('div');
    powerMatrixDiv.style.display = 'none';
    const powerStatsDiv = document.createElement('div');
    powerStatsDiv.style.display = 'none';
    powerStatsDiv.style.marginTop = '1rem';

    showPowerBtn.addEventListener('click', () => {
        if (powerMatrixDiv.style.display === 'none') {
            const A2 = graph.adjacencyPower(2);
            const A3 = graph.adjacencyPower(3);
            powerMatrixDiv.innerHTML = '<h3>AÂ²</h3>';
            const div2 = document.createElement('div');
            div2.className = 'matrix';
            div2.appendChild(createMatrixTable(A2, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div2);
            powerMatrixDiv.innerHTML += '<h3>AÂ³</h3>';
            const div3 = document.createElement('div');
            div3.className = 'matrix';
            div3.appendChild(createMatrixTable(A3, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div3);

            const stats2 = calculateMatrixStats(A2, graph.nodes, graph.nodes);
            const stats3 = calculateMatrixStats(A3, graph.nodes, graph.nodes);
            powerStatsDiv.innerHTML = `
                <div style="padding: 1rem; background-color: #e7f3ff; border-radius: 0.25rem;">
                    ${createMatrixStatsHTML(stats2, { showRowColSums: true })}
                </div>
                <div style="margin-top: 1rem; padding: 1rem; background-color: #e7f3ff; border-radius: 0.25rem;">
                    ${createMatrixStatsHTML(stats3, { showRowColSums: true })}
                </div>
            `;

            powerMatrixDiv.style.display = 'block';
            powerStatsDiv.style.display = 'block';
            showPowerBtn.textContent = 'SkrÃ½t matice';
        } else {
            powerMatrixDiv.style.display = 'none';
            powerStatsDiv.style.display = 'none';
            showPowerBtn.textContent = 'Zobrazit celÃ© matice';
        }
    });
    powerSection.appendChild(showPowerBtn);
    powerSection.appendChild(powerMatrixDiv);
    powerSection.appendChild(powerStatsDiv);
    output.appendChild(powerSection);

    // Sum of walks query section
    const sumWalksSection = document.createElement('div');
    sumWalksSection.className = 'section';
    sumWalksSection.innerHTML = '<h2>Suma vÅ¡ech prochÃ¡zek (âˆ‘ AÂ¹ + AÂ² + ... + Aáµ)</h2>';
    
    const sumWalksDiv = document.createElement('div');
    sumWalksDiv.className = 'query-section';
    sumWalksDiv.innerHTML = '<h3>Dotaz na celkovÃ½ poÄet prochÃ¡zek dÃ©lek 1 aÅ¾ k</h3>';
    
    // Add legend
    const sumWalksLegendDiv = document.createElement('div');
    sumWalksLegendDiv.className = 'info-box';
    sumWalksLegendDiv.style.backgroundColor = '#e7f3ff';
    sumWalksLegendDiv.style.padding = '0.75rem';
    sumWalksLegendDiv.style.borderRadius = '0.25rem';
    sumWalksLegendDiv.style.marginBottom = '1rem';
    sumWalksLegendDiv.style.border = '1px solid #0d6efd';
    sumWalksLegendDiv.innerHTML = `
        <strong>ğŸ“Š VysvÄ›tlenÃ­:</strong><br>
        <span style="margin-left: 1rem;">â€¢ SeÄte poÄet vÅ¡ech prochÃ¡zek dÃ©lek 1, 2, 3, ..., aÅ¾ k mezi uzly U a V</span><br>
        <span style="margin-left: 1rem;">â€¢ NapÅ™. pro k=3: poÄÃ­tÃ¡ cesty dÃ©lky 1 + cesty dÃ©lky 2 + cesty dÃ©lky 3</span><br>
        <span style="margin-left: 1rem;">â€¢ UÅ¾iteÄnÃ© pro analÃ½zu celkovÃ© propojitelnosti uzlÅ¯</span>
    `;
    sumWalksDiv.appendChild(sumWalksLegendDiv);
    
    const sumWalksInputDiv = document.createElement('div');
    sumWalksInputDiv.className = 'query-inputs';

    const sumDatalist = document.createElement('datalist');
    sumDatalist.id = 'nodes-datalist-sum';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        sumDatalist.appendChild(option);
    });
    sumWalksDiv.appendChild(sumDatalist);

    const selectSumU = document.createElement('input');
    selectSumU.setAttribute('list', 'nodes-datalist-sum');
    const selectSumV = document.createElement('input');
    selectSumV.setAttribute('list', 'nodes-datalist-sum');
    
    const sumKInput = document.createElement('input');
    sumKInput.type = 'number';
    sumKInput.min = '1';
    sumKInput.max = '10';
    sumKInput.value = '3';
    sumKInput.style.width = '80px';
    sumKInput.style.padding = '0.5rem';
    sumKInput.style.border = '1px solid #ced4da';
    sumKInput.style.borderRadius = '0.25rem';
    
    const sumWalksBtn = document.createElement('button');
    sumWalksBtn.textContent = 'VypoÄÃ­tat';
    
    const sumWalksResultDiv = document.createElement('div');
    sumWalksResultDiv.className = 'query-result';
    sumWalksResultDiv.style.display = 'none';
    
    sumWalksBtn.addEventListener('click', () => {
        const u = selectSumU.value;
        const v = selectSumV.value;
        const k = parseInt(sumKInput.value);
        
        if (k < 1 || k > 10) {
            sumWalksResultDiv.textContent = 'Hodnota k musÃ­ bÃ½t mezi 1 a 10';
            sumWalksResultDiv.style.display = 'block';
            return;
        }
        
        sumWalksBtn.disabled = true;
        sumWalksBtn.textContent = 'PoÄÃ­tÃ¡m...';
        
        setTimeout(() => {
            const result = graph.sumWalksValue(u, v, k);
            sumWalksResultDiv.innerHTML = `âˆ‘ prochÃ¡zek (dÃ©lky 1..${k}) z <strong>${u}</strong> do <strong>${v}</strong>: <strong>${result}</strong><br>
                <small>CelkovÃ½ poÄet vÅ¡ech cest dÃ©lek 1 aÅ¾ ${k}</small>`;
            sumWalksResultDiv.style.display = 'block';
            sumWalksBtn.disabled = false;
            sumWalksBtn.textContent = 'VypoÄÃ­tat';
        }, 50);
    });
    
    const labelSumU = document.createElement('span');
    labelSumU.textContent = 'Od uzlu: ';
    sumWalksInputDiv.appendChild(labelSumU);
    sumWalksInputDiv.appendChild(selectSumU);
    
    const labelSumV = document.createElement('span');
    labelSumV.textContent = ' Do uzlu: ';
    sumWalksInputDiv.appendChild(labelSumV);
    sumWalksInputDiv.appendChild(selectSumV);
    
    const labelSumK = document.createElement('span');
    labelSumK.textContent = ' Max. dÃ©lka k: ';
    sumWalksInputDiv.appendChild(labelSumK);
    sumWalksInputDiv.appendChild(sumKInput);
    sumWalksInputDiv.appendChild(sumWalksBtn);
    
    sumWalksDiv.appendChild(sumWalksInputDiv);
    sumWalksDiv.appendChild(sumWalksResultDiv);
    sumWalksSection.appendChild(sumWalksDiv);
    output.appendChild(sumWalksSection);

    // Incidence matrix with signed/unsigned toggle
    const incSection = document.createElement('div');
    incSection.className = 'section';
    incSection.innerHTML = '<h2>Matice incidence</h2>';
    
    const incLegendDiv = document.createElement('div');
    incLegendDiv.className = 'info-box';
    incLegendDiv.style.backgroundColor = '#e7f3ff';
    incLegendDiv.style.padding = '0.75rem';
    incLegendDiv.style.borderRadius = '0.25rem';
    incLegendDiv.style.marginBottom = '1rem';
    incLegendDiv.style.border = '1px solid #0d6efd';
    incLegendDiv.innerHTML = `
        <strong>ï¿½ Matice incidence:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>-1 v Å™Ã¡dku:</strong> Uzel je ocas orientovanÃ© hrany (vÃ½chozÃ­)<br>
            â€¢ <strong>+1 v Å™Ã¡dku:</strong> Uzel je hlava orientovanÃ© hrany (cÃ­lovÃ½)<br>
            â€¢ <strong>1 v Å™Ã¡dku (obojÃ­):</strong> Uzel je incidentnÃ­ s neorientovanou hranou<br>
            â€¢ <strong>0 v Å™Ã¡dku:</strong> Uzel nenÃ­ incidentnÃ­ s touto hranou
        </div>
    `;
    incSection.appendChild(incLegendDiv);
    
    const incToggleDiv = document.createElement('div');
    incToggleDiv.style.marginBottom = '1rem';
    incToggleDiv.innerHTML = '<label><input type="checkbox" id="incSigned" checked /> PodepsanÃ¡ (signed)</label>';
    incSection.appendChild(incToggleDiv);
    
    const showIncBtn = document.createElement('button');
    showIncBtn.textContent = 'Zobrazit matici';
    const incMatrixDiv = document.createElement('div');
    incMatrixDiv.className = 'matrix';
    incMatrixDiv.style.display = 'none';
    
    showIncBtn.addEventListener('click', () => {
        if (incMatrixDiv.style.display === 'none') {
            const signed = document.getElementById('incSigned').checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
            incMatrixDiv.style.display = 'block';
            showIncBtn.textContent = 'SkrÃ½t matici';
        } else {
            incMatrixDiv.style.display = 'none';
            showIncBtn.textContent = 'Zobrazit matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'incSigned' && incMatrixDiv.style.display === 'block') {
            const signed = e.target.checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
        }
    });
    
    incSection.appendChild(showIncBtn);
    incSection.appendChild(incMatrixDiv);
    output.appendChild(incSection);

    // Reachability matrix (transitive closure)
    const reachSection = document.createElement('div');
    reachSection.className = 'section';
    reachSection.innerHTML = '<h2>DosaÅ¾itelnost (transitivnÃ­ uzÃ¡vÄ›r)</h2>';
    
    const reachLegendDiv = document.createElement('div');
    reachLegendDiv.className = 'info-box';
    reachLegendDiv.style.backgroundColor = '#e7f3ff';
    reachLegendDiv.style.padding = '0.75rem';
    reachLegendDiv.style.borderRadius = '0.25rem';
    reachLegendDiv.style.marginBottom = '1rem';
    reachLegendDiv.style.border = '1px solid #0d6efd';
    reachLegendDiv.innerHTML = `
        <strong>ğŸ”„ DosaÅ¾itelnost R[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>R[i,j] = 1:</strong> Uzel j je dosaÅ¾itelnÃ½ z i (existuje cesta)<br>
            â€¢ <strong>R[i,j] = 0:</strong> Uzel j NENÃ dosaÅ¾itelnÃ½ z i<br>
            â€¢ <strong>R[i,i] = 1:</strong> VÅ¾dy (uzel dosÃ¡hne sÃ¡m sebe)<br>
            â€¢ <strong>VyuÅ¾itÃ­:</strong> ZjiÅ¡tÄ›nÃ­ komponent a souvislosti
        </div>
    `;
    reachSection.appendChild(reachLegendDiv);
    
    // Query interface
    const reachQueryDiv = document.createElement('div');
    reachQueryDiv.className = 'query-section';
    reachQueryDiv.innerHTML = '<h3>Dotaz na dosaÅ¾itelnost</h3>';
    
    const reachInputDiv = document.createElement('div');
    reachInputDiv.className = 'query-inputs';
    
    const inputReachU = document.createElement('input');
    inputReachU.type = 'text';
    inputReachU.placeholder = 'Zadejte uzel (napÅ™. A)';
    inputReachU.style.width = '120px';
    inputReachU.style.padding = '0.5rem';
    inputReachU.style.border = '1px solid #ced4da';
    inputReachU.style.borderRadius = '0.25rem';
    
    const inputReachV = document.createElement('input');
    inputReachV.type = 'text';
    inputReachV.placeholder = 'Zadejte uzel (napÅ™. B)';
    inputReachV.style.width = '120px';
    inputReachV.style.padding = '0.5rem';
    inputReachV.style.border = '1px solid #ced4da';
    inputReachV.style.borderRadius = '0.25rem';
    
    const reachQueryBtn = document.createElement('button');
    reachQueryBtn.textContent = 'Je dosaÅ¾itelnÃ½?';
    
    const reachQueryResult = document.createElement('div');
    reachQueryResult.className = 'query-result';
    reachQueryResult.style.display = 'none';
    
    reachQueryBtn.addEventListener('click', () => {
        const u = inputReachU.value.trim();
        const v = inputReachV.value.trim();
        
        if (!u || !v) {
            reachQueryResult.innerHTML = `<strong>âš ï¸ Chyba:</strong> Zadejte oba uzly`;
            reachQueryResult.style.display = 'block';
            return;
        }
        
        const uIdx = graph.nodes.indexOf(u);
        const vIdx = graph.nodes.indexOf(v);
        
        if (uIdx === -1 || vIdx === -1) {
            const invalidNodes = [];
            if (uIdx === -1) invalidNodes.push(`"${u}"`);
            if (vIdx === -1) invalidNodes.push(`"${v}"`);
            reachQueryResult.innerHTML = `<strong>âš ï¸ Chyba:</strong> Uzel ${invalidNodes.join(' a ')} neexistuje v grafu. DostupnÃ© uzly: ${graph.nodes.join(', ')}`;
            reachQueryResult.style.display = 'block';
            return;
        }
        
        const reachMat = graph.reachability();
        const isReachable = reachMat[uIdx][vIdx] === 1;
        
        reachQueryResult.innerHTML = `<strong>${u} â†’ ${v}:</strong> ${isReachable ? 'âœ… ANO (dosaÅ¾itelnÃ½)' : 'âŒ NE (nedosaÅ¾itelnÃ½)'}`;
        reachQueryResult.style.display = 'block';
    });
    
    const labelReachU = document.createElement('span');
    labelReachU.textContent = 'Z uzlu: ';
    reachInputDiv.appendChild(labelReachU);
    reachInputDiv.appendChild(inputReachU);
    
    const labelReachV = document.createElement('span');
    labelReachV.textContent = ' Do uzlu: ';
    reachInputDiv.appendChild(labelReachV);
    reachInputDiv.appendChild(inputReachV);
    reachInputDiv.appendChild(reachQueryBtn);
    
    reachQueryDiv.appendChild(reachInputDiv);
    reachQueryDiv.appendChild(reachQueryResult);
    reachSection.appendChild(reachQueryDiv);
    
    // Statistics button
    const showReachStatsBtn = document.createElement('button');
    showReachStatsBtn.textContent = 'Zobrazit statistiky dosaÅ¾itelnosti';
    showReachStatsBtn.style.marginTop = '1rem';
    const reachStatsDiv = document.createElement('div');
    reachStatsDiv.style.display = 'none';
    reachStatsDiv.style.marginTop = '1rem';
    
    showReachStatsBtn.addEventListener('click', () => {
        if (reachStatsDiv.style.display === 'none') {
            const reachMat = graph.reachability();
            const n = graph.nodes.length;
            const components = graph.getComponents();
            
            // Calculate statistics
            const reachableFrom = {}; // kolik uzlÅ¯ je dosaÅ¾itelnÃ½ch z kaÅ¾dÃ©ho uzlu
            const reachableBy = {};   // z kolika uzlÅ¯ je kaÅ¾dÃ½ uzel dosaÅ¾itelnÃ½
            let totalReachable = 0;
            
            for (let i = 0; i < n; i++) {
                reachableFrom[graph.nodes[i]] = 0;
                reachableBy[graph.nodes[i]] = 0;
            }
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j && reachMat[i][j] === 1) {
                        reachableFrom[graph.nodes[i]]++;
                        reachableBy[graph.nodes[j]]++;
                        totalReachable++;
                    }
                }
            }
            
            const maxPossible = n * (n - 1);
            const reachabilityPercent = ((totalReachable / maxPossible) * 100).toFixed(1);
            
            // Isolated nodes (cannot reach anyone, no one can reach them)
            const isolated = graph.nodes.filter(node => 
                reachableFrom[node] === 0 && reachableBy[node] === 0
            );
            
            reachStatsDiv.innerHTML = `
                <div style="background-color: #f8f9fa; padding: 1rem; border-radius: 0.25rem; border: 1px solid #dee2e6;">
                    <h3 style="margin-top: 0; color: #0d6efd;">ğŸ“ˆ Statistiky dosaÅ¾itelnosti a komponent</h3>
                    
                    <div class="stats-card" style="background-color: white; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem;">
                        <strong>CelkovÃ¡ dosaÅ¾itelnost:</strong><br>
                        â€¢ <strong>${totalReachable}</strong> z ${maxPossible} moÅ¾nÃ½ch spojenÃ­ (${reachabilityPercent}%)<br>
                        â€¢ PrÅ¯mÄ›rnÄ› kaÅ¾dÃ½ uzel dosÃ¡hne <strong>${(totalReachable / n).toFixed(1)}</strong> uzlÅ¯<br>
                        â€¢ Graf mÃ¡ <strong>${components.length}</strong> ${components.length === 1 ? 'komponentu' : components.length < 5 ? 'komponenty' : 'komponent'}
                    </div>
                    
                    ${isolated.length > 0 ? `
                    <div style="background-color: #fff3cd; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem; border: 1px solid #ffc107;">
                        <strong>âš ï¸ IzolovanÃ© uzly (${isolated.length}):</strong><br>
                        <span style="font-size: 0.9rem;">Tyto uzly nemajÃ­ Å¾Ã¡dnÃ© spojenÃ­ s ostatnÃ­mi:</span><br>
                        <code style="background-color: #fff; padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: inline-block; margin-top: 0.25rem;">
                            ${isolated.slice(0, 30).join(', ')}${isolated.length > 30 ? ` ... a dalÅ¡Ã­ch ${isolated.length - 30}` : ''}
                        </code>
                    </div>
                    ` : ''}
                    
                    <div class="stats-card" style="background-color: white; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem;">
                        <strong>ğŸ”— Komponenty grafu (${components.length}):</strong><br>
                        <span style="font-size: 0.9rem; color: #666;">KaÅ¾dÃ¡ komponenta mÃ¡ reprezentanta (koÅ™enovÃ½ uzel) - pouÅ¾ij ho pro BFS:</span><br>
                        <div style="margin-top: 0.5rem;">
                            ${components.map((comp, idx) => `
                                <div style="background-color: ${idx % 2 === 0 ? '#f8f9fa' : '#fff'}; padding: 0.5rem; margin-top: 0.25rem; border-radius: 0.25rem; border-left: 3px solid ${idx === 0 ? '#0d6efd' : idx === 1 ? '#198754' : '#dc3545'};">
                                    <strong>Komponenta ${idx + 1}</strong> (${comp.size} ${comp.size === 1 ? 'uzel' : comp.size < 5 ? 'uzly' : 'uzlÅ¯'}):
                                    <br>
                                    <span style="font-size: 0.9rem;">
                                        ğŸ¯ <strong>Reprezentant (root):</strong> <code style="background-color: #e7f3ff; padding: 0.1rem 0.4rem; border-radius: 0.2rem; font-weight: bold;">${comp.root}</code>
                                        ${comp.size <= 20 ? `<br>ğŸ“¦ Uzly: ${comp.nodes.join(', ')}` : `<br>ğŸ“¦ PrvnÃ­ uzly: ${comp.nodes.slice(0, 20).join(', ')} ... (celkem ${comp.size})`}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            reachStatsDiv.style.display = 'block';
            showReachStatsBtn.textContent = 'SkrÃ½t statistiky';
        } else {
            reachStatsDiv.style.display = 'none';
            showReachStatsBtn.textContent = 'Zobrazit statistiky dosaÅ¾itelnosti';
        }
    });
    
    reachSection.appendChild(showReachStatsBtn);
    reachSection.appendChild(reachStatsDiv);
    
    // Full matrix (only for small graphs)
    if (graph.nodes.length <= 50) {
        const showReachMatrixBtn = document.createElement('button');
        showReachMatrixBtn.textContent = 'Zobrazit celou matici';
        showReachMatrixBtn.style.marginTop = '0.5rem';
        const reachMatrixDiv = document.createElement('div');
        reachMatrixDiv.className = 'matrix';
        reachMatrixDiv.style.display = 'none';
        
        showReachMatrixBtn.addEventListener('click', () => {
            if (reachMatrixDiv.style.display === 'none') {
                const reachMat = graph.reachability();
                reachMatrixDiv.innerHTML = '';
                reachMatrixDiv.appendChild(createMatrixTable(reachMat, graph.nodes, graph.nodes));
                reachMatrixDiv.style.display = 'block';
                showReachMatrixBtn.textContent = 'SkrÃ½t matici';
            } else {
                reachMatrixDiv.style.display = 'none';
                showReachMatrixBtn.textContent = 'Zobrazit celou matici';
            }
        });
        
        reachSection.appendChild(showReachMatrixBtn);
        reachSection.appendChild(reachMatrixDiv);
    } else {
        const warningDiv = document.createElement('div');
        warningDiv.style.marginTop = '1rem';
        warningDiv.style.padding = '0.75rem';
        warningDiv.className = 'warning-box';
        warningDiv.style.backgroundColor = '#fff3cd';
        warningDiv.style.borderRadius = '0.25rem';
        warningDiv.style.border = '1px solid #ffc107';
        warningDiv.innerHTML = `
            <strong>â„¹ï¸ PoznÃ¡mka:</strong> Graf mÃ¡ ${graph.nodes.length} uzlÅ¯ - matice ${graph.nodes.length}Ã—${graph.nodes.length} by byla nepÅ™ehlednÃ¡. 
            PouÅ¾ijte dotaz nebo statistiky vÃ½Å¡e.
        `;
        reachSection.appendChild(warningDiv);
    }
    
    output.appendChild(reachSection);

    // BFS Layers
    const bfsSection = document.createElement('div');
    bfsSection.className = 'section';
    bfsSection.innerHTML = '<h2>BFS Vrstvy (Breadth-First Search Layers)</h2>';
    
    const bfsLegendDiv = document.createElement('div');
    bfsLegendDiv.className = 'info-box';
    bfsLegendDiv.style.backgroundColor = '#e7f3ff';
    bfsLegendDiv.style.padding = '0.75rem';
    bfsLegendDiv.style.borderRadius = '0.25rem';
    bfsLegendDiv.style.marginBottom = '1rem';
    bfsLegendDiv.style.border = '1px solid #0d6efd';
    bfsLegendDiv.innerHTML = `
        <strong>ğŸŒŠ BFS vrstvy:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>Vrstva 0:</strong> StartovnÃ­ uzel<br>
            â€¢ <strong>Vrstva k:</strong> Uzly dostupnÃ© v k krocÃ­ch ze startu<br>
            â€¢ <strong>KaÅ¾dÃ½ uzel:</strong> ObjevÃ­ se prÃ¡vÄ› v jednÃ© vrstvÄ›<br>
            â€¢ <strong>UÅ¾itÃ­:</strong> VzdÃ¡lenost od start, komponenty, Å¡Ã­Å™enÃ­ informace
        </div>
    `;
    bfsSection.appendChild(bfsLegendDiv);
    
    const bfsControlDiv = document.createElement('div');
    bfsControlDiv.style.marginBottom = '1rem';
    bfsControlDiv.innerHTML = '<label>StartovnÃ­ uzel: <input id="bfsStart" list="nodes-datalist-bfs"></label> <button id="bfsBtn" class="btn" style="margin-left: 0.5rem;">SpoÄÃ­tat vrstvy</button>';
    bfsSection.appendChild(bfsControlDiv);

    const bfsDatalist = document.createElement('datalist');
    bfsDatalist.id = 'nodes-datalist-bfs';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        bfsDatalist.appendChild(option);
    });
    bfsSection.appendChild(bfsDatalist);

    const bfsResultDiv = document.createElement('div');
    bfsResultDiv.className = 'scroll';
    bfsResultDiv.style.display = 'none';
    bfsSection.appendChild(bfsResultDiv);
    
    bfsControlDiv.querySelector('#bfsBtn').addEventListener('click', () => {
        const bfsStartSelect = document.getElementById('bfsStart');
        const start = bfsStartSelect.value;
        const layers = graph.bfsLayers(start);
        let html = '<h4>Vrstvy uzlÅ¯:</h4>';
        for (const [k, nodes] of Object.entries(layers)) {
            html += `<div style="margin: 0.5rem 0;"><strong>Vrstva ${k}:</strong> ${nodes.join(', ')}</div>`;
        }
        bfsResultDiv.innerHTML = html;
        bfsResultDiv.style.display = 'block';
    });
    
    output.appendChild(bfsSection);

    // All shortest paths (unweighted)
    const allPathsSection = document.createElement('div');
    allPathsSection.className = 'section';
    allPathsSection.innerHTML = '<h2>VÅ¡echny nejkratÅ¡Ã­ cesty (neohodnocenÃ©)</h2>';
    
    const allPathsLegendDiv = document.createElement('div');
    allPathsLegendDiv.className = 'info-box';
    allPathsLegendDiv.style.backgroundColor = '#e7f3ff';
    allPathsLegendDiv.style.padding = '0.75rem';
    allPathsLegendDiv.style.borderRadius = '0.25rem';
    allPathsLegendDiv.style.marginBottom = '1rem';
    allPathsLegendDiv.style.border = '1px solid #0d6efd';
    allPathsLegendDiv.innerHTML = `
        <strong>ğŸ›¤ï¸ VÅ¡echny nejkratÅ¡Ã­ cesty:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>Najde VÅ ECHNY:</strong> Cesty stejnÃ© dÃ©lky mezi U a V<br>
            â€¢ <strong>Algoritmus:</strong> BFS (dÃ©lka = poÄet hran)<br>
            â€¢ <strong>Limit 200:</strong> ZobrazÃ­ max 200 cest (mÅ¯Å¾e jich bÃ½t hodnÄ›!)<br>
            â€¢ <strong>VyuÅ¾itÃ­:</strong> AnalÃ½za redundance, alternativnÃ­ trasy
        </div>
    `;
    allPathsSection.appendChild(allPathsLegendDiv);
    
    const allPathsControlDiv = document.createElement('div');
    allPathsControlDiv.className = 'query-inputs';

    const allPathsDatalist = document.createElement('datalist');
    allPathsDatalist.id = 'nodes-datalist-allpaths';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        allPathsDatalist.appendChild(option);
    });
    allPathsSection.appendChild(allPathsDatalist);

    const selectAllU = document.createElement('input');
    selectAllU.setAttribute('list', 'nodes-datalist-allpaths');
    const selectAllV = document.createElement('input');
    selectAllV.setAttribute('list', 'nodes-datalist-allpaths');
    
    const allPathsBtn = document.createElement('button');
    allPathsBtn.textContent = 'NajÃ­t vÅ¡echny cesty';
    
    allPathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    allPathsControlDiv.appendChild(selectAllU);
    const labelAllV = document.createElement('span');
    labelAllV.textContent = ' Do uzlu: ';
    allPathsControlDiv.appendChild(labelAllV);
    allPathsControlDiv.appendChild(selectAllV);
    allPathsControlDiv.appendChild(allPathsBtn);
    
    allPathsSection.appendChild(allPathsControlDiv);
    
    const allPathsResultDiv = document.createElement('div');
    allPathsResultDiv.className = 'scroll';
    allPathsResultDiv.style.display = 'none';
    allPathsSection.appendChild(allPathsResultDiv);
    
    allPathsBtn.addEventListener('click', () => {
        const u = selectAllU.value;
        const v = selectAllV.value;
        const paths = graph.allShortestPathsUnweighted(u, v);
        
        if (paths.length === 0) {
            allPathsResultDiv.textContent = 'Nenalezena Å¾Ã¡dnÃ¡ cesta.';
        } else {
            let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">PoÄet nejkratÅ¡Ã­ch cest: ${paths.length}</div>`;
            html += paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' â†’ ')}`).join('<br/>');
            if (paths.length > 200) html += '<br/>â€¦ dalÅ¡Ã­ nezobrazeny (limit 200)';
            allPathsResultDiv.innerHTML = html;
        }
        allPathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(allPathsSection);

    // Simple paths up to K
    const simplePathsSection = document.createElement('div');
    simplePathsSection.className = 'section';
    simplePathsSection.innerHTML = '<h2>JednoduchÃ© cesty Uâ†’V do dÃ©lky K</h2>';
    
    const simplePathsLegendDiv = document.createElement('div');
    simplePathsLegendDiv.className = 'info-box';
    simplePathsLegendDiv.style.backgroundColor = '#e7f3ff';
    simplePathsLegendDiv.style.padding = '0.75rem';
    simplePathsLegendDiv.style.borderRadius = '0.25rem';
    simplePathsLegendDiv.style.marginBottom = '1rem';
    simplePathsLegendDiv.style.border = '1px solid #0d6efd';
    simplePathsLegendDiv.innerHTML = `
        <strong>ğŸ¯ JednoduchÃ© cesty (do dÃ©lky K):</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>JednoduchÃ¡ cesta:</strong> NeprochÃ¡zÃ­ Å¾Ã¡dnÃ½ uzel vÃ­cekrÃ¡t<br>
            â€¢ <strong>Max dÃ©lka K:</strong> Obsahuje max K hran<br>
            â€¢ <strong>Bez limitu K:</strong> HledÃ¡ aÅ¾ do dÃ©lky |V|-1<br>
            â€¢ <strong>Limit 10,000:</strong> MaximÃ¡lnÄ› 10,000 vÃ½sledkÅ¯ kvÅ¯li vÃ½konu
        </div>
    `;
    simplePathsSection.appendChild(simplePathsLegendDiv);
    
    const simplePathsControlDiv = document.createElement('div');
    simplePathsControlDiv.className = 'query-inputs';

    const simplePathsDatalist = document.createElement('datalist');
    simplePathsDatalist.id = 'nodes-datalist-simplepaths';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        simplePathsDatalist.appendChild(option);
    });
    simplePathsSection.appendChild(simplePathsDatalist);

    const selectSimpleU = document.createElement('input');
    selectSimpleU.setAttribute('list', 'nodes-datalist-simplepaths');
    const selectSimpleV = document.createElement('input');
    selectSimpleV.setAttribute('list', 'nodes-datalist-simplepaths');
    
    const simpleKInput = document.createElement('input');
    simpleKInput.type = 'number';
    simpleKInput.min = '1';
    simpleKInput.placeholder = 'K (prÃ¡zdnÃ© = |V|-1)';
    simpleKInput.style.width = '150px';
    simpleKInput.style.padding = '0.5rem';
    simpleKInput.style.border = '1px solid #ced4da';
    simpleKInput.style.borderRadius = '0.25rem';
    
    const simplePathsBtn = document.createElement('button');
    simplePathsBtn.textContent = 'NajÃ­t cesty';
    
    simplePathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    simplePathsControlDiv.appendChild(selectSimpleU);
    const labelSimpleV = document.createElement('span');
    labelSimpleV.textContent = ' Do uzlu: ';
    simplePathsControlDiv.appendChild(labelSimpleV);
    simplePathsControlDiv.appendChild(selectSimpleV);
    const labelSimpleK = document.createElement('span');
    labelSimpleK.textContent = ' Max dÃ©lka K: ';
    simplePathsControlDiv.appendChild(labelSimpleK);
    simplePathsControlDiv.appendChild(simpleKInput);
    simplePathsControlDiv.appendChild(simplePathsBtn);
    
    simplePathsSection.appendChild(simplePathsControlDiv);
    
    const simplePathsResultDiv = document.createElement('div');
    simplePathsResultDiv.className = 'scroll';
    simplePathsResultDiv.style.display = 'none';
    simplePathsSection.appendChild(simplePathsResultDiv);
    
    simplePathsBtn.addEventListener('click', () => {
        const u = selectSimpleU.value;
        const v = selectSimpleV.value;
        const K = simpleKInput.value ? parseInt(simpleKInput.value, 10) : null;
        const result = graph.simplePathsUpTo(u, v, K, 10000);
        
        const more = (result.count > result.paths.length) ? ' (zastaveno na limitu 10,000)' : '';
        let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">PoÄet: ${result.count}${more}</div>`;
        html += result.paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' â†’ ')}`).join('<br/>');
        if (result.count > 200) html += '<br/>â€¦ dalÅ¡Ã­ nezobrazeny (limit 200)';
        
        simplePathsResultDiv.innerHTML = html;
        simplePathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(simplePathsSection);

    // Neighbor sets by direction
    const neighborSection = document.createElement('div');
    neighborSection.className = 'section';
    neighborSection.innerHTML = '<h2>SousedÃ© podle smÄ›ru</h2>';
    
    const neighborLegendDiv = document.createElement('div');
    neighborLegendDiv.className = 'info-box';
    neighborLegendDiv.style.backgroundColor = '#e7f3ff';
    neighborLegendDiv.style.padding = '0.75rem';
    neighborLegendDiv.style.borderRadius = '0.25rem';
    neighborLegendDiv.style.marginBottom = '1rem';
    neighborLegendDiv.style.border = '1px solid #0d6efd';
    neighborLegendDiv.innerHTML = `
        <strong>ğŸ‘¥ SousedÃ© podle typu hrany:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>OUT (â†’):</strong> Uzly, do kterÃ½ch vede hrana ven<br>
            â€¢ <strong>IN (â†):</strong> Uzly, ze kterÃ½ch vede hrana dovnitÅ™<br>
            â€¢ <strong>UND (â€”):</strong> Uzly spojenÃ© neorientovanou hranou<br>
            â€¢ <strong>StupeÅˆ uzlu:</strong> |OUT| + |IN| + |UND| (s korekcÃ­)
        </div>
    `;
    neighborSection.appendChild(neighborLegendDiv);
    
    const neighborControlDiv = document.createElement('div');
    neighborControlDiv.style.marginBottom = '1rem';
    neighborControlDiv.innerHTML = '<label>Uzel: <input id="neighborSelect" list="nodes-datalist-neighbor"></label> <button id="neighborBtn" style="margin-left: 0.5rem;">Zobrazit sousedy</button>';
    neighborSection.appendChild(neighborControlDiv);

    const neighborDatalist = document.createElement('datalist');
    neighborDatalist.id = 'nodes-datalist-neighbor';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        neighborDatalist.appendChild(option);
    });
    neighborSection.appendChild(neighborDatalist);
    
    const neighborResultDiv = document.createElement('div');
    neighborResultDiv.className = 'scroll';
    neighborResultDiv.style.display = 'none';
    neighborSection.appendChild(neighborResultDiv);
    
    neighborControlDiv.querySelector('#neighborBtn').addEventListener('click', () => {
        const neighborSelect = document.getElementById('neighborSelect');
        const node = neighborSelect.value;
        const neighbors = graph.neighborSets(node);
        let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
        html += `<div style="padding: 0.5rem; background-color: #d1ecf1; border-radius: 0.25rem;"><strong>OUT (odchozÃ­):</strong> ${neighbors.out.join(', ') || 'âˆ…'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #d4edda; border-radius: 0.25rem;"><strong>IN (pÅ™Ã­chozÃ­):</strong> ${neighbors.inn.join(', ') || 'âˆ…'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #fff3cd; border-radius: 0.25rem;"><strong>NeorientovanÃ­:</strong> ${neighbors.und.join(', ') || 'âˆ…'}</div>`;
        html += '</div>';
        neighborResultDiv.innerHTML = html;
        neighborResultDiv.style.display = 'block';
    });
    
    output.appendChild(neighborSection);

    // Length matrix with query
    const lenSection = document.createElement('div');
    lenSection.className = 'section';
    lenSection.innerHTML = '<h2>Matice dÃ©lek</h2>';
    
    // PÅ™idej vysvÄ›tlivku
    const lenLegendDiv = document.createElement('div');
    lenLegendDiv.className = 'info-box';
    lenLegendDiv.style.backgroundColor = '#e7f3ff';
    lenLegendDiv.style.padding = '0.75rem';
    lenLegendDiv.style.borderRadius = '0.25rem';
    lenLegendDiv.style.marginBottom = '1rem';
    lenLegendDiv.style.border = '1px solid #0d6efd';
    lenLegendDiv.innerHTML = `
        <strong>ğŸ“Š Matice dÃ©lek L[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            â€¢ <strong>L[i,j] = ÄÃ­slo:</strong> VÃ¡ha/dÃ©lka pÅ™Ã­mÃ© hrany<br>
            â€¢ <strong>L[i,j] = âˆ:</strong> Bez pÅ™Ã­mÃ©ho spojenÃ­<br>
            â€¢ <strong>L[i,i] = 0:</strong> VzdÃ¡lenost k sobÄ› samÃ©mu<br>
            â€¢ <strong>PoznÃ¡mka:</strong> Jen pÅ™Ã­mÃ© hrany, ne nejkratÅ¡Ã­ cesty
        </div>
    `;
    lenSection.appendChild(lenLegendDiv);
    
    lenSection.appendChild(createQuerySection('Dotaz na hodnotu', 'length'));
    
    const showLenBtn = document.createElement('button');
    showLenBtn.textContent = 'Zobrazit celou matici';
    const lenMatrixDiv = document.createElement('div');
    lenMatrixDiv.className = 'matrix';
    lenMatrixDiv.style.display = 'none';
    const lenStatsDiv = document.createElement('div');
    lenStatsDiv.style.display = 'none';
    lenStatsDiv.style.marginTop = '1rem';
    lenStatsDiv.style.padding = '1rem';
    lenStatsDiv.className = 'info-box';
    lenStatsDiv.style.backgroundColor = '#e7f3ff';
    lenStatsDiv.style.borderRadius = '0.25rem';

    showLenBtn.addEventListener('click', () => {
        if (lenMatrixDiv.style.display === 'none') {
            const lenMat = graph.lengthMatrix();
            lenMatrixDiv.innerHTML = '';
            lenMatrixDiv.appendChild(createMatrixTable(lenMat, graph.nodes, graph.nodes));

            const stats = calculateMatrixStats(lenMat, graph.nodes, graph.nodes);
            lenStatsDiv.innerHTML = createMatrixStatsHTML(stats, { showRowColSums: true });

            lenMatrixDiv.style.display = 'block';
            lenStatsDiv.style.display = 'block';
            showLenBtn.textContent = 'SkrÃ½t matici';
        } else {
            lenMatrixDiv.style.display = 'none';
            lenStatsDiv.style.display = 'none';
            showLenBtn.textContent = 'Zobrazit celou matici';
        }
    });
    lenSection.appendChild(showLenBtn);
    lenSection.appendChild(lenMatrixDiv);
    lenSection.appendChild(lenStatsDiv);
    output.appendChild(lenSection);

    // Shortest path query
    const shortestSection = document.createElement('div');
    shortestSection.className = 'section';
    shortestSection.innerHTML = '<h2>NejkratÅ¡Ã­ cesty (Floyd-Warshall)</h2>';
    
    // PÅ™idej vysvÄ›tlivku pro Floyd-Warshall
    const fwLegendDiv = document.createElement('div');
    fwLegendDiv.className = 'info-box';
    fwLegendDiv.style.backgroundColor = '#e7f3ff';
    fwLegendDiv.style.padding = '0.75rem';
    fwLegendDiv.style.borderRadius = '0.25rem';
    fwLegendDiv.style.marginBottom = '1rem';
    fwLegendDiv.style.border = '1px solid #0d6efd';
    fwLegendDiv.innerHTML = `
        <strong>ğŸ›£ï¸ Floyd-WarshallÅ¯v algoritmus:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            â€¢ <strong>Co poÄÃ­tÃ¡:</strong> NejkratÅ¡Ã­ cesty mezi VÅ EMI pÃ¡ry uzlÅ¯ najednou<br>
            â€¢ <strong>VÃ½hoda:</strong> ZvlÃ¡dÃ¡ i <strong>zÃ¡pornÃ© vÃ¡hy</strong> (ale ne zÃ¡pornÃ© cykly)<br>
            â€¢ <strong>SloÅ¾itost:</strong> O(VÂ³) â€“ vhodnÃ© pro menÅ¡Ã­ grafy (do ~500 uzlÅ¯)<br>
            â€¢ <strong>VyuÅ¾itÃ­:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>RoutovÃ¡nÃ­ v sÃ­tÃ­ch</strong> â€“ pÅ™edpoÄÃ­tÃ¡nÃ­ smÄ›rovacÃ­ch tabulek</li>
                <li><strong>TranzitivnÃ­ uzÃ¡vÄ›r</strong> â€“ kdo dosÃ¡hne na koho</li>
                <li><strong>Detekce zÃ¡pornÃ½ch cyklÅ¯</strong> â€“ arbitrÃ¡Å¾ mÄ›n</li>
                <li><strong>Centrum grafu</strong> â€“ uzel s nejmenÅ¡Ã­ maximÃ¡lnÃ­ vzdÃ¡lenostÃ­</li>
            </ul>
            â€¢ <strong>Matice pÅ™edchÅ¯dcÅ¯:</strong> UmoÅ¾Åˆuje rekonstruovat celou cestu, nejen vzdÃ¡lenost
        </div>
    `;
    shortestSection.appendChild(fwLegendDiv);
    
    shortestSection.appendChild(createQuerySection('Dotaz na nejkratÅ¡Ã­ cestu', 'shortest'));
    
    const showPredBtn = document.createElement('button');
    showPredBtn.textContent = 'VypoÄÃ­tat celou matici pÅ™edchÅ¯dcÅ¯';
    const predMatrixDiv = document.createElement('div');
    predMatrixDiv.className = 'matrix';
    predMatrixDiv.style.display = 'none';
    showPredBtn.addEventListener('click', () => {
        if (predMatrixDiv.style.display === 'none') {
            showPredBtn.disabled = true;
            showPredBtn.textContent = 'PoÄÃ­tÃ¡m...';
            setTimeout(() => {
                const fw = graph.floydWarshall();
                const pred = fw.pred.map(row => row.map(p => p === null ? 'â€“' : graph.nodes[p]));
                predMatrixDiv.innerHTML = '';
                predMatrixDiv.appendChild(createMatrixTable(pred, graph.nodes, graph.nodes));
                predMatrixDiv.style.display = 'block';
                showPredBtn.textContent = 'SkrÃ½t matici';
                showPredBtn.disabled = false;
            }, 50);
        } else {
            predMatrixDiv.style.display = 'none';
            showPredBtn.textContent = 'Zobrazit celou matici';
        }
    });
    shortestSection.appendChild(showPredBtn);
    shortestSection.appendChild(predMatrixDiv);
    output.appendChild(shortestSection);

    // Incident edges
    const incident = graph.incidentEdges();
    const incEdgeSection = document.createElement('div');
    incEdgeSection.className = 'section';
    incEdgeSection.innerHTML = '<h2>Tabulka incidentnÃ­ch hran</h2>';
    
    // PÅ™idej vysvÄ›tlivku pro incidentnÃ­ hrany
    const incEdgeLegendDiv = document.createElement('div');
    incEdgeLegendDiv.style.backgroundColor = '#e7f3ff';
    incEdgeLegendDiv.style.padding = '0.75rem';
    incEdgeLegendDiv.style.borderRadius = '0.25rem';
    incEdgeLegendDiv.style.marginBottom = '1rem';
    incEdgeLegendDiv.style.border = '1px solid #0d6efd';
    incEdgeLegendDiv.innerHTML = `
        <strong>ğŸ”— Co jsou incidentnÃ­ hrany?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            â€¢ <strong>Definice:</strong> Hrany, kterÃ© â€dotÃ½kajÃ­" danÃ½ uzel (vychÃ¡zejÃ­ z nÄ›j nebo do nÄ›j vchÃ¡zejÃ­)<br>
            â€¢ <strong>StupeÅˆ uzlu:</strong> PoÄet incidentnÃ­ch hran = stupeÅˆ uzlu (degree)<br>
            â€¢ <strong>VyuÅ¾itÃ­:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>AnalÃ½za sÃ­tÃ­</strong> â€“ identifikace hubÅ¯ (uzly s mnoha spojenÃ­mi)</li>
                <li><strong>EulerovskÃ© cesty</strong> â€“ graf mÃ¡ Eul. cestu âŸº max 2 uzly lichÃ©ho stupnÄ›</li>
                <li><strong>GrafovÃ¡ vizualizace</strong> â€“ rozloÅ¾enÃ­ podle stupÅˆÅ¯</li>
                <li><strong>Optimalizace</strong> â€“ proÅ™ezÃ¡vÃ¡nÃ­ hran u mÃ¡lo propojenÃ½ch uzlÅ¯</li>
            </ul>
        </div>
    `;
    incEdgeSection.appendChild(incEdgeLegendDiv);
    
    const incEdgeDiv = document.createElement('div');
    incEdgeDiv.className = 'matrix';
    incEdgeDiv.appendChild(createListTable(incident));
    incEdgeSection.appendChild(incEdgeDiv);
    output.appendChild(incEdgeSection);

    // Neighbours
    const neighbours = graph.neighbours();
    const neighSection = document.createElement('div');
    neighSection.className = 'section';
    neighSection.innerHTML = '<h2>Seznam sousedÅ¯</h2>';
    
    // PÅ™idej vysvÄ›tlivku pro seznam sousedÅ¯
    const neighLegendDiv = document.createElement('div');
    neighLegendDiv.style.backgroundColor = '#e7f3ff';
    neighLegendDiv.style.padding = '0.75rem';
    neighLegendDiv.style.borderRadius = '0.25rem';
    neighLegendDiv.style.marginBottom = '1rem';
    neighLegendDiv.style.border = '1px solid #0d6efd';
    neighLegendDiv.innerHTML = `
        <strong>ğŸ‘¥ Co je seznam sousedÅ¯ (Adjacency List)?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            â€¢ <strong>Definice:</strong> Pro kaÅ¾dÃ½ uzel seznam vÅ¡ech uzlÅ¯, se kterÃ½mi je pÅ™Ã­mo spojen hranou<br>
            â€¢ <strong>PamÄ›Å¥ovÃ¡ nÃ¡roÄnost:</strong> O(V + E) â€“ efektivnÄ›jÅ¡Ã­ neÅ¾ matice sousednosti pro Å™Ã­dkÃ© grafy<br>
            â€¢ <strong>VyuÅ¾itÃ­:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>BFS/DFS</strong> â€“ rychlÃ½ pÅ™Ã­stup k sousedÅ¯m v O(1) amortizovanÄ›</li>
                <li><strong>SociÃ¡lnÃ­ sÃ­tÄ›</strong> â€“ seznam pÅ™Ã¡tel, sledujÃ­cÃ­ch</li>
                <li><strong>DoporuÄovacÃ­ systÃ©my</strong> â€“ â€pÅ™Ã¡telÃ© pÅ™Ã¡tel"</li>
                <li><strong>WebovÃ© crawlery</strong> â€“ odkazy z jednÃ© strÃ¡nky</li>
            </ul>
            â€¢ <strong>Tip:</strong> Pro orientovanÃ© grafy rozliÅ¡ujeme odchozÃ­ (OUT) a pÅ™Ã­chozÃ­ (IN) sousedy
        </div>
    `;
    neighSection.appendChild(neighLegendDiv);
    
    const neighDiv = document.createElement('div');
    neighDiv.className = 'matrix';
    neighDiv.appendChild(createListTable(neighbours));
    neighSection.appendChild(neighDiv);
    output.appendChild(neighSection);

    // Multiple edges detection and listing
    const multipleEdges = graph.findMultipleEdges();
    const multiEdgeSection = document.createElement('div');
    multiEdgeSection.className = 'section';
    multiEdgeSection.innerHTML = '<h2>VÃ­ceÃ¡sobnÃ© hrany</h2>';
    
    // PÅ™idej vysvÄ›tlivku pro vÃ­ceÃ¡sobnÃ© hrany
    const multiEdgeLegendDiv = document.createElement('div');
    multiEdgeLegendDiv.style.backgroundColor = '#e7f3ff';
    multiEdgeLegendDiv.style.padding = '0.75rem';
    multiEdgeLegendDiv.style.borderRadius = '0.25rem';
    multiEdgeLegendDiv.style.marginBottom = '1rem';
    multiEdgeLegendDiv.style.border = '1px solid #0d6efd';
    multiEdgeLegendDiv.innerHTML = `
        <strong>ğŸ”€ Co jsou vÃ­ceÃ¡sobnÃ© (paralelnÃ­) hrany?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            â€¢ <strong>Definice:</strong> DvÄ› nebo vÃ­ce hran spojujÃ­cÃ­ch stejnou dvojici uzlÅ¯<br>
            â€¢ <strong>Multigraf:</strong> Graf, kterÃ½ obsahuje vÃ­ceÃ¡sobnÃ© hrany<br>
            â€¢ <strong>Kde se vyskytujÃ­:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>DopravnÃ­ sÃ­tÄ›</strong> â€“ vÃ­ce linek mezi stanicemi (metro, autobus)</li>
                <li><strong>Telekomunikace</strong> â€“ redundantnÃ­ kabely mezi serverovnami</li>
                <li><strong>ElektrickÃ© obvody</strong> â€“ paralelnÄ› zapojenÃ© rezistory</li>
                <li><strong>FinanÄnÃ­ transakce</strong> â€“ vÃ­ce pÅ™evodÅ¯ mezi ÃºÄty</li>
            </ul>
            â€¢ <strong>Pozor:</strong> Mnoho algoritmÅ¯ pÅ™edpoklÃ¡dÃ¡ prostÃ½ graf â€“ vÃ­ceÃ¡sobnÃ© hrany je tÅ™eba oÅ¡etÅ™it
        </div>
    `;
    multiEdgeSection.appendChild(multiEdgeLegendDiv);
    
    if (multipleEdges.length === 0) {
        const noMultiMsg = document.createElement('p');
        noMultiMsg.textContent = 'Graf neobsahuje Å¾Ã¡dnÃ© vÃ­ceÃ¡sobnÃ© hrany.';
        noMultiMsg.style.color = '#28a745';
        noMultiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(noMultiMsg);
    } else {
        const multiMsg = document.createElement('p');
        multiMsg.textContent = `Nalezeno ${multipleEdges.length} skupin vÃ­ceÃ¡sobnÃ½ch hran:`;
        multiMsg.style.color = '#dc3545';
        multiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(multiMsg);
        
        const multiEdgeDiv = document.createElement('div');
        multiEdgeDiv.className = 'scrollable-list';
        const multiList = document.createElement('ul');
        multiList.style.listStyle = 'none';
        multiList.style.padding = '0';
        
        for (const group of multipleEdges) {
            const li = document.createElement('li');
            li.style.marginBottom = '1rem';
            li.style.padding = '0.5rem';
            li.style.backgroundColor = '#fff3cd';
            li.style.border = '1px solid #ffc107';
            li.style.borderRadius = '0.25rem';
            
            const title = document.createElement('strong');
            title.textContent = `${group.key} (${group.count}Ã— nÃ¡sobnÃ¡ hrana)`;
            li.appendChild(title);
            
            const edgeList = document.createElement('ul');
            edgeList.style.marginTop = '0.5rem';
            edgeList.style.marginLeft = '1rem';
            
            for (const e of group.edges) {
                const edgeLi = document.createElement('li');
                const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
                const label = e.label ? ` [${e.label}]` : '';
                let orientation;
                if (e.direction === '>') orientation = 'â†’';
                else if (e.direction === '<') orientation = 'â†';
                else orientation = 'â€”';
                edgeLi.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
                edgeList.appendChild(edgeLi);
            }
            
            li.appendChild(edgeList);
            multiList.appendChild(li);
        }
        
        multiEdgeDiv.appendChild(multiList);
        multiEdgeSection.appendChild(multiEdgeDiv);
    }
    
    output.appendChild(multiEdgeSection);

    // Properties (props uÅ¾ je definovanÃ© na zaÄÃ¡tku)
    const propSection = document.createElement('div');
    propSection.className = 'section';
    propSection.innerHTML = '<h2>Vlastnosti grafu</h2>';
    
    // PÅ™idej vysvÄ›tlivky pro uÅ¾ivatele
    const legendDiv = document.createElement('div');
    legendDiv.style.backgroundColor = '#fff3cd';
    legendDiv.style.padding = '1rem';
    legendDiv.style.borderRadius = '0.25rem';
    legendDiv.style.marginBottom = '1rem';
    legendDiv.style.border = '1px solid #ffc107';
    legendDiv.innerHTML = `
        <strong>ğŸ“– RychlÃ½ slovnÃ­k pojmÅ¯:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6; font-size: 0.95rem;">
            â€¢ <strong>OhodnocenÃ½:</strong> MÃ¡ vÃ¡hy na hranÃ¡ch/uzlech | <strong>OrientovanÃ½:</strong> Hrany majÃ­ smÄ›r (â†’)<br>
            â€¢ <strong>SouvislÃ½:</strong> Z kaÅ¾dÃ©ho uzlu lze dojet do kaÅ¾dÃ©ho | <strong>SilnÄ›/SlabÄ›:</strong> Pouze v orientovanÃ½ch<br>
            â€¢ <strong>ProstÃ½:</strong> Max 1 hrana mezi uzly | <strong>JednoduchÃ½:</strong> ProstÃ½ bez smyÄek<br>
            â€¢ <strong>ÃšplnÃ½:</strong> VÅ¡echny uzly spojeny | <strong>RegulÃ¡rnÃ­:</strong> VÅ¡echny uzly stejnÃ½ stupeÅˆ<br>
            â€¢ <strong>BipartitnÃ­:</strong> Uzly v 2 skupinÃ¡ch, hrany jen mezi | <strong>RovinnÃ½:</strong> NakreslitelnÃ½ bez kÅ™Ã­Å¾enÃ­
        </div>
    `;
    propSection.appendChild(legendDiv);
    
    const propDiv = document.createElement('div');
    propDiv.className = 'properties';
    const addProp = (name, value) => {
        const span = document.createElement('span');
        span.textContent = `${name}: ${value}`;
        propDiv.appendChild(span);
    };
    addProp('OhodnocenÃ½', props.weighted ? 'ano' : 'ne');
    addProp('Orientace', props.oriented);
    addProp('SouvislÃ½', props.connected ? 'ano' : 'ne');
    
    // âš¡ OPRAVA: Zobraz strong/weak connectivity chytÅ™e
    if (props.oriented === 'orientovanÃ½') {
        if (props.stronglyConnected) {
            addProp('SilnÄ› souvislÃ½', 'ano');
            // SlabÄ› souvislÃ½ nemusÃ­me zobrazovat - je implicitnÃ­!
        } else if (props.weaklyConnected) {
            addProp('SilnÄ› souvislÃ½', 'ne');
            addProp('SlabÄ› souvislÃ½', 'ano');
        } else {
            addProp('SilnÄ› souvislÃ½', 'ne');
            addProp('SlabÄ› souvislÃ½', 'ne');
        }
    }
    
    addProp('ProstÃ½', props.prosty ? 'ano' : 'ne');
    addProp('JednoduchÃ½', props.jednoduchy ? 'ano' : 'ne');
    addProp('Multigraf', props.multigraph ? 'ano' : 'ne');
    addProp('DiskrÃ©tnÃ­', props.discrete ? 'ano (bez hran)' : 'ne');
    addProp('KoneÄnÃ½', props.finite ? 'ano' : 'ne');
    addProp('SymetrizovanÃ½', props.symmetric ? 'ano' : 'ne');
    addProp('ÃšplnÃ½', props.complete ? 'ano' : 'ne');
    addProp('RegulÃ¡rnÃ­', props.regular ? 'ano' : 'ne');
    addProp('BipartitnÃ­', props.bipartite ? 'ano' : 'ne');
    addProp('RovinnÃ½', typeof props.planar === 'string' ? props.planar : (props.planar ? 'ano' : 'ne'));
    propSection.appendChild(propDiv);
    output.appendChild(propSection);

    // Graph exploration section
    const exploreSection = document.createElement('div');
    exploreSection.id = 'exploreSection';
    exploreSection.className = 'section';
    exploreSection.innerHTML = '<h2>ProhledÃ¡vÃ¡nÃ­ grafu (BFS/DFS)</h2>';
    
    // PÅ™idej vysvÄ›tlivku pro BFS/DFS
    const exploreLegendDiv = document.createElement('div');
    exploreLegendDiv.style.backgroundColor = '#e7f3ff';
    exploreLegendDiv.style.padding = '0.75rem';
    exploreLegendDiv.style.borderRadius = '0.25rem';
    exploreLegendDiv.style.marginBottom = '1rem';
    exploreLegendDiv.style.border = '1px solid #0d6efd';
    exploreLegendDiv.innerHTML = `
        <strong>ğŸ” K Äemu jsou BFS a DFS dobrÃ©?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>BFS (Breadth-First Search):</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li>Najde <strong>nejkratÅ¡Ã­ cestu</strong> v neohodnocenÃ©m grafu (poÄet hran)</li>
                <li>VhodnÃ© pro <strong>hledÃ¡nÃ­ nejbliÅ¾Å¡Ã­ch sousedÅ¯</strong> (sociÃ¡lnÃ­ sÃ­tÄ›, doporuÄovacÃ­ systÃ©my)</li>
                <li>TestovÃ¡nÃ­ <strong>souvislosti grafu</strong> a hledÃ¡nÃ­ komponent</li>
                <li>ÄŒasovÃ¡ sloÅ¾itost: O(V + E)</li>
            </ul>
            <strong>DFS (Depth-First Search):</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Detekce cyklÅ¯</strong> v grafu</li>
                <li><strong>TopologickÃ© Å™azenÃ­</strong> pro DAG (plÃ¡novÃ¡nÃ­ ÃºkolÅ¯, zÃ¡vislosti)</li>
                <li>HledÃ¡nÃ­ <strong>silnÄ› souvislÃ½ch komponent</strong> (Tarjan, Kosaraju)</li>
                <li>GenerovÃ¡nÃ­ <strong>bludiÅ¡Å¥</strong> a Å™eÅ¡enÃ­ problÃ©mÅ¯ s backtrackingem</li>
                <li>ÄŒasovÃ¡ sloÅ¾itost: O(V + E)</li>
            </ul>
        </div>
    `;
    exploreSection.appendChild(exploreLegendDiv);
    
    const exploreControls = document.createElement('div');
    exploreControls.className = 'query-inputs';
    exploreControls.innerHTML = `
        <select id="traversalAlgo" class="query-select">
            <option value="bfs">BFS (do Å¡Ã­Å™ky)</option>
            <option value="dfs">DFS (do hloubky)</option>
        </select>
        <input id="startNode" list="nodes-datalist-explore" placeholder="StartovacÃ­ uzel">
        <datalist id="nodes-datalist-explore"></datalist>
        <button id="runTraversal">Spustit</button>
    `;
    exploreSection.appendChild(exploreControls);
    const exploreResult = document.createElement('div');
    exploreResult.id = 'exploreResult';
    exploreResult.style.display = 'none';
    exploreSection.appendChild(exploreResult);
    output.appendChild(exploreSection);

    // Spanning Tree section
    const spanningTreeSection = document.createElement('div');
    spanningTreeSection.id = 'spanningTreeSection';
    spanningTreeSection.className = 'section';
    spanningTreeSection.innerHTML = '<h2>Kostra grafu</h2>';
    
    // PÅ™idej vysvÄ›tlivku pro kostru grafu
    const spanningTreeLegendDiv = document.createElement('div');
    spanningTreeLegendDiv.style.backgroundColor = '#e7f3ff';
    spanningTreeLegendDiv.style.padding = '0.75rem';
    spanningTreeLegendDiv.style.borderRadius = '0.25rem';
    spanningTreeLegendDiv.style.marginBottom = '1rem';
    spanningTreeLegendDiv.style.border = '1px solid #0d6efd';
    spanningTreeLegendDiv.innerHTML = `
        <strong>ğŸŒ² K Äemu jsou kostry grafu dobrÃ©?</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>Kostra (Spanning Tree):</strong> Podgraf obsahujÃ­cÃ­ vÅ¡echny uzly s minimem hran pro souvislost (bez cyklÅ¯).<br><br>
            <strong>MinimÃ¡lnÃ­ kostra (MST):</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>NÃ¡vrh sÃ­tÃ­</strong> â€“ elektrickÃ© vedenÃ­, vodovody, optickÃ© kabely s min. nÃ¡klady</li>
                <li><strong>Clustering</strong> â€“ shlukovÃ¡nÃ­ dat (single-linkage clustering)</li>
                <li><strong>Aproximace NP-tÄ›Å¾kÃ½ch problÃ©mÅ¯</strong> â€“ TSP (obchodnÃ­ cestujÃ­cÃ­)</li>
                <li><strong>PoÄÃ­taÄovÃ© sÃ­tÄ›</strong> â€“ spanning tree protocol (prevence smyÄek)</li>
            </ul>
            <strong>MaximÃ¡lnÃ­ kostra:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>Maximalizace kapacity/Å¡Ã­Å™ky pÃ¡sma</strong> v sÃ­ti</li>
                <li><strong>AnalÃ½za nejsilnÄ›jÅ¡Ã­ch vazeb</strong> v sociÃ¡lnÃ­ch sÃ­tÃ­ch</li>
            </ul>
            <strong>PoÄet koster:</strong> UdÃ¡vÃ¡ redundanci grafu â€“ ÄÃ­m vÃ­ce koster, tÃ­m vÃ­ce zpÅ¯sobÅ¯ propojenÃ­.<br>
            <strong>Algoritmy:</strong> Kruskal O(E log E), Prim O(E log V), BorÅ¯vka O(E log V)
        </div>
    `;
    spanningTreeSection.appendChild(spanningTreeLegendDiv);
    
    const spanningTreeControls = document.createElement('div');
    spanningTreeControls.className = 'query-inputs';
    spanningTreeControls.innerHTML = `
        <button id="runSpanningTree">Analyzovat kostru grafu</button>
    `;
    spanningTreeSection.appendChild(spanningTreeControls);
    const spanningTreeResult = document.createElement('div');
    spanningTreeResult.id = 'spanningTreeResult';
    spanningTreeResult.style.display = 'none';
    spanningTreeSection.appendChild(spanningTreeResult);
    output.appendChild(spanningTreeSection);

    // Optimal paths (shortest/longest/safest/widest)
    const optimalSection = document.createElement('div');
    optimalSection.id = 'optimalPathsSection';
    optimalSection.className = 'section';
    optimalSection.innerHTML = '<h2>OptimÃ¡lnÃ­ cesty (nejkratÅ¡Ã­ / nejdelÅ¡Ã­ / nejbezpeÄnÄ›jÅ¡Ã­ / nejÅ¡irÅ¡Ã­)</h2>';
    
    // PÅ™idej detailnÃ­ vysvÄ›tlivku pro optimÃ¡lnÃ­ cesty
    const optimalLegendDiv = document.createElement('div');
    optimalLegendDiv.style.backgroundColor = '#e7f3ff';
    optimalLegendDiv.style.padding = '0.75rem';
    optimalLegendDiv.style.borderRadius = '0.25rem';
    optimalLegendDiv.style.marginBottom = '1rem';
    optimalLegendDiv.style.border = '1px solid #0d6efd';
    optimalLegendDiv.innerHTML = `
        <strong>ğŸ›¤ï¸ PÅ™ehled algoritmÅ¯ pro hledÃ¡nÃ­ cest:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                <tr style="background-color: rgba(0,0,0,0.05);">
                    <th style="text-align: left; padding: 0.3rem;">Algoritmus</th>
                    <th style="text-align: left; padding: 0.3rem;">SloÅ¾itost</th>
                    <th style="text-align: left; padding: 0.3rem;">Kdy pouÅ¾Ã­t</th>
                </tr>
                <tr>
                    <td style="padding: 0.3rem;"><strong>Moore (BFS)</strong></td>
                    <td style="padding: 0.3rem;">O(V + E)</td>
                    <td style="padding: 0.3rem;">NeohodnocenÃ½ graf, hledÃ¡me min. poÄet hran</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.3rem;"><strong>Dijkstra</strong></td>
                    <td style="padding: 0.3rem;">O((V+E) log V)</td>
                    <td style="padding: 0.3rem;">NezÃ¡pornÃ© vÃ¡hy â€“ GPS navigace, routing</td>
                </tr>
                <tr>
                    <td style="padding: 0.3rem;"><strong>Bellman-Ford</strong></td>
                    <td style="padding: 0.3rem;">O(V Ã— E)</td>
                    <td style="padding: 0.3rem;">ZÃ¡pornÃ© vÃ¡hy â€“ arbitrÃ¡Å¾ mÄ›n, detekce zÃ¡p. cyklÅ¯</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.3rem;"><strong>NejÅ¡irÅ¡Ã­ cesta</strong></td>
                    <td style="padding: 0.3rem;">O((V+E) log V)</td>
                    <td style="padding: 0.3rem;">Maximalizace minimÃ¡lnÃ­ kapacity â€“ sÃ­Å¥ovÃ© toky, bandwidth. <span style="color:#dc3545;">VyÅ¾aduje nezÃ¡pornÃ© kapacity!</span></td>
                </tr>
                <tr>
                    <td style="padding: 0.3rem;"><strong>NejbezpeÄnÄ›jÅ¡Ã­</strong></td>
                    <td style="padding: 0.3rem;">O((V+E) log V)</td>
                    <td style="padding: 0.3rem;">Spolehlivost r = exp(âˆ’w). Max. souÄin spolehlivostÃ­ = min. souÄet vah.</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.3rem;"><strong>NejdelÅ¡Ã­ cesta</strong></td>
                    <td style="padding: 0.3rem;">O(V + E) pro DAG</td>
                    <td style="padding: 0.3rem;">PlÃ¡novÃ¡nÃ­ projektÅ¯ (CPM), kritickÃ¡ cesta</td>
                </tr>
            </table>
            <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #6c757d;">
                ğŸ’¡ <strong>Tip:</strong> Pro jeden zdroj â†’ Dijkstra/BF. Pro vÅ¡echny pÃ¡ry â†’ Floyd-Warshall (sekce vÃ½Å¡e).
            </div>
        </div>
    `;
    optimalSection.appendChild(optimalLegendDiv);
    
    const optimalInfo = document.createElement('p');
    optimalInfo.style.color = '#495057';
    optimalInfo.innerHTML = 'MooreÅ¯v algoritmus (BFS) hledÃ¡ nejkratÅ¡Ã­ cestu v neohodnocenÃ©m grafu. DijkstrÅ¯v a Bellman-FordÅ¯v algoritmus pracujÃ­ s vahami (Bellman-Ford zvlÃ¡dÃ¡ i zÃ¡pornÃ© hrany) a Floyd-Warshallova varianta nÃ­Å¾e poskytuje kompletnÃ­ matici vzdÃ¡lenostÃ­.';
    optimalSection.appendChild(optimalInfo);
    const optimalInputs = document.createElement('div');
    optimalInputs.className = 'query-inputs';
    optimalInputs.innerHTML = `
        <input id="optimalStartNode" list="nodes-datalist-optimal" placeholder="Od uzlu">
        <input id="optimalEndNode" list="nodes-datalist-optimal" placeholder="Do uzlu">
        <button id="runOptimalPaths">Analyzovat optimÃ¡lnÃ­ cesty</button>
    `;
    optimalSection.appendChild(optimalInputs);
    const optimalDatalist = document.createElement('datalist');
    optimalDatalist.id = 'nodes-datalist-optimal';
    optimalSection.appendChild(optimalDatalist);
    const optimalResult = document.createElement('div');
    optimalResult.id = 'optimalPathsResult';
    optimalResult.style.display = 'none';
    optimalSection.appendChild(optimalResult);
    output.appendChild(optimalSection);

    // CPM / critical path section
    const cpmSection = document.createElement('div');
    cpmSection.id = 'cpmSection';
    cpmSection.className = 'section';
    cpmSection.innerHTML = '<h2>ProjektovÃ© plÃ¡novÃ¡nÃ­ (sÃ­Å¥ovÃ½ graf & CPM)</h2>';
    
    // PÅ™idej detailnÃ­ CPM legendu
    const cpmLegendDiv = document.createElement('div');
    cpmLegendDiv.style.backgroundColor = '#e7f3ff';
    cpmLegendDiv.style.padding = '0.75rem';
    cpmLegendDiv.style.borderRadius = '0.25rem';
    cpmLegendDiv.style.marginBottom = '1rem';
    cpmLegendDiv.style.border = '1px solid #0d6efd';
    cpmLegendDiv.innerHTML = `
        <strong>ğŸ“Š CPM (Critical Path Method) â€“ Metoda kritickÃ© cesty</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>Co je CPM?</strong> Technika projektovÃ©ho Å™Ã­zenÃ­ pro plÃ¡novÃ¡nÃ­ a optimalizaci harmonogramu.<br><br>
            <strong>KlÃ­ÄovÃ© pojmy:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>ES (Early Start)</strong> â€“ NejdÅ™Ã­ve moÅ¾nÃ½ zaÄÃ¡tek Äinnosti</li>
                <li><strong>EF (Early Finish)</strong> â€“ NejdÅ™Ã­ve moÅ¾nÃ½ konec = ES + dÃ©lka</li>
                <li><strong>LS (Late Start)</strong> â€“ NejpozdÄ›ji pÅ™Ã­pustnÃ½ zaÄÃ¡tek</li>
                <li><strong>LF (Late Finish)</strong> â€“ NejpozdÄ›ji pÅ™Ã­pustnÃ½ konec (deadline)</li>
                <li><strong>Rezerva (Float/Slack)</strong> â€“ LS âˆ’ ES = o kolik lze Äinnost zpozdit</li>
                <li><strong>KritickÃ¡ cesta</strong> â€“ NejdelÅ¡Ã­ cesta projektem (nulovÃ¡ rezerva)</li>
            </ul>
            <strong>K Äemu je CPM dobrÃ¡:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>StavebnictvÃ­</strong> â€“ plÃ¡novÃ¡nÃ­ vÃ½stavby, koordinace subdodavatelÅ¯</li>
                <li><strong>VÃ½voj software</strong> â€“ release planning, dependency management</li>
                <li><strong>VÃ½roba</strong> â€“ optimalizace vÃ½robnÃ­ch linek</li>
                <li><strong>VÄ›da</strong> â€“ plÃ¡novÃ¡nÃ­ experimentÅ¯ s nÃ¡vaznostmi</li>
            </ul>
            <strong>ğŸ”¥ KritickÃ© Äinnosti</strong> = Äinnosti s nulovou rezervou. JakÃ©koli zpoÅ¾dÄ›nÃ­ prodlouÅ¾Ã­ projekt!
        </div>
    `;
    cpmSection.appendChild(cpmLegendDiv);
    
    const cpmIntro = document.createElement('p');
    cpmIntro.style.color = '#495057';
    cpmIntro.innerHTML = 'Hrany interpretujeme jako Äinnosti s dÃ©lkou podle vÃ¡hy. CPM (Critical Path Method) spoÄÃ­tÃ¡ kritickou cestu, dÃ©lku projektu a rezervy ÄinnostÃ­, abyste mohli plÃ¡novat kapacity.';
    cpmSection.appendChild(cpmIntro);
    const cpmBtn = document.createElement('button');
    cpmBtn.id = 'runCpmAnalysis';
    cpmBtn.textContent = 'Analyzovat kritickou cestu (CPM)';
    cpmSection.appendChild(cpmBtn);
    const cpmResult = document.createElement('div');
    cpmResult.id = 'cpmResult';
    cpmResult.style.display = 'none';
    cpmSection.appendChild(cpmResult);
    output.appendChild(cpmSection);

    // Network flow section
    const flowSection = document.createElement('div');
    flowSection.id = 'flowSection';
    flowSection.className = 'section';
    flowSection.innerHTML = '<h2>SÃ­Å¥ovÃ© toky (maximÃ¡lnÃ­ tok & minimÃ¡lnÃ­ Å™ez)</h2>';
    
    // PÅ™idej detailnÃ­ vysvÄ›tlivku pro sÃ­Å¥ovÃ© toky
    const flowLegendDiv = document.createElement('div');
    flowLegendDiv.style.backgroundColor = '#e7f3ff';
    flowLegendDiv.style.padding = '0.75rem';
    flowLegendDiv.style.borderRadius = '0.25rem';
    flowLegendDiv.style.marginBottom = '1rem';
    flowLegendDiv.style.border = '1px solid #0d6efd';
    flowLegendDiv.innerHTML = `
        <strong>ğŸŒŠ SÃ­Å¥ovÃ© toky â€“ MaximÃ¡lnÃ­ tok a MinimÃ¡lnÃ­ Å™ez</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6;">
            <strong>Co je tok v sÃ­ti?</strong> PÅ™eprava â€komodity" ze zdroje (s) do cÃ­le (t) respektujÃ­cÃ­ kapacity hran.<br><br>
            <strong>KlÃ­ÄovÃ© pojmy:</strong>
            <ul style="margin: 0.25rem 0 0.5rem 1rem;">
                <li><strong>Kapacita hrany</strong> â€“ maximÃ¡lnÃ­ tok, kterÃ½ mÅ¯Å¾e hranou projÃ­t</li>
                <li><strong>ReziduÃ¡lnÃ­ kapacita</strong> â€“ kolik jeÅ¡tÄ› mÅ¯Å¾e hranou protÃ©ct</li>
                <li><strong>ZlepÅ¡ujÃ­cÃ­ cesta</strong> â€“ cesta s kladnou reziduÃ¡lnÃ­ kapacitou</li>
                <li><strong>Min-cut vÄ›ta</strong> â€“ max tok = minimÃ¡lnÃ­ Å™ez (Ford-Fulkerson)</li>
            </ul>
            <strong>Algoritmy:</strong>
            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem; margin: 0.5rem 0;">
                <tr style="background-color: rgba(0,0,0,0.05);">
                    <th style="text-align: left; padding: 0.2rem;">Algoritmus</th>
                    <th style="text-align: left; padding: 0.2rem;">SloÅ¾itost</th>
                    <th style="text-align: left; padding: 0.2rem;">PÅ™Ã­stup</th>
                </tr>
                <tr>
                    <td style="padding: 0.2rem;">Ford-Fulkerson (DFS)</td>
                    <td style="padding: 0.2rem;">O(E Ã— max_flow)</td>
                    <td style="padding: 0.2rem;">ZlepÅ¡ujÃ­cÃ­ cesty (DFS)</td>
                </tr>
                <tr style="background-color: rgba(0,0,0,0.03);">
                    <td style="padding: 0.2rem;">Edmonds-Karp (BFS)</td>
                    <td style="padding: 0.2rem;">O(V Ã— EÂ²)</td>
                    <td style="padding: 0.2rem;">NejkratÅ¡Ã­ zlepÅ¡ujÃ­cÃ­ cesty</td>
                </tr>
                <tr>
                    <td style="padding: 0.2rem;">Goldberg (Push-Relabel)</td>
                    <td style="padding: 0.2rem;">O(VÂ² Ã— E)</td>
                    <td style="padding: 0.2rem;">LokÃ¡lnÃ­ operace, vÃ½Å¡ky uzlÅ¯</td>
                </tr>
            </table>
            <strong>PraktickÃ© vyuÅ¾itÃ­:</strong>
            <ul style="margin: 0.25rem 0 0 1rem;">
                <li><strong>Logistika</strong> â€“ maximÃ¡lnÃ­ pÅ™epravnÃ­ kapacita</li>
                <li><strong>PoÄÃ­taÄovÃ© sÃ­tÄ›</strong> â€“ bandwidth, load balancing</li>
                <li><strong>BipartitnÃ­ pÃ¡rovÃ¡nÃ­</strong> â€“ pÅ™iÅ™azovÃ¡nÃ­ ÃºkolÅ¯, svatebnÃ­ problÃ©m</li>
                <li><strong>Segmentace obrazu</strong> â€“ min-cut pro oddÄ›lenÃ­ objektÅ¯</li>
            </ul>
        </div>
    `;
    flowSection.appendChild(flowLegendDiv);
    
    const flowIntro = document.createElement('p');
    flowIntro.style.color = '#495057';
    flowIntro.innerHTML = 'Pro orientovanÃ½ graf mÅ¯Å¾eme vytvoÅ™it <strong>sÃ­Å¥</strong>: hrany chÃ¡peme jako kapacity a hledÃ¡me maximÃ¡lnÃ­ tok ze zdroje <em>s</em> do cÃ­le <em>t</em>. FordÅ¯v-FulkersonÅ¯v a EdmondsÅ¯v-KarpÅ¯v algoritmus vyuÅ¾Ã­vajÃ­ zlepÅ¡ujÃ­cÃ­ polocesty, GoldbergÅ¯v algoritmus (push-relabel) pracuje s vÃ½Å¡kami uzlÅ¯.';
    flowSection.appendChild(flowIntro);
    const flowInputs = document.createElement('div');
    flowInputs.className = 'query-inputs';
    flowInputs.innerHTML = `
        <input id="flowSource" list="nodes-datalist-flow" placeholder="Zdroj (s)">
        <input id="flowSink" list="nodes-datalist-flow" placeholder="CÃ­l (t)">
        <button id="runFlowAnalysis">Analyzovat tok v sÃ­ti</button>
    `;
    flowSection.appendChild(flowInputs);
    const flowDatalist = document.createElement('datalist');
    flowDatalist.id = 'nodes-datalist-flow';
    flowSection.appendChild(flowDatalist);
    const flowResult = document.createElement('div');
    flowResult.id = 'flowResult';
    flowResult.style.display = 'none';
    flowSection.appendChild(flowResult);
    output.appendChild(flowSection);

    const theorySection = document.createElement('div');
    theorySection.id = 'graphTheoryGuide';
    theorySection.className = 'section';
    theorySection.innerHTML = `
        <h2>ğŸ“˜ TeoretickÃ½ rozcestnÃ­k (grafy)</h2>
        <p style="color: #495057;">KrÃ¡tkÃ½ tahÃ¡k k pojmÅ¯m, kterÃ© pÅ™i prÃ¡ci s grafy nejÄastÄ›ji pouÅ¾Ã­vÃ¡me:</p>
        <ul style="line-height: 1.8; padding-left: 1.25rem;">
            <li><strong>Kostra grafu:</strong> Podgraf, kterÃ½ obsahuje vÅ¡echny uzly a jen tolik hran, aby byl graf stÃ¡le souvislÃ½ (tedy Å¾Ã¡dnÃ© cykly).</li>
            <li><strong>MinimÃ¡lnÃ­ kostra grafu:</strong> Soubor hran s nejniÅ¾Å¡Ã­ moÅ¾nou vÃ¡hou. Typicky ji hledÃ¡me JarnÃ­kÅ¯v-PrimÅ¯v-DijkstrÅ¯v algoritmus nebo Kruskalem.</li>
            <li><strong>MaximÃ¡lnÃ­ kostra grafu:</strong> Analogicky hledÃ¡ nejvyÅ¡Å¡Ã­ celkovou vÃ¡hu â€“ hodÃ­ se napÅ™Ã­klad pro maximalizaci kapacity.</li>
            <li><strong>Laplaceova matice:</strong> L = D - A. PomÃ¡hÃ¡ nÃ¡m spoÄÃ­tat poÄet koster (vÄ›ta o matici stromÅ¯) a popsat spektrÃ¡lnÃ­ vlastnosti grafu.</li>
            <li><strong>JarnÃ­kÅ¯v-PrimÅ¯v-DijkstrÅ¯v algoritmus:</strong> Greedy pÅ™Ã­stup â€“ zaÄneme v nÃ¡hodnÃ©m uzlu a opakovanÄ› pÅ™idÃ¡vÃ¡me nejlevnÄ›jÅ¡Ã­ hranu, kterÃ¡ neuzavÃ­rÃ¡ cyklus.</li>
            <li><strong>KruskalÅ¯v algoritmus:</strong> SeÅ™adÃ­ vÅ¡echny hrany podle vÃ¡hy, pÅ™idÃ¡vÃ¡ je od nejmenÅ¡Ã­ch, a pÅ™es sjednocovÃ¡nÃ­ komponent hlÃ­dÃ¡, aby nevznikaly cykly.</li>
            <li><strong>BorÅ¯vkÅ¯v-SollinÅ¯v algoritmus:</strong> KaÅ¾dÃ¡ komponenta si vybÃ­rÃ¡ svou nejlevnÄ›jÅ¡Ã­ incidentnÃ­ hranu a komponenty se paralelnÄ› spojujÃ­, dokud nezÅ¯stane jedna.</li>
            <li><strong>ProhledÃ¡vÃ¡nÃ­ do Å¡Ã­Å™ky (BFS):</strong> VrstevnatÃ½ prÅ¯chod grafem â€“ nejprve vÅ¡echny sousedy, pak sousedy sousedÅ¯. PouÅ¾Ã­vÃ¡me frontu.</li>
            <li><strong>ProhledÃ¡vÃ¡nÃ­ do hloubky (DFS):</strong> VÅ¾dy pokraÄujeme co nejdÃ¡l, dokud nenarazÃ­me na slepou vÄ›tev, pak se vracÃ­me. PouÅ¾Ã­vÃ¡me zÃ¡sobnÃ­k (nebo rekurzi).</li>
            <li><strong>Tok v sÃ­ti:</strong> OrientovanÃ½ graf s kapacitami hran (sÃ­Å¥) a dvÄ›ma speciÃ¡lnÃ­mi uzly <em>s</em> (zdroj) a <em>t</em> (cÃ­l). HledÃ¡me maximÃ¡lnÃ­ tok, kterÃ½ respektuje kapacitnÃ­ omezenÃ­ i rovnovÃ¡hu v uzlech.</li>
            <li><strong>RezervnÃ­ kapacita cesty:</strong> NejmenÅ¡Ã­ z kapacit (resp. reziduÃ¡lnÃ­ch kapacit) podÃ©l vybranÃ© cesty. UdÃ¡vÃ¡, o kolik lze zvÃ½Å¡it tok po zlepÅ¡ujÃ­cÃ­ polocestÄ›.</li>
            <li><strong>ZlepÅ¡ujÃ­cÃ­ polocesta:</strong> Cesta v reziduÃ¡lnÃ­ sÃ­ti se zÃ¡pasem od <em>s</em> do <em>t</em>, kterÃ¡ mÃ¡ kladnou rezervnÃ­ kapacitu â€“ umoÅ¾Åˆuje zvÃ½Å¡it celkovÃ½ tok.</li>
            <li><strong>FordÅ¯v-FulkersonÅ¯v / EdmondsÅ¯v-KarpÅ¯v algoritmus:</strong> HledajÃ­ zlepÅ¡ujÃ­cÃ­ polocesty (DFS resp. BFS) a iterativnÄ› zvÄ›tÅ¡ujÃ­ tok. EdmondsÅ¯v-Karp garantuje polynomiÃ¡lnÃ­ Äas.</li>
            <li><strong>GoldbergÅ¯v algoritmus (push-relabel):</strong> UdrÅ¾uje vÃ½Å¡ku (label) uzlÅ¯, pÅ™eposÃ­lÃ¡ pÅ™ebytky (push) a dynamicky pÅ™eladÃ­ vÃ½Å¡ky tak, aby byl nalezen maximÃ¡lnÃ­ tok i minimÃ¡lnÃ­ Å™ez.</li>
        </ul>
    `;
    output.appendChild(theorySection);

    // Populate explore datalist
    const exploreDatalist = document.getElementById('nodes-datalist-explore');
    const optimalDatalistEl = document.getElementById('nodes-datalist-optimal');
    const flowDatalistEl = document.getElementById('nodes-datalist-flow');
    const fillDatalist = (listEl) => {
        if (!listEl) return;
        listEl.innerHTML = '';
        graph.nodes.forEach(node => {
            const option = document.createElement('option');
            option.value = node;
            listEl.appendChild(option);
        });
    };
    fillDatalist(exploreDatalist);
    fillDatalist(optimalDatalistEl);
    fillDatalist(flowDatalistEl);

    const optimalButton = document.getElementById('runOptimalPaths');
    if (optimalButton) {
        optimalButton.addEventListener('click', () => {
            const startNode = document.getElementById('optimalStartNode').value.trim();
            const endNode = document.getElementById('optimalEndNode').value.trim();
            const resultDiv = document.getElementById('optimalPathsResult');
            if (!resultDiv) return;
            if (!startNode || !endNode) {
                resultDiv.innerHTML = '<p style="color:#dc3545;">VyplÅˆte prosÃ­m oba uzly.</p>';
                resultDiv.style.display = 'block';
                return;
            }
            const dijkstra = graph.shortestPath(startNode, endNode);
            const moore = graph.mooreShortestPath(startNode, endNode);
            const bellman = graph.bellmanFordPath(startNode, endNode);
            const longest = graph.longestPathInfo(startNode, endNode);
            const safest = graph.safestPath(startNode, endNode);
            const widest = graph.widestPath(startNode, endNode);
            const formatPath = (arr) => (arr && arr.length ? arr.join(' â†’ ') : 'Cesta nenalezena');
            const formatDistance = (val) => {
                if (val === null || val === undefined) return 'â€”';
                if (val === Infinity) return 'âˆ';
                if (!Number.isFinite(val)) return 'â€”';
                const rounded = Math.round((val + Number.EPSILON) * 100) / 100;
                return Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(2);
            };
            let html = '<div class="optimal-grid">';
            // Dijkstra - zpracovÃ¡nÃ­ chyby pro zÃ¡pornÃ© hrany
            let dijkstraError = dijkstra && dijkstra.error ? `<div style="color:#dc3545; margin-top:0.25rem;">âš ï¸ ${dijkstra.error}</div>` : '';
            html += `<div class="result-box">
                <div class="result-label">NejkratÅ¡Ã­ cesta (DijkstrÅ¯v algoritmus)</div>
                <div>VzdÃ¡lenost: ${dijkstra && dijkstra.error ? 'â€”' : formatDistance(dijkstra ? dijkstra.distance : null)}</div>
                <div>Cesta: ${dijkstra && dijkstra.error ? 'Nelze spoÄÃ­tat' : formatPath(dijkstra ? dijkstra.path : [])}</div>
                ${dijkstraError}
            </div>`;
            html += `<div class="result-box">
                <div class="result-label">MoorÅ¯v algoritmus (BFS)</div>
                <div>PoÄet hran: ${moore && moore.distance !== Infinity ? moore.distance : 'Cesta nenalezena'}</div>
                <div>Cesta: ${formatPath(moore ? moore.path : [])}</div>
            </div>`;
            const bellmanWarning = bellman && bellman.negativeCycle ? '<div style="color:#dc3545; margin-top:0.25rem;">VarovÃ¡nÃ­: DetekovÃ¡na zÃ¡pornÃ¡ kruÅ¾nice â€“ vÃ½sledky mohou bÃ½t neplatnÃ©.</div>' : '';
            html += `<div class="result-box">
                <div class="result-label">Bellman-FordÅ¯v algoritmus</div>
                <div>VzdÃ¡lenost: ${formatDistance(bellman ? bellman.distance : null)}</div>
                <div>Cesta: ${formatPath(bellman ? bellman.path : [])}</div>
                ${bellmanWarning}
            </div>`;
            // NejdelÅ¡Ã­ cesta - zpracovÃ¡nÃ­ cyklickÃ©ho grafu
            let longestError = longest && longest.error ? `<div style="color:#dc3545; margin-top:0.25rem;">âš ï¸ ${longest.error}</div>` : '';
            const longestNote = longest && !longest.error && longest.mode === 'dag'
                ? '<div style="font-size:0.85rem; color:#6c757d;">VÃ½poÄet v DAG pomocÃ­ topologickÃ©ho poÅ™adÃ­.</div>'
                : '';
            html += `<div class="result-box">
                <div class="result-label">NejdelÅ¡Ã­ cesta</div>
                <div>DÃ©lka: ${longest && longest.error ? 'â€”' : formatDistance(longest ? longest.weight : null)}</div>
                <div>Cesta: ${longest && longest.error ? 'Nelze urÄit' : formatPath(longest ? longest.path : [])}</div>
                ${longestNote}
                ${longestError}
            </div>`;
            
            // NejbezpeÄnÄ›jÅ¡Ã­ cesta - zpracovÃ¡nÃ­ chyb a zobrazenÃ­ vzorce
            let safestError = safest && safest.error ? `<div style="color:#dc3545; margin-top:0.25rem;">âš ï¸ ${safest.error}</div>` : '';
            const reliability = safest && safest.reliability !== null ? Math.min(1, Math.max(0, safest.reliability || 0)) : 0;
            const totalWeightInfo = safest && safest.totalWeight !== undefined 
                ? `<div style="font-size:0.85rem; color:#6c757d;">SouÄet vah: ${formatDistance(safest.totalWeight)} â†’ r = exp(-${formatDistance(safest.totalWeight)}) = ${(reliability * 100).toFixed(2)}%</div>` 
                : '';
            html += `<div class="result-box">
                <div class="result-label">NejbezpeÄnÄ›jÅ¡Ã­ cesta (maximalizace spolehlivosti)</div>
                <div>Spolehlivost: ${safest && safest.error ? 'â€”' : (reliability * 100).toFixed(2) + ' %'}</div>
                <div>Cesta: ${formatPath(safest ? safest.path : [])}</div>
                ${totalWeightInfo}
                ${safestError}
                <div style="font-size:0.8rem; color:#6c757d; margin-top:0.25rem;">Vzorec: r = exp(âˆ’w), kde w je vÃ¡ha hrany</div>
            </div>`;
            
            // NejÅ¡irÅ¡Ã­ cesta - zpracovÃ¡nÃ­ chyb pro zÃ¡pornÃ© kapacity + podrobnÃ¡ analÃ½za segmentÅ¯
            let widestError = widest && widest.error ? `<div style="color:#dc3545; margin-top:0.25rem;">âš ï¸ ${widest.error}</div>` : '';
            
            // DetailnÃ­ informace o segmentech cesty
            let bottleneckInfo = '';
            let widestSegmentInfo = '';
            let segmentsDetail = '';
            
            if (widest && !widest.error && widest.path && widest.path.length > 1) {
                // Bottleneck (nejuÅ¾Å¡Ã­ Ãºsek = nejvÄ›tÅ¡Ã­ omezenÃ­)
                if (widest.bottleneck) {
                    bottleneckInfo = `<div style="margin-top:0.5rem; padding:0.4rem; background-color:#fff3cd; border-radius:0.25rem; border-left:3px solid #ffc107;">
                        <strong style="color:#856404;">ğŸ”´ Bottleneck (nejuÅ¾Å¡Ã­ Ãºsek):</strong> 
                        ${widest.bottleneck.from} â†’ ${widest.bottleneck.to} 
                        <span style="color:#dc3545; font-weight:bold;">(kapacita: ${formatDistance(widest.bottleneck.capacity)})</span>
                    </div>`;
                }
                
                // NejÅ¡irÅ¡Ã­ segment
                if (widest.widestSegment && widest.bottleneck && 
                    (widest.widestSegment.from !== widest.bottleneck.from || widest.widestSegment.to !== widest.bottleneck.to)) {
                    widestSegmentInfo = `<div style="margin-top:0.25rem; padding:0.4rem; background-color:#d4edda; border-radius:0.25rem; border-left:3px solid #28a745;">
                        <strong style="color:#155724;">ğŸŸ¢ NejÅ¡irÅ¡Ã­ Ãºsek:</strong> 
                        ${widest.widestSegment.from} â†’ ${widest.widestSegment.to} 
                        <span style="color:#28a745; font-weight:bold;">(kapacita: ${formatDistance(widest.widestSegment.capacity)})</span>
                    </div>`;
                }
                
                // Tabulka vÅ¡ech segmentÅ¯ cesty (pokud je vÃ­ce neÅ¾ 1 segment)
                if (widest.segments && widest.segments.length > 1) {
                    segmentsDetail = `<details style="margin-top:0.5rem;">
                        <summary style="cursor:pointer; color:#0d6efd; font-size:0.9rem;">ğŸ“Š Zobrazit vÅ¡echny segmenty cesty (${widest.segments.length})</summary>
                        <table style="width:100%; margin-top:0.5rem; font-size:0.85rem;">
                            <thead>
                                <tr style="background-color:#e9ecef;">
                                    <th style="padding:0.3rem; text-align:left;">Ãšsek</th>
                                    <th style="padding:0.3rem; text-align:right;">Kapacita</th>
                                    <th style="padding:0.3rem; text-align:center;">Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${widest.segments.map(seg => {
                                    const isBottleneck = widest.bottleneck && seg.from === widest.bottleneck.from && seg.to === widest.bottleneck.to;
                                    const isWidest = widest.widestSegment && seg.from === widest.widestSegment.from && seg.to === widest.widestSegment.to;
                                    let statusIcon = '';
                                    let rowStyle = '';
                                    if (isBottleneck) {
                                        statusIcon = 'ğŸ”´ Bottleneck';
                                        rowStyle = 'background-color:#fff3cd;';
                                    } else if (isWidest) {
                                        statusIcon = 'ğŸŸ¢ NejÅ¡irÅ¡Ã­';
                                        rowStyle = 'background-color:#d4edda;';
                                    }
                                    return `<tr style="${rowStyle}">
                                        <td style="padding:0.3rem;">${seg.from} â†’ ${seg.to}</td>
                                        <td style="padding:0.3rem; text-align:right; font-weight:bold;">${formatDistance(seg.capacity)}</td>
                                        <td style="padding:0.3rem; text-align:center;">${statusIcon}</td>
                                    </tr>`;
                                }).join('')}
                            </tbody>
                        </table>
                    </details>`;
                }
            }
            
            html += `<div class="result-box">
                <div class="result-label">NejÅ¡irÅ¡Ã­ cesta (max-min kapacita)</div>
                <div>KritickÃ© hrdlo (Å¡Ã­Å™ka cesty): ${widest && widest.error ? 'â€”' : formatDistance(widest ? widest.width : null)}</div>
                <div>Cesta: ${formatPath(widest ? widest.path : [])}</div>
                ${bottleneckInfo}
                ${widestSegmentInfo}
                ${segmentsDetail}
                ${widestError}
            </div>`;
            html += '</div>';
            html += '<p style="font-size:0.9rem; color:#495057; margin-top:0.75rem;">Tip: Ãºplnou matici nejkratÅ¡Ã­ch cest poskytuje sekce â€NejkratÅ¡Ã­ cesty (Floyd-Warshall)â€œ.</p>';
            resultDiv.innerHTML = html;
            resultDiv.style.display = 'block';
        });
    }

    const cpmButton = document.getElementById('runCpmAnalysis');
    if (cpmButton) {
        cpmButton.addEventListener('click', () => {
            const result = graph.cpmAnalysis();
            const cpmDiv = document.getElementById('cpmResult');
            if (!cpmDiv) return;
            if (!result || result.error) {
                cpmDiv.innerHTML = `<p style="color:#dc3545;">${result && result.error ? result.error : 'AnalÃ½za se nezdaÅ™ila.'}</p>`;
                cpmDiv.style.display = 'block';
                return;
            }
            const formatNum = (val) => Number.isFinite(val) ? (Math.round((val + Number.EPSILON) * 100) / 100).toString() : 'â€”';
            const criticalPath = result.criticalPath && result.criticalPath.length
                ? result.criticalPath.join(' â†’ ')
                : 'Nenalezena';
            let html = `<div class="result-box">
                <div class="result-label">ShrnutÃ­ CPM</div>
                <div><strong>DÃ©lka projektu:</strong> ${formatNum(result.projectDuration)}</div>
                <div><strong>PoÄet kritickÃ½ch ÄinnostÃ­:</strong> ${result.criticalEdgesCount}</div>
                <div><strong>KritickÃ¡ cesta:</strong> ${criticalPath}</div>
            </div>`;
            html += '<h4 style="margin-top: 1rem; margin-bottom: 0.5rem; color: #0d6efd;">ğŸ“ UzlovÃ© Äasy (milnÃ­ky projektu)</h4>';
            html += '<p style="font-size: 0.85rem; color: #6c757d; margin-bottom: 0.5rem;">KaÅ¾dÃ½ uzel pÅ™edstavuje udÃ¡lost/milnÃ­k. ES = nejdÅ™Ã­ve moÅ¾nÃ½ start, EF = nejdÅ™Ã­ve moÅ¾nÃ© ukonÄenÃ­, LS = nejpozdÄ›ji pÅ™Ã­pustnÃ½ start, LF = nejpozdÄ›ji pÅ™Ã­pustnÃ© ukonÄenÃ­.</p>';
            html += '<div class="scrollable-list">';
            html += '<table><thead><tr><th>Uzel</th><th>ES</th><th>EF</th><th>LS</th><th>LF</th><th>Rezerva</th><th>Je kritickÃ½?</th></tr></thead><tbody>';
            result.nodeSummaries.forEach(node => {
                html += `<tr>
                    <td>${node.id}</td>
                    <td>${formatNum(node.es !== undefined ? node.es : node.earliest)}</td>
                    <td>${formatNum(node.ef !== undefined ? node.ef : node.earliest)}</td>
                    <td>${formatNum(node.ls !== undefined ? node.ls : node.latest)}</td>
                    <td>${formatNum(node.lf !== undefined ? node.lf : node.latest)}</td>
                    <td>${formatNum(node.slack)}</td>
                    <td>${node.isCritical ? 'ANO' : 'ne'}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            html += '<h4 style="margin-top: 1.5rem; margin-bottom: 0.5rem; color: #198754;">ğŸ”— HranovÃ© aktivity (Äinnosti projektu)</h4>';
            html += '<p style="font-size: 0.85rem; color: #6c757d; margin-bottom: 0.5rem;">KaÅ¾dÃ¡ hrana pÅ™edstavuje Äinnost s urÄitou dÃ©lkou trvÃ¡nÃ­. ES = nejdÅ™Ã­ve moÅ¾nÃ½ start, EF = nejdÅ™Ã­ve moÅ¾nÃ© ukonÄenÃ­, LS = nejpozdÄ›ji pÅ™Ã­pustnÃ½ start, LF = nejpozdÄ›ji pÅ™Ã­pustnÃ© ukonÄenÃ­.</p>';
            html += '<div class="scrollable-list" style="margin-top:0.5rem;">';
            html += '<table><thead><tr><th>Hrana</th><th>VÃ¡ha hrany</th><th>ES</th><th>EF</th><th>LS</th><th>LF</th><th>Rezerva</th><th>Je kritickÃ¡?</th></tr></thead><tbody>';
            result.activities.forEach(act => {
                const edgeLabel = act.id || `${act.from}â†’${act.to}`;
                html += `<tr>
                    <td>${edgeLabel}</td>
                    <td>${formatNum(act.duration)}</td>
                    <td>${formatNum(act.earlyStart)}</td>
                    <td>${formatNum(act.earlyFinish)}</td>
                    <td>${formatNum(act.lateStart)}</td>
                    <td>${formatNum(act.lateFinish)}</td>
                    <td>${formatNum(act.slack)}</td>
                    <td>${act.isCritical ? 'ANO' : 'ne'}</td>
                </tr>`;
            });
            html += '</tbody></table></div>';
            html += '<p style="font-size:0.9rem; color:#495057; margin-top:0.5rem;">Rezerva Äinnosti (float) = LS âˆ’ ES. ÄŒinnosti s nulovou rezervou tvoÅ™Ã­ kritickou cestu (CPM).</p>';
            cpmDiv.innerHTML = html;
            cpmDiv.style.display = 'block';
        });
    }

    const flowButton = document.getElementById('runFlowAnalysis');
    if (flowButton) {
        flowButton.addEventListener('click', () => {
            const source = document.getElementById('flowSource').value.trim();
            const sink = document.getElementById('flowSink').value.trim();
            const flowDiv = document.getElementById('flowResult');
            if (!flowDiv) return;
            if (!source || !sink) {
                flowDiv.innerHTML = '<p style="color:#dc3545;">Zadejte prosÃ­m zdroj <em>s</em> i cÃ­l <em>t</em>.</p>';
                flowDiv.style.display = 'block';
                return;
            }
            const analysis = graph.flowNetworkAnalysis(source, sink);
            if (!analysis || analysis.error) {
                flowDiv.innerHTML = `<p style="color:#dc3545;">${analysis && analysis.error ? analysis.error : 'AnalÃ½za toku se nezdaÅ™ila.'}</p>`;
                flowDiv.style.display = 'block';
                return;
            }
            const formatNum = (val) => {
                if (!Number.isFinite(val)) return '0';
                const rounded = Math.round((val + Number.EPSILON) * 100) / 100;
                return Number.isInteger(rounded) ? rounded.toString() : rounded.toFixed(2);
            };
            const formatEdges = (edges) => {
                if (!edges || !edges.length) return '<p>Tok nenÃ­ vedenÃ½ Å¾Ã¡dnou hranou.</p>';
                const rows = edges.slice(0, 6).map(edge => {
                    const utilRatio = (edge.utilization !== undefined && edge.utilization !== null)
                        ? edge.utilization
                        : (edge.capacity > 0 ? edge.flow / edge.capacity : 0);
                    const utilPercent = Number.isFinite(utilRatio) ? Math.min(100, Math.max(0, utilRatio * 100)) : 0;
                    return `<li>${edge.from} â†’ ${edge.to}: ${formatNum(edge.flow)} / ${formatNum(edge.capacity)} (vyuÅ¾itÃ­ ${utilPercent.toFixed(1)} %)</li>`;
                }).join('');
                return `<ul>${rows}</ul>`;
            };
            const formatAugPaths = (paths) => {
                if (!paths || !paths.length) return '<li>Å½Ã¡dnÃ¡ zlepÅ¡ujÃ­cÃ­ polocesta nebyla nalezena.</li>';
                return paths.slice(0, 5).map((p, idx) =>
                    `<li>${idx + 1}. ${p.path.join(' â†’ ')} (rezervnÃ­ kapacita cesty: ${formatNum(p.bottleneck)})</li>`
                ).join('');
            };
            const minCut = analysis.minCut || { value: 0, S: [], T: [], edges: [] };
            const cutEdges = (minCut.edges || []).slice(0, 6).map(edge => `${edge.from} â†’ ${edge.to} (${formatNum(edge.capacity)})`).join(', ') || 'â€”';
            const capacityInfo = analysis.capacitySummary || { outFromSource: 0, intoSink: 0 };
            const buildAlgorithmBox = (title, data, extraInfo = '') => {
                if (!data) return '';
                const pathList = data.augmentingPaths
                    ? `<div style="margin-top:0.5rem;"><strong>ZlepÅ¡ujÃ­cÃ­ polocesty:</strong><ul>${formatAugPaths(data.augmentingPaths)}</ul></div>`
                    : '<p style="margin-top:0.5rem; font-size:0.9rem; color:#6c757d;">Push-relabel varianta nepracuje s explicitnÃ­mi polocestami, ale s pÅ™ebytky a vÃ½Å¡kami uzlÅ¯.</p>';
                const extraStats = [];
                if (typeof data.iterations === 'number') {
                    extraStats.push(`<div>PoÄet polocest: ${data.iterations}</div>`);
                }
                if (typeof data.relabelCount === 'number') {
                    extraStats.push(`<div>Relabel operace: ${data.relabelCount}</div>`);
                }
                if (typeof data.pushCount === 'number') {
                    extraStats.push(`<div>Push operace: ${data.pushCount}</div>`);
                }
                if (data.heightProfile) {
                    const interesting = data.heightProfile
                        .filter(h => Number.isFinite(h.height))
                        .sort((a, b) => b.height - a.height)
                        .slice(0, 3)
                        .map(item => `${item.node}: ${item.height}`);
                    if (interesting.length) {
                        extraStats.push(`<div>VÃ½Å¡ky (Goldberg): ${interesting.join(', ')}</div>`);
                    }
                }
                return `<div class="result-box">
                    <div class="result-label">${title}</div>
                    <div><strong>MaximÃ¡lnÃ­ tok:</strong> ${formatNum(data.maxFlow || 0)}</div>
                    ${extraInfo ? `<div>${extraInfo}</div>` : ''}
                    ${extraStats.join('')}
                    <div style="margin-top:0.5rem;"><strong>Toky hran:</strong>${formatEdges(data.flowEdges || [])}</div>
                    ${pathList}
                </div>`;
            };
            let html = `<div class="result-box">
                <div class="result-label">Souhrn sÃ­tÄ›</div>
                <p><strong>Tok v sÃ­ti:</strong> nejlepÅ¡Ã­ dosaÅ¾enÃ½ maximÃ¡lnÃ­ tok je ${formatNum(analysis.bestFlow || 0)} jednotek.</p>
                <p><strong>Kapacita ze zdroje:</strong> ${formatNum(capacityInfo.outFromSource || 0)} | <strong>Kapacita do cÃ­le:</strong> ${formatNum(capacityInfo.intoSink || 0)}</p>
                <p><strong>MinimÃ¡lnÃ­ Å™ez:</strong> ${formatNum(minCut.value || 0)} (S = {${minCut.S.join(', ')}}, T = {${minCut.T.join(', ')}})</p>
                <p><strong>Hrany Å™ezu:</strong> ${cutEdges}</p>
            </div>`;
            html += '<div class="optimal-grid">';
            html += buildAlgorithmBox('FordÅ¯v-FulkersonÅ¯v algoritmus (DFS polocesty)', analysis.fordFulkerson, 'ZlepÅ¡ujÃ­cÃ­ polocesty hledÃ¡me do hloubky.');
            html += buildAlgorithmBox('EdmondsÅ¯v-KarpÅ¯v algoritmus (BFS polocesty)', analysis.edmondsKarp, 'Polocesty jsou nejkratÅ¡Ã­ podle poÄtu hran, proto se tok stabilizuje rychleji.');
            html += buildAlgorithmBox('GoldbergÅ¯v algoritmus (push-relabel)', analysis.goldberg, '');
            html += '</div>';
            html += '<p style="font-size:0.9rem; color:#495057; margin-top:0.5rem;">RezervnÃ­ kapacita cesty = minimum reziduÃ¡lnÃ­ch kapacit na zlepÅ¡ujÃ­cÃ­ polocestÄ›. Jakmile Å¾Ã¡dnÃ¡ takovÃ¡ polocesta neexistuje, aktuÃ¡lnÃ­ tok je maximÃ¡lnÃ­ a odpovÃ­dÃ¡ minimÃ¡lnÃ­mu Å™ezu.</p>';
            flowDiv.innerHTML = html;
            flowDiv.style.display = 'block';
        });
    }

    document.getElementById('runTraversal').addEventListener('click', () => {
        const algo = document.getElementById('traversalAlgo').value;
        const startNode = document.getElementById('startNode').value;
        const graph = new Graph();
        graph.parse(document.getElementById('graphInput').value);
        let result = [];
        if (algo === 'bfs') {
            result = graph.bfsTraversal(startNode);
        } else {
            result = graph.dfsTraversal(startNode);
        }

        let html = `<h4>VÃ½sledek pro ${algo.toUpperCase()} od ${startNode}:</h4>`;
        html += `<p>PoÅ™adÃ­ navÅ¡tÃ­venÃ½ch uzlÅ¯: ${result.join(' â†’ ')}</p>`;
        html += `<p>DosaÅ¾itelnÃ½ch uzlÅ¯: ${result.length}</p>`;

        const exploreResult = document.getElementById('exploreResult');
        exploreResult.innerHTML = html;
        exploreResult.style.display = 'block';
    });

    document.getElementById('runSpanningTree').addEventListener('click', () => {
        const graph = new Graph();
        graph.parse(document.getElementById('graphInput').value);
    const mst = graph.minimumSpanningTree();
    const maxTree = graph.maximumSpanningTree();
    const forestInfo = graph.countSpanningForests();
    
    let html = `<h4>VÃ½sledky analÃ½zy kostry grafu:</h4>`;
    
    if (forestInfo.componentCount === 1) {
        // SouvislÃ½ graf - jednoduchÃ½ vÃ½pis
        const countLabel = Number.isFinite(forestInfo.total) ? forestInfo.total : 'pÅ™Ã­liÅ¡ velkÃ© ÄÃ­slo (nelze bezpeÄnÄ› zobrazit)';
        html += `<p><strong>PoÄet koster:</strong> ${countLabel}</p>`;
    } else {
        // NesouvislÃ½ graf - vÃ½pis po komponentÃ¡ch
        const totalLabel = Number.isFinite(forestInfo.total) ? forestInfo.total : 'pÅ™Ã­liÅ¡ velkÃ© ÄÃ­slo';
        html += `<div style="background-color: #fff3cd; padding: 0.75rem; border-radius: 0.25rem; border: 1px solid #ffc107; margin-bottom: 1rem;">`;
        html += `<p style="margin: 0;"><strong>ğŸŒ² PoÄet spanning forests (lesÅ¯ koster):</strong> ${totalLabel}</p>`;
        html += `<p style="margin: 0.5rem 0 0 0; font-size: 0.9rem; color: #856404;">Graf mÃ¡ ${forestInfo.componentCount} komponent. CelkovÃ½ poÄet spanning forests = souÄin poÄtu koster vÅ¡ech komponent.</p>`;
        html += `<div style="margin-top: 0.5rem;">`;
        forestInfo.perComponent.forEach((comp, idx) => {
            const compCountLabel = Number.isFinite(comp.count) ? comp.count : 'âˆ';
            html += `<div style="font-size: 0.85rem; margin: 0.25rem 0;"><strong>Komponenta ${idx + 1}</strong> (${comp.nodes.length} uzlÅ¯): ${compCountLabel} koster</div>`;
        });
        html += `</div></div>`;
    }

        const renderTreeList = (title, treeData) => {
            const forest = (treeData && treeData.componentTrees && treeData.componentTrees.length)
                ? treeData.componentTrees
                : [{ nodes: graph.nodes, edges: treeData ? treeData.tree : [], totalWeight: treeData ? treeData.totalWeight : 0 }];
            const hasEdges = forest.some(component => component.edges.length);
            if (!hasEdges) {
                return `<p><strong>${title}:</strong> Nelze sestavit â€“ graf nenÃ­ souvislÃ½ nebo neobsahuje Å¾Ã¡dnÃ© hrany.</p>`;
            }

            const componentCount = treeData && typeof treeData.componentCount === 'number'
                ? treeData.componentCount
                : 1;

            let block = `<div style="margin-top: 0.75rem;">
                <strong>${title}${componentCount === 1 ? ` (vÃ¡ha: ${Math.round((treeData.totalWeight + Number.EPSILON) * 100) / 100})` : ''}</strong>`;
            if (componentCount > 1) {
                block += `<p style="margin: 0.25rem 0; font-size: 0.9rem; color: #495057;">Graf mÃ¡ ${componentCount} komponent â€“ zobrazujeme minimÃ¡lnÃ­ kostry jednotlivÃ½ch komponent (spanning forest).</p>`;
            }

            forest.forEach((component, idx) => {
                const compWeight = component.totalWeight !== undefined ? component.totalWeight : component.edges.reduce((sum, edge) => {
                    const w = edge.weight !== null && edge.weight !== undefined ? edge.weight : 1;
                    return sum + w;
                }, 0);
                if (componentCount > 1) {
                    block += `<div style="margin-top:0.5rem; font-weight:600;">Komponenta ${idx + 1} â€“ ${component.nodes.length} uzlÅ¯, vÃ¡ha ${compWeight}</div>`;
                }
                if (!component.edges.length) {
                    block += `<p style="margin:0.25rem 0 0.5rem 0; font-size:0.9rem; color:#6c757d;">Komponenta obsahuje pouze izolovanÃ½ uzel (${component.nodes.join(', ')}).</p>`;
                    return;
                }
                block += '<ul>' + component.edges.map(edge => {
                    const w = edge.weight !== null && edge.weight !== undefined ? edge.weight : 1;
                    return `<li>${edge.u} - ${edge.v} (vÃ¡ha: ${w})${edge.label ? ` â€“ ${edge.label}` : ''}</li>`;
                }).join('') + '</ul>';
            });

            block += '</div>';
            return block;
        };

        html += renderTreeList('MinimÃ¡lnÃ­ kostra (JarnÃ­k-Prim-Dijkstra)', mst);
        html += renderTreeList('MaximÃ¡lnÃ­ kostra (obrÃ¡cenÃ¡ heuristika)', maxTree);
        html += `<p style="margin-top: 0.75rem; font-size: 0.9rem; color: #084298;">
            MinimÃ¡lnÃ­ kostru poÄÃ­tÃ¡me variantou JarnÃ­kova-Primova algoritmu â€“ zaÄÃ­nÃ¡me v jednom uzlu a pÅ™idÃ¡vÃ¡me nejlevnÄ›jÅ¡Ã­ hranu, kterÃ¡ graf drÅ¾Ã­ souvislÃ½.
            MaximÃ¡lnÃ­ kostra vyuÅ¾Ã­vÃ¡ stejnÃ½ princip, ale hrany bereme od nejtÄ›Å¾Å¡Ã­ch k nejlehÄÃ­m, takÅ¾e dostaneme nejdraÅ¾Å¡Ã­ moÅ¾nou kostru.
            CelkovÃ½ poÄet koster zÃ­skÃ¡vÃ¡me pomocÃ­ Laplaceovy matice a vÄ›ty o matici stromÅ¯.
        </p>`;

        const spanningTreeResult = document.getElementById('spanningTreeResult');
        spanningTreeResult.innerHTML = html;
        spanningTreeResult.style.display = 'block';
    });
});

document.addEventListener('change', function(event) {
    if (event.target.classList.contains('matrix-stats-toggle')) {
        const advancedStatsDiv = event.target.nextElementSibling.nextElementSibling;
        if (advancedStatsDiv) {
            advancedStatsDiv.style.display = event.target.checked ? 'block' : 'none';
        }
    }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INSTANT SEASON ENGINE - 0ms switching, GPU only
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function detectSeason() {
    const d = new Date(), m = d.getMonth() + 1, day = d.getDate();
    // SpeciÃ¡lnÃ­ svÃ¡tky majÃ­ prioritu
    if ((m === 10 && day >= 20) || (m === 11 && day <= 2)) return 'halloween';
    if (m === 2 && day >= 10 && day <= 16) return 'valentine';
    if (m === 12 || (m === 1 && day <= 6)) return 'christmas';
    // RoÄnÃ­ obdobÃ­
    if (m >= 3 && m <= 5) return 'spring';
    if (m >= 6 && m <= 8) return 'summer';
    if (m >= 9 && m <= 11) return 'autumn';
    return 'winter';
}

function prerenderDecorations() {
    const w = window.innerWidth;
    
    // ğŸ„ Christmas - lights
    const lightsContainer = document.getElementById('lightsContainer');
    if (lightsContainer && !lightsContainer.hasChildNodes()) {
        const colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
        const count = Math.floor(w / 45);
        for (let i = 0; i < count; i++) {
            const light = document.createElement('div');
            light.className = 'light ' + colors[i % colors.length];
            light.style.animationDelay = (i * 0.1 % 2) + 's, ' + (i * 0.15 % 2) + 's';
            lightsContainer.appendChild(light);
        }
    }
    
    // â„ï¸ Winter - snowflakes
    const winterDeco = document.getElementById('winterDeco');
    if (winterDeco && !winterDeco.hasChildNodes()) {
        const chars = ['â„', 'â…', 'â†', 'âœ»', 'âœ¼'];
        for (let i = 0; i < 35; i++) {
            const el = document.createElement('div');
            el.className = 'snowflake';
            el.textContent = chars[i % chars.length];
            el.style.left = (i * 2.9) + '%';
            el.style.fontSize = (0.6 + (i % 3) * 0.4) + 'em';
            el.style.animationDuration = (6 + (i % 5)) + 's';
            el.style.animationDelay = (i * 0.3) + 's';
            el.style.opacity = 0.6 + (i % 4) * 0.1;
            winterDeco.appendChild(el);
        }
    }
    
    // ğŸŒ¸ Spring - sakura
    const springDeco = document.getElementById('springDeco');
    if (springDeco && !springDeco.hasChildNodes()) {
        const chars = ['ğŸŒ¸', 'ğŸµï¸', 'ğŸ’®', 'ğŸ¦‹'];
        for (let i = 0; i < 30; i++) {
            const el = document.createElement('div');
            el.className = 'sakura';
            el.textContent = chars[i % chars.length];
            el.style.left = (i * 3.3) + '%';
            el.style.fontSize = (0.8 + (i % 3) * 0.3) + 'em';
            el.style.animationDuration = (8 + (i % 6)) + 's';
            el.style.animationDelay = (i * 0.4) + 's';
            springDeco.appendChild(el);
        }
    }
    
    // â˜€ï¸ Summer - bubbles
    const summerDeco = document.getElementById('summerDeco');
    if (summerDeco && !summerDeco.hasChildNodes()) {
        for (let i = 0; i < 20; i++) {
            const el = document.createElement('div');
            el.className = 'bubble';
            const size = 12 + (i % 5) * 8;
            el.style.width = size + 'px';
            el.style.height = size + 'px';
            el.style.left = (i * 5) + '%';
            el.style.animationDuration = (10 + (i % 8)) + 's';
            el.style.animationDelay = (i * 0.7) + 's';
            summerDeco.appendChild(el);
        }
    }
    
    // ğŸ‚ Autumn - leaves
    const autumnDeco = document.getElementById('autumnDeco');
    if (autumnDeco && !autumnDeco.hasChildNodes()) {
        const chars = ['ğŸ‚', 'ğŸ', 'ğŸƒ', 'ğŸŒ°'];
        for (let i = 0; i < 25; i++) {
            const el = document.createElement('div');
            el.className = 'leaf';
            el.textContent = chars[i % chars.length];
            el.style.left = (i * 4) + '%';
            el.style.fontSize = (1 + (i % 3) * 0.4) + 'em';
            el.style.animationDuration = (10 + (i % 8)) + 's';
            el.style.animationDelay = (i * 0.5) + 's';
            autumnDeco.appendChild(el);
        }
    }
    
    // ğŸƒ Halloween
    const halloweenDeco = document.getElementById('halloweenDeco');
    if (halloweenDeco && !halloweenDeco.hasChildNodes()) {
        const count = Math.floor(w / 70);
        for (let i = 0; i < count; i++) {
            const el = document.createElement('div');
            el.className = i % 2 === 0 ? 'bat' : 'pumpkin';
            el.textContent = i % 2 === 0 ? 'ğŸ¦‡' : 'ğŸƒ';
            el.style.left = (i * 70 + 10) + 'px';
            el.style.top = (12 + (i % 3) * 10) + 'px';
            el.style.fontSize = (1.4 + (i % 2) * 0.4) + 'em';
            el.style.animationDelay = (i * 0.2) + 's';
            halloweenDeco.appendChild(el);
        }
    }
    
    // ğŸ’• Valentine
    const valentineDeco = document.getElementById('valentineDeco');
    if (valentineDeco && !valentineDeco.hasChildNodes()) {
        const chars = ['â¤ï¸', 'ğŸ’•', 'ğŸ’–', 'ğŸ’—', 'ğŸ’“', 'ğŸ’˜'];
        for (let i = 0; i < 30; i++) {
            const el = document.createElement('div');
            el.className = 'heart';
            el.textContent = chars[i % chars.length];
            el.style.left = (i * 3.3) + '%';
            el.style.fontSize = (0.9 + (i % 3) * 0.3) + 'em';
            el.style.animationDuration = (7 + (i % 5)) + 's';
            el.style.animationDelay = (i * 0.35) + 's';
            valentineDeco.appendChild(el);
        }
    }
}

function initSeason() {
    prerenderDecorations();
    const season = detectSeason();
    // Remove any existing season class
    document.body.className = document.body.className.replace(/season-\w+/g, '').trim();
    document.body.classList.add('season-' + season);
}

// Init
initTheme();
initSeason();
window.addEventListener('resize', () => {
    // Only regenerate halloween (depends on width), others are % based
    const h = document.getElementById('halloweenDeco');
    if (h) { h.innerHTML = ''; prerenderDecorations(); }
});
</script>
</body>
</html>
