<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="utf-8">
    <title>Graph Analyzer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background-color: #f8f9fa;
            color: #212529;
        }
        h1, h2, h3 {
            color: #0d6efd;
        }
        textarea {
            width: 100%;
            max-width: 100%;
            min-height: 160px;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            font-family: monospace;
            margin-bottom: 1rem;
        }
        button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background-color: #0d6efd;
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            margin-bottom: 1rem;
            margin-right: 0.5rem;
        }
        button:hover {
            background-color: #0b5ed7;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 0.25rem 0.5rem;
            text-align: center;
        }
        th {
            background-color: #e9ecef;
        }
        .matrix {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        .section {
            margin-bottom: 2rem;
        }
        .properties span {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            padding: 0.25rem 0.5rem;
            background-color: #e2e3e5;
            border-radius: 0.25rem;
        }
        .query-section {
            background-color: #fff;
            padding: 1rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
        }
        .query-inputs {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .query-inputs select {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
        }
        .query-result {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: #e7f3ff;
            border-radius: 0.25rem;
            font-weight: bold;
        }
        .scrollable-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            padding: 0.5rem;
            background-color: #fff;
        }
        .degree-info {
            display: inline-block;
            margin-left: 0.5rem;
            color: #6c757d;
            font-size: 0.9em;
        }
        .highlight {
            background-color: #ffc107 !important;
        }
    </style>
</head>
<body>
<div id="matrix-stats-tooltip" style="position: absolute; display: none; background-color: rgba(0,0,0,0.8); color: white; padding: 8px 12px; border-radius: 5px; pointer-events: none; z-index: 1000; font-size: 0.9em; line-height: 1.5;"></div>
<h1>Graph Analyzer</h1>
<p>Zadejte definici grafu ve form√°tu uveden√©m v zad√°n√≠. Ka≈æd√Ω uzel se definuje
pomoc√≠ ≈ô√°dku zaƒç√≠naj√≠c√≠ho <code>u</code> a ka≈æd√° hrana pomoc√≠ ≈ô√°dku zaƒç√≠naj√≠c√≠ho
<code>h</code>. Orientace hrany se urƒçuje ≈°ipkami <code>&lt;</code>, <code>&gt;</code> nebo
pomlƒçkou <code>-</code>. Ohodnocen√≠ je voliteln√©.</p>
<textarea id="graphInput">u A;
u B;
h A &gt; B 1 :h1;
u C;
h B &gt; C 1 :h2;
u D;
h A &gt; D 2 :h3;
u E;
h A &lt; E 2 :h4;
h B &lt; E 3 :h5;
h C &gt; E 3 :h6;
h D &gt; E 4 :h8;
u F;
h C &gt; F 4 :h7;
h E &gt; F 5 :h9;
u G;
h D &lt; G 5 :h10;
h E &gt; G 6 :h11;
u H;
h H &gt; E 6 :h12;
h F &gt; H 7 :h13;
h G &lt; H 7 :h14;</textarea>
<button id="parseBtn">Analyzovat graf</button>

<div id="counters" style="margin: 1rem 0; padding: 1rem; background-color: #e7f3ff; border: 1px solid #0d6efd; border-radius: 0.25rem; display: none;">
    <h3 style="margin-top: 0; color: #0d6efd;">üìä Z√°kladn√≠ statistiky</h3>
    <div style="display: flex; gap: 2rem; font-size: 1.1rem; flex-wrap: wrap;">
        <div><strong>Poƒçet uzl≈Ø:</strong> <span id="nodeCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
        <div><strong>Poƒçet hran:</strong> <span id="edgeCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
        <div><strong>Poƒçet komponent:</strong> <span id="componentCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
    </div>
    <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #b6d4fe; font-size: 0.9rem; color: #084298;">
        üí° <strong>Komponenta</strong> = oddƒõlen√° ƒç√°st grafu (1 komponenta = graf je souvisl√Ω)
    </div>
</div>

<div id="output"></div>

<script>
// Graph analyzer with optimizations for large graphs
class Graph {
    constructor() {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        this._cachedProperties = null; // ‚ö° CACHE pro properties()
    }

    parse(text) {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        this._cachedProperties = null; // ‚ö° Invalidate cache p≈ôi zmƒõnƒõ
        
        const lines = text.split(/\r?\n/);
        const nodePattern = /^u\s+([^\s;]+)(?:\s+([-+]?[0-9]*\.?[0-9]+))?\s*;/i;
        const edgePattern = /^h\s+([^\s<>-]+)\s*([<>-])\s*([^\s<>-]+)\s*(?:([-+]?[0-9]*\.?[0-9]+))?\s*(?::([^;]+))?\s*;/i;
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            let m;
            if ((m = nodePattern.exec(trimmed))) {
                const id = m[1];
                if (id === '*') continue;
                const weight = m[2] !== undefined ? parseFloat(m[2]) : null;
                if (!this.nodes.includes(id)) {
                    this.nodes.push(id);
                    this.nodeWeights[id] = weight;
                }
            } else if ((m = edgePattern.exec(trimmed))) {
                const u = m[1];
                const direction = m[2];
                const v = m[3];
                const weight = m[4] !== undefined ? parseFloat(m[4]) : null;
                const label = m[5] ? m[5].trim() : null;
                this.edges.push({ u, v, direction, weight, label });
            }
        }
        this.edges = this.edges.filter(e => this.nodes.includes(e.u) && this.nodes.includes(e.v));
    }

    adjacencyMatrix(binary = false) {
        if (!binary && this._cachedAdjMatrix) return this._cachedAdjMatrix;
        
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const mat = Array.from({ length: n }, () => Array(n).fill(0));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                mat[i][j] += 1;
            } else if (e.direction === '<') {
                mat[j][i] += 1;
            } else {
                mat[i][j] += 1;
                mat[j][i] += 1;
            }
        }
        
        if (binary) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    mat[i][j] = mat[i][j] > 0 ? 1 : 0;
                }
            }
        } else {
            this._cachedAdjMatrix = mat;
        }
        
        return mat;
    }

    // Optimized: query single cell instead of computing full matrix
    adjacencyValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) count++;
            else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) count++;
            else if (e.direction === '-' && 
                     ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) count++;
        }
        return count;
    }

    lengthMatrix() {
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const INF = Infinity;
        const mat = Array.from({ length: n }, (_, i) => 
            Array.from({ length: n }, (__, j) => i === j ? 0 : INF));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                if (w < mat[i][j]) mat[i][j] = w;
            } else if (e.direction === '<') {
                if (w < mat[j][i]) mat[j][i] = w;
            } else {
                if (w < mat[i][j]) mat[i][j] = w;
                if (w < mat[j][i]) mat[j][i] = w;
            }
        }
        return mat;
    }

    // Optimized: query single cell
    lengthValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        if (nodeU === nodeV) return 0;
        
        let minWeight = Infinity;
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '-' && 
                       ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) {
                minWeight = Math.min(minWeight, w);
            }
        }
        return minWeight;
    }

    signMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const S = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                S[i][j] = A[i][j] - A[j][i];
            }
        }
        return S;
    }

    signValue(nodeU, nodeV) {
        const adjUV = this.adjacencyValue(nodeU, nodeV);
        const adjVU = this.adjacencyValue(nodeV, nodeU);
        if (adjUV === null || adjVU === null) return null;
        return adjUV - adjVU;
    }

    static multiplyMatrices(X, Y) {
        const n = X.length;
        const result = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let k = 0; k < n; k++) {
                if (X[i][k] === 0) continue;
                for (let j = 0; j < n; j++) {
                    if (Y[k][j] === 0) continue;
                    result[i][j] += X[i][k] * Y[k][j];
                }
            }
        }
        return result;
    }

    adjacencyPower(k) {
        let A = this.adjacencyMatrix();
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result;
    }

    // Optimized: compute power for specific cell
    adjacencyPowerValue(nodeU, nodeV, k) {
        const A = this.adjacencyMatrix();
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result[uIdx][vIdx];
    }

    // Laplacian matrix L = D - A
    laplacianMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const L = Array.from({ length: n }, () => Array(n).fill(0));
        
        // ‚ö° OPRAVA: Pro orientovan√© grafy pou≈æij OUT-degree!
        const props = this.properties();
        const isDirected = props.oriented === 'orientovan√Ω';
        
        // Compute degree for each node
        for (let i = 0; i < n; i++) {
            let degree = 0;
            
            if (isDirected) {
                // ‚úÖ OUT-degree pro orientovan√© (jen hrany ven)
                for (let j = 0; j < n; j++) {
                    degree += A[i][j]; // Souƒçet ≈ô√°dku = out-degree
                }
            } else {
                // ‚úÖ Celkov√Ω stupe≈à pro neorientovan√©
                for (let j = 0; j < n; j++) {
                    degree += A[i][j];
                }
            }
            
            L[i][i] = degree; // Diagonal: degree
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    L[i][j] = -A[i][j]; // Off-diagonal: -A[i][j]
                }
            }
        }
        return L;
    }

    // Get single value from Laplacian matrix
    laplacianValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        if (uIdx === vIdx) {
            // ‚ö° OPRAVA: Diagonal = out-degree pro orientovan√© grafy
            const props = this.properties();
            const isDirected = props.oriented === 'orientovan√Ω';
            
            let degree = 0;
            for (const e of this.edges) {
                if (isDirected) {
                    // ‚úÖ Poƒç√≠tej jen hrany VYCH√ÅZEJ√çC√ç z nodeU
                    if (e.direction === '>' && e.u === nodeU) degree++;
                    else if (e.direction === '<' && e.v === nodeU) degree++;
                    // Smyƒçka v orientovan√©m grafu
                    else if (e.direction === '-' && e.u === nodeU && e.v === nodeU) degree += 2;
                    else if (e.direction === '-' && (e.u === nodeU || e.v === nodeU)) degree++;
                } else {
                    // ‚úÖ Pro neorientovan√© poƒç√≠tej v≈°echny dot√Ωkaj√≠c√≠ se hrany
                    if (e.u === nodeU || e.v === nodeU) {
                        if (e.u === e.v) degree += 2; // Loop counts twice
                        else degree += 1;
                    }
                }
            }
            return degree;
        } else {
            // Off-diagonal: -A[i][j]
            return -this.adjacencyValue(nodeU, nodeV);
        }
    }

    // Sum of all walks from length 1 to k
    sumWalksValue(nodeU, nodeV, k) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        const A = this.adjacencyMatrix();
        let sum = 0;
        let currentPower = A;
        
        for (let i = 1; i <= k; i++) {
            sum += currentPower[uIdx][vIdx];
            if (i < k) {
                currentPower = Graph.multiplyMatrices(currentPower, A);
            }
        }
        return sum;
    }

    // Multiplicity: count all edges between U and V (regardless of direction for undirected)
    multiplicityValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            // Count all edges connecting these two nodes
            if ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU)) {
                count++;
            }
        }
        return count;
    }

    // Reachability matrix (transitive closure)
    reachability() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const R = A.map(row => row.map(v => v > 0 ? 1 : 0));
        
        // Floyd-Warshall on binary matrix
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                if (R[i][k] === 1) {
                    for (let j = 0; j < n; j++) {
                        if (R[k][j] === 1) R[i][j] = 1;
                    }
                }
            }
        }
        return R;
    }

    // BFS Layers from start node
    bfsLayers(startNode) {
        const idx = this.nodes.indexOf(startNode);
        if (idx === -1) return {};
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const layers = { 0: [startNode] };
        const seen = new Set([idx]);
        let frontier = [idx];
        let k = 0;
        
        while (frontier.length) {
            const next = [];
            for (const u of frontier) {
                for (const v of adjList[u]) {
                    if (!seen.has(v)) {
                        seen.add(v);
                        next.push(v);
                    }
                }
            }
            if (!next.length) break;
            k++;
            layers[k] = next.map(i => this.nodes[i]).sort();
            frontier = next;
        }
        return layers;
    }

    // All shortest paths (unweighted BFS)
    allShortestPathsUnweighted(src, dst) {
        const srcIdx = this.nodes.indexOf(src);
        const dstIdx = this.nodes.indexOf(dst);
        if (srcIdx === -1 || dstIdx === -1) return [];
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list (outgoing edges)
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const dist = Array(n).fill(Infinity);
        dist[srcIdx] = 0;
        const parents = Array.from({ length: n }, () => []);
        const queue = [srcIdx];
        
        while (queue.length) {
            const u = queue.shift();
            for (const v of adjList[u]) {
                if (dist[v] === Infinity) {
                    dist[v] = dist[u] + 1;
                    parents[v].push(u);
                    queue.push(v);
                } else if (dist[v] === dist[u] + 1) {
                    parents[v].push(u);
                }
            }
        }
        
        if (dist[dstIdx] === Infinity) return [];
        
        // Reconstruct all paths
        const paths = [];
        const stack = [dstIdx];
        
        const reconstruct = (v) => {
            if (v === srcIdx) {
                paths.push(stack.slice().reverse().map(i => this.nodes[i]));
                return;
            }
            for (const p of parents[v]) {
                stack.push(p);
                reconstruct(p);
                stack.pop();
            }
        };
        
        reconstruct(dstIdx);
        return paths;
    }

    // Simple paths up to length K (no repeated nodes)
    simplePathsUpTo(srcNode, dstNode, K = null, cap = 10000) {
        const srcIdx = this.nodes.indexOf(srcNode);
        const dstIdx = this.nodes.indexOf(dstNode);
        if (srcIdx === -1 || dstIdx === -1) return { count: 0, paths: [] };
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const maxLen = (K === null) ? (n - 1) : K;
        const paths = [];
        let count = 0;
        const visited = new Set();
        
        const dfs = (u, depth, acc) => {
            if (count >= cap) return;
            if (u === dstIdx) {
                paths.push(acc.map(i => this.nodes[i]));
                count++;
                return;
            }
            if (depth === 0) return;
            
            for (const w of adjList[u]) {
                if (visited.has(w)) continue;
                visited.add(w);
                acc.push(w);
                dfs(w, depth - 1, acc);
                acc.pop();
                visited.delete(w);
            }
        };
        
        visited.add(srcIdx);
        dfs(srcIdx, maxLen, [srcIdx]);
        visited.delete(srcIdx);
        
        return { count, paths };
    }

    // Neighbor sets by direction
    neighborSets(nodeU) {
        const out = new Set();
        const inn = new Set();
        const und = new Set();
        
        for (const e of this.edges) {
            if (e.direction === '>') {
                if (e.u === nodeU) out.add(e.v);
                if (e.v === nodeU) inn.add(e.u);
            } else if (e.direction === '<') {
                if (e.v === nodeU) out.add(e.u);
                if (e.u === nodeU) inn.add(e.v);
            } else {
                if (e.u === nodeU) und.add(e.v);
                if (e.v === nodeU) und.add(e.u);
            }
        }
        
        return {
            out: [...out].sort(),
            inn: [...inn].sort(),
            und: [...und].sort()
        };
    }

    incidenceMatrix(signed = true) {
        const n = this.nodes.length;
        const m = this.edges.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const inc = Array.from({ length: n }, () => Array(m).fill(0));
        
        this.edges.forEach((e, ci) => {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                if (signed) {
                    inc[i][ci] = -1;
                    inc[j][ci] = 1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else if (e.direction === '<') {
                if (signed) {
                    inc[j][ci] = 1;
                    inc[i][ci] = -1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else {
                inc[i][ci] = 1;
                inc[j][ci] = 1;
            }
        });
        return inc;
    }

    floydWarshall() {
        const n = this.nodes.length;
        const dist = this.lengthMatrix().map(row => row.slice());
        const pred = Array.from({ length: n }, () => Array(n).fill(null));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    pred[i][j] = i;
                }
            }
        }
        
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const alt = dist[i][k] + dist[k][j];
                    if (alt < dist[i][j]) {
                        dist[i][j] = alt;
                        pred[i][j] = pred[k][j];
                    }
                }
            }
        }
        return { dist, pred };
    }

    // Optimized: compute shortest path for specific pair
    shortestPath(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        // Simple Dijkstra for single source-target
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const visited = Array(n).fill(false);
        const pred = Array(n).fill(null);
        dist[uIdx] = 0;
        
        for (let count = 0; count < n; count++) {
            let minDist = Infinity;
            let u = -1;
            for (let i = 0; i < n; i++) {
                if (!visited[i] && dist[i] < minDist) {
                    minDist = dist[i];
                    u = i;
                }
            }
            if (u === -1 || u === vIdx) break;
            visited[u] = true;
            
            for (const e of this.edges) {
                const w = e.weight !== null ? e.weight : 1;
                let vNeighbor = -1;
                if (e.direction === '>' && e.u === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.v);
                } else if (e.direction === '<' && e.v === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.u);
                } else if (e.direction === '-') {
                    if (e.u === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.v);
                    else if (e.v === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.u);
                }
                
                if (vNeighbor !== -1 && !visited[vNeighbor]) {
                    const alt = dist[u] + w;
                    if (alt < dist[vNeighbor]) {
                        dist[vNeighbor] = alt;
                        pred[vNeighbor] = u;
                    }
                }
            }
        }
        
        // Reconstruct path
        const path = [];
        if (dist[vIdx] < Infinity) {
            let current = vIdx;
            while (current !== null) {
                path.unshift(this.nodes[current]);
                current = pred[current];
            }
        }
        
        return {
            distance: dist[vIdx],
            predecessor: pred[vIdx] !== null ? this.nodes[pred[vIdx]] : null,
            path: path
        };
    }

    incidentEdges() {
        const map = {};
        this.nodes.forEach(id => { map[id] = []; });
        this.edges.forEach(e => {
            const desc = e.label ? e.label : `${e.u}${e.direction}${e.v}`;
            map[e.u].push(desc);
            map[e.v].push(desc);
        });
        return map;
    }

    neighbours() {
        const map = {};
        this.nodes.forEach(id => { map[id] = new Set(); });
        this.edges.forEach(e => {
            map[e.u].add(e.v);
            map[e.v].add(e.u);
        });
        const result = {};
        for (const id of this.nodes) {
            result[id] = Array.from(map[id]);
        }
        return result;
    }

    // Compute and cache degrees
    degrees() {
        if (this._cachedDegrees) return this._cachedDegrees;
        
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            if (e.u === e.v) {
                degrees[e.u] += 2;
            } else {
                degrees[e.u] += 1;
                degrees[e.v] += 1;
            }
        }
        this._cachedDegrees = degrees;
        return degrees;
    }

    // Check if directed graph is strongly connected using Kosaraju's algorithm
    // ‚ö° VYLEP≈†EN√ç 12: Optimalizovan√° strongly connected detection
    isStronglyConnected() {
        const n = this.nodes.length;
        if (n === 0) return true;
        if (n === 1) return true; // ‚ö° Single node is trivially strongly connected
        
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        
        // ‚ö° Build adjacency list AND reverse graph v jednom pr≈Øchodu!
        const adjList = Array.from({ length: n }, () => []);
        const reverseAdj = Array.from({ length: n }, () => []);
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                adjList[i].push(j);
                reverseAdj[j].push(i); // ‚ö° Build reverse souƒçasnƒõ
            } else if (e.direction === '<') {
                adjList[j].push(i);
                reverseAdj[i].push(j);
            } else {
                // Undirected edge - add both directions
                adjList[i].push(j);
                adjList[j].push(i);
                reverseAdj[i].push(j);
                reverseAdj[j].push(i);
            }
        }
        
        // DFS from first node - inline pro rychlost
        const visited = new Array(n).fill(false);
        const stack = [0];
        visited[0] = true;
        let count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of adjList[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        if (count !== n) return false; // ‚ö° Early exit
        
        // DFS on reverse graph - ji≈æ m√°me reverseAdj!
        visited.fill(false);
        stack.length = 0; // ‚ö° Reuse array
        stack.push(0);
        visited[0] = true;
        count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of reverseAdj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        return count === n;
    }

    // ‚ö° VYLEP≈†EN√ç 14: Poƒç√≠t√°n√≠ komponent grafu (slab√© komponenty)
    countComponents() {
        const n = this.nodes.length;
        if (n === 0) return 0;
        
        const visited = new Set();
        let components = 0;
        
        // Build adjacency list (ignoruj orientaci hran)
        const adj = {};
        this.nodes.forEach(id => adj[id] = new Set());
        for (const e of this.edges) {
            adj[e.u].add(e.v);
            adj[e.v].add(e.u); // Obousmƒõrnƒõ pro slab√© komponenty
        }
        
        // BFS pro ka≈ædou komponentu
        for (const start of this.nodes) {
            if (visited.has(start)) continue;
            
            components++;
            const queue = [start];
            visited.add(start);
            
            while (queue.length) {
                const u = queue.shift();
                for (const v of adj[u]) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                    }
                }
            }
        }
        
        return components;
    }
    
    // Vrac√≠ detailn√≠ informace o komponent√°ch (reprezentant + seznam uzl≈Ø)
    getComponents() {
        const n = this.nodes.length;
        if (n === 0) return [];
        
        const visited = new Set();
        const components = [];
        
        // Build adjacency list (ignoruj orientaci hran)
        const adj = {};
        this.nodes.forEach(id => adj[id] = new Set());
        for (const e of this.edges) {
            adj[e.u].add(e.v);
            adj[e.v].add(e.u); // Obousmƒõrnƒõ pro slab√© komponenty
        }
        
        // BFS pro ka≈ædou komponentu
        for (const start of this.nodes) {
            if (visited.has(start)) continue;
            
            const componentNodes = [];
            const queue = [start];
            visited.add(start);
            componentNodes.push(start);
            
            while (queue.length) {
                const u = queue.shift();
                for (const v of adj[u]) {
                    if (!visited.has(v)) {
                        visited.add(v);
                        queue.push(v);
                        componentNodes.push(v);
                    }
                }
            }
            
            components.push({
                root: start,  // Prvn√≠ nalezen√Ω uzel (reprezentant)
                nodes: componentNodes.sort(),
                size: componentNodes.length
            });
        }
        
        return components.sort((a, b) => b.size - a.size); // Se≈ôaƒè podle velikosti
    }

    // Find all multiple edges in the graph
    findMultipleEdges() {
        const edgeMap = new Map();
        const multipleEdges = [];
        
        for (const e of this.edges) {
            // Create key based on nodes and direction
            let key;
            if (e.direction === '>') {
                key = `${e.u}>${e.v}`;
            } else if (e.direction === '<') {
                key = `${e.v}>${e.u}`;
            } else {
                // For undirected edges, normalize the key
                key = e.u <= e.v ? `${e.u}-${e.v}` : `${e.v}-${e.u}`;
            }
            
            if (!edgeMap.has(key)) {
                edgeMap.set(key, []);
            }
            edgeMap.get(key).push(e);
        }
        
        // Find groups with multiple edges
        for (const [key, edges] of edgeMap.entries()) {
            if (edges.length > 1) {
                multipleEdges.push({
                    key: key,
                    count: edges.length,
                    edges: edges
                });
            }
        }
        
        return multipleEdges;
    }

    
    properties() {
        // ‚ö° VYLEP≈†EN√ç 10: Memoizace properties() - obrovsk√Ω speedup!
        if (this._cachedProperties) return this._cachedProperties;
        
        const props = {};
        const n = this.nodes.length;
        
        // Weighted: any edge weight specified and different from 1, or any node has weight
        let weightedEdge = false;
        for (const e of this.edges) {
            if (e.weight !== null && e.weight !== undefined && e.weight !== 1) {
                weightedEdge = true;
                break;
            }
        }
        let weightedNode = false;
        for (const id of this.nodes) {
            const w = this.nodeWeights[id];
            if (w !== null && w !== undefined) {
                weightedNode = true;
                break;
            }
        }
        props.weighted = weightedEdge || weightedNode;
        
        // Orientation: determine if graph is directed, undirected or mixed
        let hasDirected = false;
        let hasUndirected = false;
        for (const e of this.edges) {
            if (e.direction === '-' || e.direction === '‚Äì') hasUndirected = true;
            else hasDirected = true;
        }
        if (hasDirected && !hasUndirected) props.oriented = 'orientovan√Ω';
        else if (!hasDirected && hasUndirected) props.oriented = 'neorientovan√Ω';
        else props.oriented = 'sm√≠≈°en√Ω';
        
        // Connectivity: BFS on underlying undirected graph
        const visited = new Array(n).fill(false);
        if (n > 0) {
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            const neighbours = this.neighbours();
            const queue = [0];
            visited[0] = true;
            while (queue.length > 0) {
                const i = queue.shift();
                const u = this.nodes[i];
                for (const v of neighbours[u]) {
                    const j = idx[v];
                    if (!visited[j]) {
                        visited[j] = true;
                        queue.push(j);
                    }
                }
            }
        }
        props.connected = visited.every(v => v);
        
        // ‚ö° OPRAVA: Strong a weak connectivity pro orientovan√© grafy
        // Pokud je silnƒõ souvisl√Ω ‚Üí automaticky slabƒõ souvisl√Ω (zobraz√≠me jen "silnƒõ")
        // Pokud nen√≠ silnƒõ, ale je weakly ‚Üí zobraz√≠me "slabƒõ"
        if (props.oriented === 'orientovan√Ω') {
            props.stronglyConnected = this.isStronglyConnected();
            // Weakly connected = connected v podkladov√©m neorientovan√©m grafu
            // ALE zobraz√≠me jen pokud nen√≠ strongly connected
            props.weaklyConnected = !props.stronglyConnected && props.connected;
        }
        
        // Finite: always true for parsed input
        props.finite = true;
        
        // ‚ö° VYLEP≈†EN√ç 11: Loops + multiple edges + degrees v JEDNOM pr≈Øchodu
        let loops = 0;
        const edgeSet = new Set();
        let multiEdges = false;
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            // Poƒç√≠tej stupnƒõ souƒçasnƒõ
            if (e.u === e.v) {
                loops++;
                degrees[e.u] += 2; // Smyƒçka p≈ôid√° stupe≈à 2
                continue;
            }
            
            degrees[e.u] += 1;
            degrees[e.v] += 1;
            
            // Check multiple edges
            const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
            if (edgeSet.has(key)) {
                multiEdges = true;
                // Nekonƒç√≠me - mus√≠me dopoƒç√≠tat degrees!
            } else {
                edgeSet.add(key);
            }
        }
        
        props.prosty = !multiEdges;
        props.jednoduchy = !multiEdges && loops === 0;
        
        // ‚ö° NOV√â: Multigraf (existuj√≠ n√°sobn√© hrany)
        props.multigraph = multiEdges;
        
        // ‚ö° NOV√â: Diskr√©tn√≠ graf (≈æ√°dn√© hrany)
        props.discrete = this.edges.length === 0;
        
        // ‚ö° VYLEP≈†EN√ç 13: Complete graph - vyu≈æij u≈æ existuj√≠c√≠ edgeSet!
        if (n > 50) {
            props.complete = false;
        } else {
            // edgeSet u≈æ m√°me z v√Ωpoƒçtu multiple edges v√Ω≈°e!
            const expectedEdges = (n * (n - 1)) / 2;
            props.complete = (edgeSet.size === expectedEdges) && !multiEdges && loops === 0;
        }
        
        // ‚ö° Regular: degrees u≈æ m√°me spoƒç√≠tan√© v√Ω≈°e!
        const degValues = Object.values(degrees);
        const firstDeg = degValues[0];
        props.regular = degValues.every(d => d === firstDeg);
        
        // Bipartite: OPTIMIZED - early exit on odd cycle
        props.bipartite = (() => {
            if (n === 0) return true;
            const colours = new Array(n).fill(-1);
            const neighbours = this.neighbours();
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            
            for (let start = 0; start < n; start++) {
                if (colours[start] !== -1) continue;
                const queue = [start];
                colours[start] = 0;
                
                while (queue.length > 0) {
                    const uIdx = queue.shift();
                    const u = this.nodes[uIdx];
                    const currentColour = colours[uIdx];
                    
                    for (const v of neighbours[u]) {
                        const vIdx = idx[v];
                        if (colours[vIdx] === -1) {
                            colours[vIdx] = 1 - currentColour;
                            queue.push(vIdx);
                        } else if (colours[vIdx] === currentColour) {
                            return false;
                        }
                    }
                }
            }
            return true;
        })();
        
        // Planar: OPTIMIZED for ALL graph sizes using fast heuristics
        props.planar = (() => {
            // Count unique undirected edges efficiently
            const uniqueEdges = new Set();
            for (const e of this.edges) {
                const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
                uniqueEdges.add(key);
            }
            const m = uniqueEdges.size;
            
            // Trivial cases
            if (n <= 4) return true;
            if (m === 0) return true;
            if (m <= 1) return true; // ‚ö° Single edge is always planar
            
            // ‚ö° VYLEP≈†EN√ç 1: P≈ôesnƒõj≈°√≠ Eulerova formule pro nesouvisl√© grafy
            // Pro nesouvisl√Ω graf: m ‚â§ 3n - 6k, kde k = poƒçet komponent
            if (props.prosty) {
                // Poƒçet komponent pomoc√≠ BFS
                const visited = new Set();
                let components = 0;
                const adj = {};
                this.nodes.forEach(id => adj[id] = new Set());
                for (const e of this.edges) {
                    adj[e.u].add(e.v);
                    adj[e.v].add(e.u);
                }
                
                for (const start of this.nodes) {
                    if (visited.has(start)) continue;
                    components++;
                    const queue = [start];
                    visited.add(start);
                    while (queue.length) {
                        const u = queue.shift();
                        for (const v of adj[u]) {
                            if (!visited.has(v)) {
                                visited.add(v);
                                queue.push(v);
                            }
                        }
                    }
                }
                
                // Eulerova formule: m ‚â§ 3n - 6k (pro k komponent)
                if (m > 3 * n - 6 * components) {
                    return false;
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 2: Zp≈ôesnƒõn√≠ pro bipartitn√≠ grafy
            if (props.bipartite) {
                // Pro bipartitn√≠ graf: m ‚â§ 2n - 4 (pokud souvisl√Ω)
                // Pro nesouvisl√Ω: pou≈æij podobnou formuli jako v√Ω≈°e
                if (props.connected && m > 2 * n - 4) {
                    return false;
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 3: Kontrola pr≈Ømƒõrn√©ho stupnƒõ (zp≈ôesnƒõn√≠)
            const avgDegree = (2 * m) / n;
            if (avgDegree > 6) { // Zmƒõna z >= na > (6.0 je je≈°tƒõ mo≈æn√©)
                return false;
            }
            
            // ‚ö° VYLEP≈†EN√ç 4: Kontrola maxim√°ln√≠ho stupnƒõ
            // Rovinn√Ω graf nem≈Ø≈æe m√≠t uzel se stupnƒõm > 5 u mal√Ωch graf≈Ø
            const maxDegree = Math.max(...Object.values(degrees));
            if (n <= 10 && maxDegree > n - 1) {
                // Pokud m√° uzel stupe≈à n-1, je to hvƒõzda ‚Üí rovinn√©
                // Jinak pokraƒçuj v kontrol√°ch
            }
            
            // ‚ö° VYLEP≈†EN√ç 5: Speci√°ln√≠ p≈ô√≠pady - stromy a lesy
            if (m === n - 1 && props.connected) {
                return true; // Strom je v≈ædy rovinn√Ω!
            }
            if (m < n) {
                return true; // Les (m < n) je v≈ædy rovinn√Ω!
            }
            
            // ‚ö° VYLEP≈†EN√ç 6: Optimalizovan√° detekce K5 s lep≈°√≠m targeting
            if (n >= 5 && m >= 10) {
                // K5 pot≈ôebuje 10 hran mezi 5 uzly
                // Nejprve najdi uzly s vysok√Ωm stupnƒõm (‚â•4)
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 4) { // K5 m√° v≈°echny uzly se stupnƒõm 4
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                // Zkontroluj jen high-degree uzly (v√Ωraznƒõ rychlej≈°√≠!)
                if (highDegreeNodes.length >= 5) {
                    const maxSamples = Math.min(50, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        // Random sampling z high-degree uzl≈Ø
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 5);
                        
                        let isK5 = true;
                        let edgeCount = 0;
                        
                        // Check if these 5 nodes form K5
                        for (let i = 0; i < 5 && isK5; i++) {
                            for (let j = i + 1; j < 5; j++) {
                                const u = candidateNodes[i];
                                const v = candidateNodes[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgeCount++;
                                } else {
                                    isK5 = false;
                                    break;
                                }
                            }
                        }
                        
                        // K5 m√° p≈ôesnƒõ 10 hran
                        if (isK5 && edgeCount === 10) return false;
                    }
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 7: Optimalizovan√° detekce K3,3 s bipartitn√≠ anal√Ωzou
            if (n >= 6 && m >= 9) {
                // K3,3 pot≈ôebuje 9 hran a je bipartitn√≠
                // Pokud graf nen√≠ bipartitn√≠, zkontroluj subgrafy
                
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 3) { // K3,3 m√° v≈°echny uzly se stupnƒõm p≈ôesnƒõ 3
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                if (highDegreeNodes.length >= 6) {
                    const maxSamples = Math.min(30, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 6);
                        
                        // ‚ö° Optimalizace: Zkus jen logick√© partitiony
                        // Nam√≠sto v≈°ech 2^6 = 64 kombinac√≠, zkus jen validn√≠
                        const partitions = [
                            [[0,1,2], [3,4,5]],
                            [[0,1,3], [2,4,5]],
                            [[0,1,4], [2,3,5]],
                            [[0,1,5], [2,3,4]],
                            [[0,2,3], [1,4,5]],
                            [[0,2,4], [1,3,5]],
                            [[0,2,5], [1,3,4]],
                            [[0,3,4], [1,2,5]],
                            [[0,3,5], [1,2,4]],
                            [[0,4,5], [1,2,3]]
                        ];
                        
                        for (const [setAIdx, setBIdx] of partitions) {
                            const setA = setAIdx.map(i => candidateNodes[i]);
                            const setB = setBIdx.map(i => candidateNodes[i]);
                            
                            // Check if complete bipartite
                            let isK33 = true;
                            let edgeCount = 0;
                            
                            // Kontroluj jen hrany mezi mno≈æinami (ne uvnit≈ô!)
                            for (const ua of setA) {
                                for (const vb of setB) {
                                    const key = ua <= vb ? `${ua}|${vb}` : `${vb}|${ua}`;
                                    if (uniqueEdges.has(key)) {
                                        edgeCount++;
                                    } else {
                                        isK33 = false;
                                        break;
                                    }
                                }
                                if (!isK33) break;
                            }
                            
                            // K3,3 m√° p≈ôesnƒõ 9 hran a ≈æ√°dn√© hrany uvnit≈ô mno≈æin
                            if (isK33 && edgeCount === 9) {
                                // Ovƒõ≈ô, ≈æe nejsou hrany uvnit≈ô setA a setB
                                let hasInternalEdge = false;
                                for (let i = 0; i < 3; i++) {
                                    for (let j = i + 1; j < 3; j++) {
                                        const keyA = setA[i] <= setA[j] ? `${setA[i]}|${setA[j]}` : `${setA[j]}|${setA[i]}`;
                                        const keyB = setB[i] <= setB[j] ? `${setB[i]}|${setB[j]}` : `${setB[j]}|${setB[i]}`;
                                        if (uniqueEdges.has(keyA) || uniqueEdges.has(keyB)) {
                                            hasInternalEdge = true;
                                            break;
                                        }
                                    }
                                    if (hasInternalEdge) break;
                                }
                                
                                if (!hasInternalEdge) return false; // K3,3 found!
                            }
                        }
                    }
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 8: Kontrola hustoty subgraf≈Ø
            // Rovinn√Ω graf nem≈Ø≈æe obsahovat "lok√°lnƒõ hust√Ω" subgraf
            if (n >= 10 && m >= 20) {
                // Vyber n√°hodn√© uzly a kontroluj jejich okol√≠
                const samples = Math.min(10, n);
                for (let s = 0; s < samples; s++) {
                    const centerIdx = Math.floor(Math.random() * n);
                    const center = this.nodes[centerIdx];
                    
                    // Najdi sousedy centra
                    const neighbors = new Set();
                    for (const e of this.edges) {
                        if (e.u === center) neighbors.add(e.v);
                        if (e.v === center) neighbors.add(e.u);
                    }
                    
                    if (neighbors.size >= 6) {
                        // Spoƒç√≠tej hrany mezi sousedy
                        const neighborsList = Array.from(neighbors);
                        let edgesInNeighborhood = 0;
                        for (let i = 0; i < neighborsList.length; i++) {
                            for (let j = i + 1; j < neighborsList.length; j++) {
                                const u = neighborsList[i];
                                const v = neighborsList[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgesInNeighborhood++;
                                }
                            }
                        }
                        
                        // Pokud m√° okol√≠ p≈ô√≠li≈° mnoho hran, nen√≠ rovinn√Ω
                        const k = neighbors.size;
                        const maxEdgesInNeighborhood = 3 * k - 6;
                        if (edgesInNeighborhood > maxEdgesInNeighborhood) {
                            return false;
                        }
                    }
                }
            }
            
            // ‚ö° VYLEP≈†EN√ç 9: Zp≈ôesnƒõn√≠ odpovƒõdi podle jistoty
            if (n > 100) {
                // Pro velmi velk√© grafy pou≈æij disclaimer
                return 'pravdƒõpodobnƒõ ano (heuristika)';
            } else if (n > 50 && (m > 2.5 * n)) {
                // Pro st≈ôednƒõ velk√© hust≈°√≠ grafy buƒè opatrnƒõj≈°√≠
                return 'pravdƒõpodobnƒõ ano (heuristika)';
            } else if (m <= n + 3) {
                // ≈ò√≠dk√© grafy (m ‚â§ n+3) jsou t√©mƒõ≈ô jistƒõ rovinn√©
                return true;
            }
            
            return true;
        })();
        
        // ‚ö° NOV√â: Symetrizace (v≈°echny orientovan√© hrany maj√≠ i opaƒçnou hranu)
        props.symmetric = (() => {
            if (!props.oriented) return true; // Neorientovan√Ω graf je v≈ædy symetrick√Ω
            
            // Pro orientovan√© grafy: kontrola, ≈æe ka≈æd√° hrana m√° protƒõj≈°ek
            for (const e of this.edges) {
                if (e.direction === '-') continue; // Neorientovan√© hrany ignoruj
                
                // Hledej opaƒçnou hranu
                const oppositeExists = this.edges.some(e2 => 
                    e2.u === e.v && e2.v === e.u && (e2.direction === '<' || e2.direction === '>' || e2.direction === '-')
                );
                
                if (!oppositeExists) {
                    return false; // Na≈°li jsme hranu bez protƒõj≈°ku
                }
            }
            return true;
        })();
        
        // ‚ö° Cachuj v√Ωsledek pro budouc√≠ vol√°n√≠
        this._cachedProperties = props;
        return props;
    }

    // üìä Kompletn√≠ statistick√Ω p≈ôehled grafu
    getStatistics() {
        const stats = {};
        const n = this.nodes.length;
        const m = this.edges.length;
        
        // Z√°kladn√≠ poƒçty
        stats.nodeCount = n;
        stats.edgeCount = m;
        stats.componentCount = this.countComponents();
        
        // Stupnƒõ uzl≈Ø
        const degrees = this.degrees();
        const degreeValues = Object.values(degrees);
        stats.degrees = {
            min: Math.min(...degreeValues),
            max: Math.max(...degreeValues),
            avg: degreeValues.reduce((a, b) => a + b, 0) / n,
            median: this._median(degreeValues),
            distribution: this._degreeDistribution(degreeValues)
        };
        
        // ‚ö° NOV√â: Pro orientovan√© grafy p≈ôidej IN/OUT stupnƒõ
        const props = this.properties();
        if (props.oriented === 'orientovan√Ω') {
            const inDegrees = {};
            const outDegrees = {};
            this.nodes.forEach(id => { inDegrees[id] = 0; outDegrees[id] = 0; });
            
            for (const e of this.edges) {
                if (e.direction === '>') {
                    outDegrees[e.u]++;
                    inDegrees[e.v]++;
                } else if (e.direction === '<') {
                    inDegrees[e.u]++;
                    outDegrees[e.v]++;
                }
            }
            
            const inValues = Object.values(inDegrees);
            const outValues = Object.values(outDegrees);
            
            stats.inDegrees = {
                min: Math.min(...inValues),
                max: Math.max(...inValues),
                avg: inValues.reduce((a, b) => a + b, 0) / n
            };
            
            stats.outDegrees = {
                min: Math.min(...outValues),
                max: Math.max(...outValues),
                avg: outValues.reduce((a, b) => a + b, 0) / n
            };
        }
        
        // Izolovan√© uzly (stupe≈à 0)
        stats.isolatedNodes = this.nodes.filter(id => degrees[id] === 0);
        
        // Smyƒçky (self-loops)
        stats.loops = this.edges.filter(e => e.u === e.v).length;
        
        // N√°sobn√© hrany
        const multipleEdges = this.findMultipleEdges();
        stats.multipleEdgeGroups = multipleEdges.length;
        stats.totalMultipleEdges = multipleEdges.reduce((sum, g) => sum + g.count, 0);
        
        // Hustota grafu (0 = ≈ô√≠dk√Ω, 1 = √∫pln√Ω)
        const maxEdges = (n * (n - 1)) / 2;
        stats.density = maxEdges > 0 ? m / maxEdges : 0;
        
        // Pr≈Ømƒõr a polomƒõr grafu (pokud je souvisl√Ω a ne moc velk√Ω)
        if (n > 0 && n <= 100 && this.properties().connected) {
            const diameterInfo = this._computeDiameterAndRadius();
            stats.diameter = diameterInfo.diameter;
            stats.radius = diameterInfo.radius;
            stats.centerNodes = diameterInfo.centerNodes;
            stats.peripheralNodes = diameterInfo.peripheralNodes;
        } else {
            stats.diameter = null;
            stats.radius = null;
        }
        
        // Komponenty
        const components = this.getComponents();
        if (components.length > 0) {
            stats.largestComponent = Math.max(...components.map(c => c.size));
            stats.smallestComponent = Math.min(...components.map(c => c.size));
            stats.componentSizes = components.map(c => c.size).sort((a, b) => b - a);
        }
        
        // Orientace hran
        let directedCount = 0;
        let undirectedCount = 0;
        for (const e of this.edges) {
            if (e.direction === '-') undirectedCount++;
            else directedCount++;
        }
        stats.directedEdges = directedCount;
        stats.undirectedEdges = undirectedCount;
        
        // Ohodnocen√≠
        stats.weightedEdges = this.edges.filter(e => e.weight !== null && e.weight !== undefined).length;
        stats.weightedNodes = this.nodes.filter(id => this.nodeWeights[id] !== null && this.nodeWeights[id] !== undefined).length;

        // Edge weight stats
        if (stats.weightedEdges > 0) {
            const weights = this.edges.map(e => e.weight).filter(w => w !== null && w !== undefined);
            const minWeight = Math.min(...weights);
            const maxWeight = Math.max(...weights);
            stats.edgeWeights = {
                min: minWeight,
                max: maxWeight,
                avg: weights.reduce((a, b) => a + b, 0) / weights.length,
                distribution: weights.reduce((acc, val) => {
                    acc[val] = (acc[val] || 0) + 1;
                    return acc;
                }, {})
            };
            stats.longestEdges = this.edges.filter(e => e.weight === maxWeight);
            stats.shortestEdges = this.edges.filter(e => e.weight === minWeight);
        }
        
        return stats;
    }

    _median(arr) {
        if (arr.length === 0) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
    }

    _degreeDistribution(degreeValues) {
        const dist = {};
        for (const deg of degreeValues) {
            dist[deg] = (dist[deg] || 0) + 1;
        }
        return dist;
    }

    _computeDiameterAndRadius() {
        const n = this.nodes.length;
        const fw = this.floydWarshall();
        const dist = fw.dist;
        
        // Excentricita ka≈æd√©ho uzlu = max vzd√°lenost k ostatn√≠m
        const eccentricities = [];
        for (let i = 0; i < n; i++) {
            let maxDist = 0;
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    maxDist = Math.max(maxDist, dist[i][j]);
                }
            }
            eccentricities.push(maxDist);
        }
        
        const diameter = Math.max(...eccentricities); // max excentricita
        const radius = Math.min(...eccentricities);   // min excentricita
        
        // Centr√°ln√≠ uzly (excentricita = polomƒõr)
        const centerNodes = [];
        const peripheralNodes = [];
        for (let i = 0; i < n; i++) {
            if (eccentricities[i] === radius) centerNodes.push(this.nodes[i]);
            if (eccentricities[i] === diameter) peripheralNodes.push(this.nodes[i]);
        }
        
        return { diameter, radius, centerNodes, peripheralNodes };
    }
}


function createMatrixTable(matrix, rowLabels, colLabels) {
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th'));
    for (const label of colLabels) {
        const th = document.createElement('th');
        th.textContent = label;
        headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (let i = 0; i < matrix.length; i++) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = rowLabels[i];
        tr.appendChild(th);
        for (let j = 0; j < matrix[i].length; j++) {
            const td = document.createElement('td');
            const val = matrix[i][j];
            td.textContent = (val === Infinity ? '‚àû' : val);
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    table.addEventListener('mouseover', handleMatrixMouseOver(matrix));
    table.addEventListener('mouseout', handleMatrixMouseOut);
    return table;
}

function showRowColStats(type, matrix, container) {
    let statsHTML = '';
    if (type === 'row') {
        statsHTML += '<h4>Statistiky po ≈ô√°dc√≠ch:</h4>';
        matrix.forEach((row, i) => {
            const sum = row.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            const counts = row.reduce((acc, val) => {
                if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});
            statsHTML += `<strong>≈ò√°dek ${i + 1}:</strong> Suma = ${sum}, Hodnoty: ${Object.entries(counts).map(([v, c]) => `${v}:${c}√ó`).join(', ')}<br>`;
        });
    } else {
        statsHTML += '<h4>Statistiky po sloupc√≠ch:</h4>';
        const cols = matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
        cols.forEach((col, i) => {
            const sum = col.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            const counts = col.reduce((acc, val) => {
                if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
                return acc;
            }, {});
            statsHTML += `<strong>Sloupec ${i + 1}:</strong> Suma = ${sum}, Hodnoty: ${Object.entries(counts).map(([v, c]) => `${v}:${c}√ó`).join(', ')}<br>`;
        });
    }
    container.innerHTML = statsHTML;
}

function handleMatrixMouseOver(matrix) {
    return function(event) {
        const cell = event.target.closest('td');
        if (!cell) return;

        const rowIndex = cell.parentNode.rowIndex - 1;
        const colIndex = cell.cellIndex - 1;

        // Row stats
        const row = matrix[rowIndex];
        const rowSum = row.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
        const rowCounts = row.reduce((acc, val) => {
            if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});

        // Column stats
        const col = matrix.map(r => r[colIndex]);
        const colSum = col.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
        const colCounts = col.reduce((acc, val) => {
            if (isFinite(val)) acc[val] = (acc[val] || 0) + 1;
            return acc;
        }, {});

        let statsHTML = `<strong>Row ${rowIndex + 1}:</strong> Sum = ${rowSum}<br>`;
        statsHTML += `<strong>Col ${colIndex + 1}:</strong> Sum = ${colSum}<br>`;

        // Diagonal stats
        if (rowIndex === colIndex) {
            const mainDiag = matrix.map((r, i) => r[i]);
            const mainDiagSum = mainDiag.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            statsHTML += `<strong>Main Diag:</strong> Sum = ${mainDiagSum}<br>`;
        }
        if (rowIndex + colIndex === matrix.length - 1) {
            const antiDiag = matrix.map((r, i) => r[matrix.length - 1 - i]);
            const antiDiagSum = antiDiag.reduce((a, b) => a + (isFinite(b) ? b : 0), 0);
            statsHTML += `<strong>Anti Diag:</strong> Sum = ${antiDiagSum}<br>`;
        }

        const tooltip = document.getElementById('matrix-stats-tooltip');
        tooltip.innerHTML = statsHTML;
        tooltip.style.display = 'block';
        tooltip.style.left = `${event.pageX + 10}px`;
        tooltip.style.top = `${event.pageY + 10}px`;
    };
}

function handleMatrixMouseOut(event) {
    const tooltip = document.getElementById('matrix-stats-tooltip');
    tooltip.style.display = 'none';
}

function countBinaryMatrix(matrix) {
    const n = matrix.length;
    const m = matrix[0] ? matrix[0].length : 0;
    
    const colStats = [];
    for (let j = 0; j < m; j++) {
        colStats.push({ zeros: 0, ones: 0 });
    }
    
    let totalZeros = 0;
    let totalOnes = 0;
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            const val = matrix[i][j];
            if (val === 0) {
                colStats[j].zeros++;
                totalZeros++;
            } else if (val === 1) {
                colStats[j].ones++;
                totalOnes++;
            }
        }
    }
    
    return { colStats, totalZeros, totalOnes };
}

function countMatrixValues(matrix) {
    const counts = {};
    let total = 0;
    
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            const val = matrix[i][j];
            if (val === Infinity) continue;
            
            counts[val] = (counts[val] || 0) + 1;
            total++;
        }
    }
    
    return { counts, total };
}

function createListTable(map) {
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');
    for (const key of Object.keys(map)) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = key;
        tr.appendChild(th);
        const td = document.createElement('td');
        td.textContent = map[key].join(', ');
        tr.appendChild(td);
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
}

let currentGraph = null;

document.getElementById('parseBtn').addEventListener('click', () => {
    const input = document.getElementById('graphInput').value;
    const graph = new Graph();
    graph.parse(input);
    currentGraph = graph;
    
    const output = document.getElementById('output');
    output.innerHTML = '';
    
    if (graph.nodes.length === 0) {
        output.textContent = 'Nebyl rozpozn√°n ≈æ√°dn√Ω uzel. Zkontrolujte pros√≠m vstup.';
        document.getElementById('counters').style.display = 'none';
        return;
    }

    // ‚ö° D≈ÆLE≈ΩIT√â: Z√≠skej properties() hned na zaƒç√°tku, pou≈æ√≠v√° se to v≈°ude!
    const props = graph.properties();

    // Update counters
    document.getElementById('nodeCount').textContent = graph.nodes.length;
    document.getElementById('edgeCount').textContent = graph.edges.length;
    document.getElementById('componentCount').textContent = graph.countComponents();
    document.getElementById('counters').style.display = 'block';

    // üìä STATISTICK√Å SEKCE - Kompletn√≠ p≈ôehled grafu
    const statsSection = document.createElement('div');
    statsSection.id = 'statisticsSection';
    statsSection.style.margin = '1rem 0';
    statsSection.style.padding = '1rem';
    statsSection.style.backgroundColor = '#f8f9fa';
    statsSection.style.border = '1px solid #dee2e6';
    statsSection.style.borderRadius = '0.25rem';
    
    const statsHeader = document.createElement('h2');
    statsHeader.style.marginTop = '0';
    statsHeader.style.color = '#0d6efd';
    statsHeader.innerHTML = 'üìä Kompletn√≠ statistick√Ω p≈ôehled';
    statsSection.appendChild(statsHeader);
    
    const statsBtn = document.createElement('button');
    statsBtn.textContent = 'Zobrazit statistiky';
    statsBtn.style.marginBottom = '1rem';
    
    const statsContent = document.createElement('div');
    statsContent.style.display = 'none';
    
    statsBtn.addEventListener('click', () => {
        if (statsContent.style.display === 'none') {
            const stats = graph.getStatistics();
            const degrees = graph.degrees();
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem;">';
            
            // üìà Z√°kladn√≠ metriky
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #0d6efd;">
                    <h3 style="margin-top: 0; color: #0d6efd;">üìà Z√°kladn√≠ metriky</h3>
                    <div style="line-height: 1.8;">
                        <strong>Uzly:</strong> ${stats.nodeCount}<br>
                        <strong>Hrany:</strong> ${stats.edgeCount}<br>
                        <strong>Komponenty:</strong> ${stats.componentCount}<br>
                        <strong>Izolovan√© uzly:</strong> ${stats.isolatedNodes.length}${stats.isolatedNodes.length > 0 ? ` (${stats.isolatedNodes.slice(0, 5).join(', ')}${stats.isolatedNodes.length > 5 ? '...' : ''})` : ''}<br>
                        <strong>Smyƒçky:</strong> ${stats.loops}<br>
                        <strong>Hustota grafu:</strong> ${(stats.density * 100).toFixed(2)}%
                    </div>
                </div>
            `;
            if (stats.edgeWeights) {
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #fd7e14;">
                        <h3 style="margin-top: 0; color: #fd7e14;">‚öñÔ∏è Statistiky vah hran</h3>
                        <div style="line-height: 1.8;">
                            <strong>Min v√°ha:</strong> ${stats.edgeWeights.min} (hrany: ${stats.shortestEdges.map(e => e.label || `${e.u}-${e.v}`).join(', ')})<br>
                            <strong>Max v√°ha:</strong> ${stats.edgeWeights.max} (hrany: ${stats.longestEdges.map(e => e.label || `${e.u}-${e.v}`).join(', ')})<br>
                            <strong>Pr≈Ømƒõrn√° v√°ha:</strong> ${stats.edgeWeights.avg.toFixed(2)}<br>
                            <strong>Distribuce:</strong> ${Object.entries(stats.edgeWeights.distribution).map(([w, c]) => `${w}: ${c}√ó`).join(', ')}
                        </div>
                    </div>
                `;
            }
            
            // üéØ Stupnƒõ uzl≈Ø
            const degDistKeys = Object.keys(stats.degrees.distribution).map(Number).sort((a, b) => a - b);
            const degDistStr = degDistKeys.slice(0, 10).map(deg => `${deg}: ${stats.degrees.distribution[deg]}√ó`).join(', ');
            
            // ‚ö° NOV√â: Pro orientovan√© grafy zobraz IN/OUT stupnƒõ
            let degreeDetailsHTML = '';
            if (stats.inDegrees && stats.outDegrees) {
                degreeDetailsHTML = `
                    <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid #dee2e6;">
                    <strong style="color: #0d6efd;">IN-degree:</strong><br>
                    <span style="margin-left: 1rem;">Min: ${stats.inDegrees.min} | Max: ${stats.inDegrees.max} | √ò ${stats.inDegrees.avg.toFixed(2)}</span><br>
                    <strong style="color: #dc3545;">OUT-degree:</strong><br>
                    <span style="margin-left: 1rem;">Min: ${stats.outDegrees.min} | Max: ${stats.outDegrees.max} | √ò ${stats.outDegrees.avg.toFixed(2)}</span>
                `;
            }
            
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #198754;">
                    <h3 style="margin-top: 0; color: #198754;">üéØ Stupnƒõ uzl≈Ø</h3>
                    <div style="line-height: 1.8;">
                        <strong>Min:</strong> ${stats.degrees.min}<br>
                        <strong>Max:</strong> ${stats.degrees.max}<br>
                        <strong>Pr≈Ømƒõr:</strong> ${stats.degrees.avg.toFixed(2)}<br>
                        <strong>Medi√°n:</strong> ${stats.degrees.median}<br>
                        ${degreeDetailsHTML}
                        <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid #dee2e6;">
                        <strong>Distribuce:</strong><br>
                        <span style="font-size: 0.9rem; color: #666;">${degDistStr}${degDistKeys.length > 10 ? '...' : ''}</span>
                    </div>
                </div>
            `;
            
            // üîó Hrany
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #dc3545;">
                    <h3 style="margin-top: 0; color: #dc3545;">üîó Hrany</h3>
                    <div style="line-height: 1.8;">
                        <strong>Orientovan√©:</strong> ${stats.directedEdges}<br>
                        <strong>Neorientovan√©:</strong> ${stats.undirectedEdges}<br>
                        <strong>S vahami:</strong> ${stats.weightedEdges}<br>
                        <strong>N√°sobn√© hrany:</strong> ${stats.multipleEdgeGroups} skupin (${stats.totalMultipleEdges} hran)<br>
                        <strong>Smyƒçky:</strong> ${stats.loops}
                    </div>
                </div>
            `;
            
            // üå≥ Komponenty
            if (stats.componentSizes) {
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #ffc107;">
                        <h3 style="margin-top: 0; color: #f59f00;">üå≥ Komponenty</h3>
                        <div style="line-height: 1.8;">
                            <strong>Poƒçet komponent:</strong> ${stats.componentCount}<br>
                            <strong>Nejvƒõt≈°√≠:</strong> ${stats.largestComponent} uzl≈Ø<br>
                            <strong>Nejmen≈°√≠:</strong> ${stats.smallestComponent} uzl≈Ø<br>
                            <strong>Velikosti:</strong> ${stats.componentSizes.slice(0, 10).join(', ')}${stats.componentSizes.length > 10 ? '...' : ''}
                        </div>
                    </div>
                `;
            }
            
            // üìè Pr≈Ømƒõr a polomƒõr (pokud vypoƒç√≠t√°no)
            if (stats.diameter !== null) {
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #6f42c1;">
                        <h3 style="margin-top: 0; color: #6f42c1;">üìè Pr≈Ømƒõr a polomƒõr</h3>
                        <div style="line-height: 1.8;">
                            <strong>Pr≈Ømƒõr grafu:</strong> ${stats.diameter}<br>
                            <strong>Polomƒõr grafu:</strong> ${stats.radius}<br>
                            <strong>Centr√°ln√≠ uzly:</strong> ${stats.centerNodes.slice(0, 10).join(', ')}${stats.centerNodes.length > 10 ? '...' : ''}<br>
                            <strong>Perifern√≠ uzly:</strong> ${stats.peripheralNodes.slice(0, 10).join(', ')}${stats.peripheralNodes.length > 10 ? '...' : ''}
                        </div>
                    </div>
                `;
            } else if (stats.nodeCount > 100) {
                html += `
                    <div style="background-color: #fff3cd; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #ffc107;">
                        <h3 style="margin-top: 0; color: #856404;">üìè Pr≈Ømƒõr a polomƒõr</h3>
                        <div style="line-height: 1.8;">
                            <em>P≈ô√≠li≈° velk√Ω graf pro v√Ωpoƒçet pr≈Ømƒõru (> 100 uzl≈Ø)</em>
                        </div>
                    </div>
                `;
            }
            
            // üèÜ TOP uzly podle stupnƒõ
            const topNodes = Object.entries(degrees)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15);
            
            html += `
                <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #20c997; grid-column: span 1;">
                    <h3 style="margin-top: 0; color: #20c997;">üèÜ TOP uzly (nejvy≈°≈°√≠ stupe≈à)</h3>
                    <div style="line-height: 1.6; font-size: 0.9rem;">
                        ${topNodes.map(([node, deg], i) => `${i + 1}. <strong>${node}</strong> (${deg})`).join('<br>')}
                    </div>
                </div>
            `;
            
            // üìâ Histogram stup≈à≈Ø (pokud ne moc uzl≈Ø)
            if (stats.nodeCount <= 50) {
                const maxFreq = Math.max(...Object.values(stats.degrees.distribution));
                html += `
                    <div style="background-color: white; padding: 1rem; border-radius: 0.25rem; border-left: 4px solid #0dcaf0; grid-column: span 2;">
                        <h3 style="margin-top: 0; color: #0dcaf0;">üìâ Histogram stup≈à≈Ø</h3>
                        <div style="font-family: monospace; font-size: 0.85rem; line-height: 1.4;">
                `;
                
                for (const deg of degDistKeys) {
                    const count = stats.degrees.distribution[deg];
                    const barWidth = Math.round((count / maxFreq) * 40);
                    const bar = '‚ñà'.repeat(barWidth);
                    html += `Stupe≈à ${deg.toString().padStart(2)}: ${bar} ${count}<br>`;
                }
                
                html += '</div></div>';
            }
            
            html += '</div>';
            
            // Legenda
            html += `
                <div style="margin-top: 1rem; padding: 0.75rem; background-color: #e7f3ff; border-radius: 0.25rem; border: 1px solid #0d6efd;">
                    <strong>üí° Vysvƒõtlen√≠ pojm≈Ø:</strong><br>
                    <div style="margin-left: 1rem; margin-top: 0.5rem; font-size: 0.9rem; line-height: 1.6;">
                        ‚Ä¢ <strong>Hustota:</strong> Pomƒõr skuteƒçn√Ωch hran k max. mo≈æn√Ωm (0% = ≈æ√°dn√© hrany, 100% = √∫pln√Ω graf)<br>
                        ‚Ä¢ <strong>Pr≈Ømƒõr:</strong> Maxim√°ln√≠ excentricita = nejdel≈°√≠ nejkrat≈°√≠ cesta mezi libovoln√Ωmi uzly<br>
                        ‚Ä¢ <strong>Polomƒõr:</strong> Minim√°ln√≠ excentricita = centrum grafu<br>
                        ‚Ä¢ <strong>Centr√°ln√≠ uzly:</strong> Uzly s nejmen≈°√≠ excentricitou (nejbl√≠≈æ ke v≈°em ostatn√≠m)<br>
                        ‚Ä¢ <strong>Perifern√≠ uzly:</strong> Uzly s nejvƒõt≈°√≠ excentricitou (nejd√°l od ostatn√≠ch)
                    </div>
                </div>
            `;
            
            statsContent.innerHTML = html;
            statsContent.style.display = 'block';
            statsBtn.textContent = 'Skr√Ωt statistiky';
        } else {
            statsContent.style.display = 'none';
            statsBtn.textContent = 'Zobrazit statistiky';
        }
    });
    
    statsSection.appendChild(statsBtn);
    statsSection.appendChild(statsContent);
    output.appendChild(statsSection);

    // Query sections for each matrix type
    const createQuerySection = (title, matrixType) => {
    const section = document.createElement('div');
    section.className = 'query-section';
    section.innerHTML = `<h3>${title}</h3>`;
    
    const inputDiv = document.createElement('div');
    inputDiv.className = 'query-inputs';
    
    const datalistId = `nodes-datalist-${matrixType}`;
    const datalist = document.createElement('datalist');
    datalist.id = datalistId;
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        datalist.appendChild(option);
    });
    section.appendChild(datalist);

    const selectU = document.createElement('input');
    selectU.setAttribute('list', datalistId);
    selectU.className = 'node-input';
    const selectV = document.createElement('input');
    selectV.setAttribute('list', datalistId);
    selectV.className = 'node-input';
    
    const queryBtn = document.createElement('button');
    queryBtn.textContent = 'Dotaz';
    
    const resultDiv = document.createElement('div');
    resultDiv.className = 'query-result';
    resultDiv.style.display = 'none';
    
    queryBtn.addEventListener('click', () => {
        const u = selectU.value;
        const v = selectV.value;
        let result;
        
        switch(matrixType) {
            case 'adjacency':
                result = graph.adjacencyValue(u, v);
                resultDiv.textContent = `A[${u}, ${v}] = ${result}`;
                break;
            case 'sign':
                result = graph.signValue(u, v);
                resultDiv.textContent = `S[${u}, ${v}] = ${result}`;
                break;
            case 'length':
                result = graph.lengthValue(u, v);
                resultDiv.textContent = `L[${u}, ${v}] = ${result === Infinity ? '‚àû' : result}`;
                break;
            case 'power2':
                result = graph.adjacencyPowerValue(u, v, 2);
                resultDiv.textContent = `A¬≤[${u}, ${v}] = ${result}`;
                break;
            case 'power3':
                result = graph.adjacencyPowerValue(u, v, 3);
                resultDiv.textContent = `A¬≥[${u}, ${v}] = ${result}`;
                break;
            case 'laplacian':
                result = graph.laplacianValue(u, v);
                resultDiv.innerHTML = `Laplaci√°nsk√° matice <strong>L[${u}, ${v}] = ${result}</strong><br>
                    <small>L = D - A (D = matice stup≈à≈Ø, A = matice sousednosti)</small>`;
                break;
            case 'multiplicity':
                result = graph.multiplicityValue(u, v);
                resultDiv.innerHTML = `Multiplicita hran mezi <strong>${u}</strong> a <strong>${v}</strong>: <strong>${result}</strong><br>
                    <small>Poƒçet v≈°ech hran (vƒçetnƒõ paraleln√≠ch) spojuj√≠c√≠ch tyto uzly</small>`;
                break;
            case 'shortest':
                result = graph.shortestPath(u, v);
                if (result.distance === Infinity) {
                    resultDiv.textContent = `Nejkrat≈°√≠ cesta z ${u} do ${v}: neexistuje`;
                } else {
                    const pathStr = result.path.join(' ‚Üí ');
                    resultDiv.innerHTML = `Nejkrat≈°√≠ cesta z <strong>${u}</strong> do <strong>${v}</strong>:<br>
                        D√©lka: <strong>${result.distance}</strong><br>
                        Sled: <strong>${pathStr}</strong>`;
                }
                break;
        }
        resultDiv.style.display = 'block';
    });
    
    // ‚úÖ OPRAVA: Spr√°vn√© vytv√°≈ôen√≠ labelu a p≈ôid√°n√≠ element≈Ø
    const labelU = document.createElement('span');
    labelU.textContent = 'Od uzlu: ';
    inputDiv.appendChild(labelU);
    inputDiv.appendChild(selectU);
    
    const labelV = document.createElement('span');
    labelV.textContent = ' Do uzlu: ';
    inputDiv.appendChild(labelV);
    inputDiv.appendChild(selectV);
    
    inputDiv.appendChild(queryBtn);
    
    section.appendChild(inputDiv);
    section.appendChild(resultDiv);
    return section;
};

    // Node and edge list with degrees (scrollable)
    const listSection = document.createElement('div');
    listSection.className = 'section';
    listSection.innerHTML = '<h2>Seznam uzl≈Ø a hran</h2>';
    
    const degrees = graph.degrees();
    const nodeListDiv = document.createElement('div');
    nodeListDiv.className = 'scrollable-list';
    const nodeList = document.createElement('ul');
    nodeList.style.listStyle = 'none';
    nodeList.style.padding = '0';
    
    // ‚ö° VYLEP≈†EN√ç: Pro orientovan√© grafy zobraz IN/OUT stupnƒõ
    const showDirectedDegrees = props.oriented === 'orientovan√Ω';
    
    graph.nodes.forEach(id => {
        const li = document.createElement('li');
        const w = graph.nodeWeights[id];
        const deg = degrees[id];
        
        let degreeInfo = '';
        if (showDirectedDegrees) {
            // Pro orientovan√©: spoƒç√≠tej in/out degree
            let inDegree = 0;
            let outDegree = 0;
            for (const e of graph.edges) {
                if (e.direction === '>' && e.u === id) outDegree++;
                else if (e.direction === '>' && e.v === id) inDegree++;
                else if (e.direction === '<' && e.u === id) inDegree++;
                else if (e.direction === '<' && e.v === id) outDegree++;
                else if (e.direction === '-') {
                    // Neorientovan√© hrany v mixed grafu
                    if (e.u === id || e.v === id) {
                        if (e.u === e.v) { inDegree++; outDegree++; } // Smyƒçka
                        else { inDegree++; outDegree++; }
                    }
                }
            }
            degreeInfo = `<span class="degree-info">in: ${inDegree} | out: ${outDegree} | celkem: ${deg}</span>`;
        } else {
            degreeInfo = `<span class="degree-info">stupe≈à: ${deg}</span>`;
        }
        
        li.innerHTML = `<strong>Uzel ${id}</strong>${w !== null && w !== undefined ? ` (hodnota: ${w})` : ''}${degreeInfo}`;
        nodeList.appendChild(li);
    });
    nodeListDiv.appendChild(nodeList);
    listSection.appendChild(nodeListDiv);
    
    const edgeListDiv = document.createElement('div');
    edgeListDiv.className = 'scrollable-list';
    const edgeList = document.createElement('ul');
    edgeList.style.listStyle = 'none';
    edgeList.style.padding = '0';
    graph.edges.forEach(e => {
        const li = document.createElement('li');
        const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
        const label = e.label ? ` [${e.label}]` : '';
        let orientation;
        if (e.direction === '>') orientation = '‚Üí';
        else if (e.direction === '<') orientation = '‚Üê';
        else orientation = '‚Äî';
        li.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
        edgeList.appendChild(li);
    });
    edgeListDiv.appendChild(edgeList);
    listSection.appendChild(edgeListDiv);
    output.appendChild(listSection);

    // Adjacency matrix with query and binary/count toggle
    const adjSection = document.createElement('div');
    adjSection.className = 'section';
    adjSection.innerHTML = '<h2>Matice sousednosti</h2>';
    
    const adjLegendDiv = document.createElement('div');
    adjLegendDiv.style.backgroundColor = '#e7f3ff';
    adjLegendDiv.style.padding = '0.75rem';
    adjLegendDiv.style.borderRadius = '0.25rem';
    adjLegendDiv.style.marginBottom = '1rem';
    adjLegendDiv.style.border = '1px solid #0d6efd';
    adjLegendDiv.innerHTML = `
        <strong>üìä Matice sousednosti A[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>A[i,j] = 0:</strong> Bez hrany z i do j<br>
            ‚Ä¢ <strong>A[i,j] = 1:</strong> Existuje hrana z i do j<br>
            ‚Ä¢ <strong>A[i,j] ‚â• 2:</strong> V√≠ce paraleln√≠ch hran (multigraf)<br>
            ‚Ä¢ <strong>Symetrick√° matice:</strong> Graf je neorientovan√Ω
        </div>
    `;
    adjSection.appendChild(adjLegendDiv);
    
    const adjToggleDiv = document.createElement('div');
    adjToggleDiv.style.marginBottom = '1rem';
    adjToggleDiv.innerHTML = '<label><input type="checkbox" id="adjBinary" /> Bin√°rn√≠ verze (0/1)</label>';
    adjSection.appendChild(adjToggleDiv);
    
    adjSection.appendChild(createQuerySection('Dotaz na hodnotu', 'adjacency'));

    const searchAdjInput = document.createElement('input');
    searchAdjInput.type = 'text';
    searchAdjInput.placeholder = 'Hledat v matici...';
    searchAdjInput.style.marginBottom = '1rem';
    searchAdjInput.style.display = 'none'; // Hide by default
    searchAdjInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const table = adjMatrixDiv.querySelector('table');
        if (!table) return;
        table.querySelectorAll('td').forEach(cell => {
            if (query && cell.textContent.toLowerCase().includes(query)) {
                cell.classList.add('highlight');
            } else {
                cell.classList.remove('highlight');
            }
        });
    });
    adjSection.appendChild(searchAdjInput);
    
    const showAdjBtn = document.createElement('button');
    showAdjBtn.textContent = 'Zobrazit celou matici';
    const adjMatrixDiv = document.createElement('div');
    adjMatrixDiv.className = 'matrix';
    adjMatrixDiv.style.display = 'none';
    const adjStatsDiv = document.createElement('div');
    adjStatsDiv.style.display = 'none';
    adjStatsDiv.style.marginTop = '1rem';
    adjStatsDiv.style.padding = '1rem';
    adjStatsDiv.style.backgroundColor = '#e7f3ff';
    adjStatsDiv.style.borderRadius = '0.25rem';
    
    showAdjBtn.addEventListener('click', () => {
        if (adjMatrixDiv.style.display === 'none') {
            const binary = document.getElementById('adjBinary').checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            // Count all values in adjacency matrix
            const { counts, total } = countMatrixValues(adjMat);
            adjStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
            const statsHTML = Object.entries(counts).map(([key, count]) => {
                const percentage = ((count / total) * 100).toFixed(1);
                return `<div style="display: inline-block; margin-right: 1.5rem; margin-bottom: 0.5rem;">
                    <strong>Hodnota ${key}:</strong> ${count}√ó (${percentage}%)
                </div>`;
            }).join('');
            adjStatsDiv.innerHTML += statsHTML;
            adjStatsDiv.innerHTML += `<div style="margin-top: 0.5rem; font-weight: bold;">Celkem hodnot: ${total}</div>`;

            const rowColStatsDiv = document.createElement('div');
            rowColStatsDiv.style.marginTop = '1rem';
            adjStatsDiv.appendChild(rowColStatsDiv);

            const showRowStatsBtn = document.createElement('button');
            showRowStatsBtn.textContent = 'Statistiky po ≈ô√°dc√≠ch';
            showRowStatsBtn.onclick = () => showRowColStats('row', adjMat, rowColStatsDiv);
            adjStatsDiv.appendChild(showRowStatsBtn);

            const showColStatsBtn = document.createElement('button');
            showColStatsBtn.textContent = 'Statistiky po sloupc√≠ch';
            showColStatsBtn.onclick = () => showRowColStats('col', adjMat, rowColStatsDiv);
            adjStatsDiv.appendChild(showColStatsBtn);
            
            adjMatrixDiv.style.display = 'block';
            adjStatsDiv.style.display = 'block';
            searchAdjInput.style.display = 'block'; // Show search
            showAdjBtn.textContent = 'Skr√Ωt matici';
        } else {
            adjMatrixDiv.style.display = 'none';
            adjStatsDiv.style.display = 'none';
            searchAdjInput.style.display = 'none'; // Hide search
            showAdjBtn.textContent = 'Zobrazit celou matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'adjBinary' && adjMatrixDiv.style.display === 'block') {
            const binary = e.target.checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            const { colStats, totalZeros, totalOnes } = countBinaryMatrix(adjMat);
            adjStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Celkov√° statistika hodnot 0 a 1:</h4>';
            adjStatsDiv.innerHTML += `<div style="display: flex; gap: 2rem; margin-top: 0.5rem;">`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #0b5ed7; font-weight: bold;">Poƒçet 1:</span> ${totalOnes}√ó</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #dc3545; font-weight: bold;">Poƒçet 0:</span> ${totalZeros}√ó</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="font-weight: bold;">Celkem:</span> ${totalOnes + totalZeros}</div>`;
            adjStatsDiv.innerHTML += `</div>`;
        }
    });
    
    adjSection.appendChild(showAdjBtn);
    adjSection.appendChild(adjMatrixDiv);
    adjSection.appendChild(adjStatsDiv);
    output.appendChild(adjSection);

    // Sign matrix with query
    const signSection = document.createElement('div');
    signSection.className = 'section';
    signSection.innerHTML = '<h2>Znam√©nkov√° matice</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const signLegendDiv = document.createElement('div');
    signLegendDiv.style.backgroundColor = '#e7f3ff';
    signLegendDiv.style.padding = '0.75rem';
    signLegendDiv.style.borderRadius = '0.25rem';
    signLegendDiv.style.marginBottom = '1rem';
    signLegendDiv.style.border = '1px solid #0d6efd';
    signLegendDiv.innerHTML = `
        <strong>üìä Znam√©nkov√° matice S[i,j] = A[i,j] - A[j,i]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>S[i,j] > 0:</strong> V√≠ce hran z i do j ne≈æ z j do i<br>
            ‚Ä¢ <strong>S[i,j] < 0:</strong> V√≠ce hran z j do i ne≈æ z i do j<br>
            ‚Ä¢ <strong>S[i,j] = 0:</strong> Symetricky nebo bez hran<br>
            ‚Ä¢ <strong>Zji≈°≈•uje≈°:</strong> Asymetrii a vyv√°≈æen√≠ smƒõr≈Ø v grafu
        </div>
    `;
    signSection.appendChild(signLegendDiv);
    
    signSection.appendChild(createQuerySection('Dotaz na hodnotu', 'sign'));

    const searchSignInput = document.createElement('input');
    searchSignInput.type = 'text';
    searchSignInput.placeholder = 'Hledat v matici...';
    searchSignInput.style.marginBottom = '1rem';
    searchSignInput.style.display = 'none'; // Hide by default
    searchSignInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const table = signMatrixDiv.querySelector('table');
        if (!table) return;
        table.querySelectorAll('td').forEach(cell => {
            if (query && cell.textContent.toLowerCase().includes(query)) {
                cell.classList.add('highlight');
            } else {
                cell.classList.remove('highlight');
            }
        });
    });
    signSection.appendChild(searchSignInput);
    
    const showSignBtn = document.createElement('button');
    showSignBtn.textContent = 'Zobrazit celou matici';
    const signMatrixDiv = document.createElement('div');
    signMatrixDiv.className = 'matrix';
    signMatrixDiv.style.display = 'none';
    const signStatsDiv = document.createElement('div');
    signStatsDiv.style.display = 'none';
    signStatsDiv.style.marginTop = '1rem';
    signStatsDiv.style.padding = '1rem';
    signStatsDiv.style.backgroundColor = '#e7f3ff';
    signStatsDiv.style.borderRadius = '0.25rem';
    
    showSignBtn.addEventListener('click', () => {
        if (signMatrixDiv.style.display === 'none') {
            const signMat = graph.signMatrix();
            signMatrixDiv.innerHTML = '';
            signMatrixDiv.appendChild(createMatrixTable(signMat, graph.nodes, graph.nodes));
            
            // Count values in sign matrix
            const { counts, total } = countMatrixValues(signMat);
            signStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
            
            // Sort keys numerically
            const sortedKeys = Object.keys(counts).map(Number).sort((a, b) => a - b);
            const statsHTML = sortedKeys.map(key => {
                const count = counts[key];
                const percentage = ((count / total) * 100).toFixed(1);
                return `<div style="display: inline-block; margin-right: 1.5rem; margin-bottom: 0.5rem;">
                    <strong>Hodnota ${key}:</strong> ${count}√ó (${percentage}%)
                </div>`;
            }).join('');
            
            signStatsDiv.innerHTML += statsHTML;
            signStatsDiv.innerHTML += `<div style="margin-top: 0.5rem; font-weight: bold;">Celkem hodnot: ${total}</div>`;

            const rowColStatsDiv = document.createElement('div');
            rowColStatsDiv.style.marginTop = '1rem';
            signStatsDiv.appendChild(rowColStatsDiv);

            const showRowStatsBtn = document.createElement('button');
            showRowStatsBtn.textContent = 'Statistiky po ≈ô√°dc√≠ch';
            showRowStatsBtn.onclick = () => showRowColStats('row', signMat, rowColStatsDiv);
            signStatsDiv.appendChild(showRowStatsBtn);

            const showColStatsBtn = document.createElement('button');
            showColStatsBtn.textContent = 'Statistiky po sloupc√≠ch';
            showColStatsBtn.onclick = () => showRowColStats('col', signMat, rowColStatsDiv);
            signStatsDiv.appendChild(showColStatsBtn);
            
            signMatrixDiv.style.display = 'block';
            signStatsDiv.style.display = 'block';
            searchSignInput.style.display = 'block';
            showSignBtn.textContent = 'Skr√Ωt matici';
        } else {
            signMatrixDiv.style.display = 'none';
            signStatsDiv.style.display = 'none';
            searchSignInput.style.display = 'none';
            showSignBtn.textContent = 'Zobrazit celou matici';
        }
    });
    signSection.appendChild(showSignBtn);
    signSection.appendChild(signMatrixDiv);
    signSection.appendChild(signStatsDiv);
    output.appendChild(signSection);

    // Laplacian matrix with query
    const laplacianSection = document.createElement('div');
    laplacianSection.className = 'section';
    laplacianSection.innerHTML = '<h2>Laplaci√°nsk√° matice (L = D - A)</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const laplacianLegendDiv = document.createElement('div');
    laplacianLegendDiv.style.backgroundColor = '#e7f3ff';
    laplacianLegendDiv.style.padding = '0.75rem';
    laplacianLegendDiv.style.borderRadius = '0.25rem';
    laplacianLegendDiv.style.marginBottom = '1rem';
    laplacianLegendDiv.style.border = '1px solid #0d6efd';
    
    // ‚ö° DYNAMICK√Å vysvƒõtlivka podle typu grafu
    const isDirected = props.oriented === 'orientovan√Ω';
    laplacianLegendDiv.innerHTML = `
        <strong>üìä Laplaci√°nsk√° matice L = D - A:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>L[U,V] = 0:</strong> Uzly U a V nejsou spojeny<br>
            ‚Ä¢ <strong>L[U,V] = -1:</strong> Uzly U a V jsou p≈ô√≠mo spojeny hranou<br>
            ‚Ä¢ <strong>L[U,U]:</strong> ${isDirected ? '<strong style="color: #0d6efd;">V√Ωstupn√≠ stupe≈à</strong> (poƒçet hran VYCH√ÅZEJ√çC√çCH z U)' : '<strong>Stupe≈à uzlu</strong> (poƒçet hran dot√Ωkaj√≠c√≠ch se U)'}<br>
            ‚Ä¢ <strong>Vlastnost:</strong> Souƒçet ka≈æd√©ho ≈ô√°dku = 0
        </div>
    `;
    laplacianSection.appendChild(laplacianLegendDiv);
    
    laplacianSection.appendChild(createQuerySection('Dotaz na hodnotu L[U,V]', 'laplacian'));

    const searchLaplacianInput = document.createElement('input');
    searchLaplacianInput.type = 'text';
    searchLaplacianInput.placeholder = 'Hledat v matici...';
    searchLaplacianInput.style.marginBottom = '1rem';
    searchLaplacianInput.style.display = 'none'; // Hide by default
    searchLaplacianInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const table = laplacianMatrixDiv.querySelector('table');
        if (!table) return;
        table.querySelectorAll('td').forEach(cell => {
            if (query && cell.textContent.toLowerCase().includes(query)) {
                cell.classList.add('highlight');
            } else {
                cell.classList.remove('highlight');
            }
        });
    });
    laplacianSection.appendChild(searchLaplacianInput);
    
    const showLaplacianBtn = document.createElement('button');
    showLaplacianBtn.textContent = 'Zobrazit celou matici';
    const laplacianMatrixDiv = document.createElement('div');
    laplacianMatrixDiv.className = 'matrix';
    laplacianMatrixDiv.style.display = 'none';
    
    showLaplacianBtn.addEventListener('click', () => {
        if (laplacianMatrixDiv.style.display === 'none') {
            const laplacianMat = graph.laplacianMatrix();
            laplacianMatrixDiv.innerHTML = '';
            laplacianMatrixDiv.appendChild(createMatrixTable(laplacianMat, graph.nodes, graph.nodes));
            laplacianMatrixDiv.style.display = 'block';
            searchLaplacianInput.style.display = 'block';
            showLaplacianBtn.textContent = 'Skr√Ωt matici';
        } else {
            laplacianMatrixDiv.style.display = 'none';
            searchLaplacianInput.style.display = 'none';
            showLaplacianBtn.textContent = 'Zobrazit celou matici';
        }
    });
    laplacianSection.appendChild(showLaplacianBtn);
    const laplacianStatsDiv = document.createElement('div');
    laplacianStatsDiv.style.display = 'none';
    laplacianStatsDiv.style.marginTop = '1rem';
    laplacianStatsDiv.style.padding = '1rem';
    laplacianStatsDiv.style.backgroundColor = '#e7f3ff';
    laplacianStatsDiv.style.borderRadius = '0.25rem';
    laplacianSection.appendChild(laplacianStatsDiv);
    laplacianSection.appendChild(laplacianMatrixDiv);
    output.appendChild(laplacianSection);

    showLaplacianBtn.addEventListener('click', () => {
        if (laplacianMatrixDiv.style.display === 'none') {
            const laplacianMat = graph.laplacianMatrix();
            laplacianMatrixDiv.innerHTML = '';
            laplacianMatrixDiv.appendChild(createMatrixTable(laplacianMat, graph.nodes, graph.nodes));

            const { counts, total } = countMatrixValues(laplacianMat);
            laplacianStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
            const statsHTML = Object.entries(counts).map(([key, count]) => {
                const percentage = ((count / total) * 100).toFixed(1);
                return `<div style="display: inline-block; margin-right: 1.5rem; margin-bottom: 0.5rem;">
                    <strong>Hodnota ${key}:</strong> ${count}√ó (${percentage}%)
                </div>`;
            }).join('');
            laplacianStatsDiv.innerHTML += statsHTML;
            laplacianStatsDiv.innerHTML += `<div style="margin-top: 0.5rem; font-weight: bold;">Celkem hodnot: ${total}</div>`;

            const rowColStatsDiv = document.createElement('div');
            rowColStatsDiv.style.marginTop = '1rem';
            laplacianStatsDiv.appendChild(rowColStatsDiv);

            const showRowStatsBtn = document.createElement('button');
            showRowStatsBtn.textContent = 'Statistiky po ≈ô√°dc√≠ch';
            showRowStatsBtn.onclick = () => showRowColStats('row', laplacianMat, rowColStatsDiv);
            laplacianStatsDiv.appendChild(showRowStatsBtn);

            const showColStatsBtn = document.createElement('button');
            showColStatsBtn.textContent = 'Statistiky po sloupc√≠ch';
            showColStatsBtn.onclick = () => showRowColStats('col', laplacianMat, rowColStatsDiv);
            laplacianStatsDiv.appendChild(showColStatsBtn);

            laplacianStatsDiv.style.display = 'block';
        } else {
            laplacianStatsDiv.style.display = 'none';
        }
    });

    // Multiplicity query section
    const multiplicitySection = document.createElement('div');
    multiplicitySection.className = 'section';
    multiplicitySection.innerHTML = '<h2>Multiplicita hran (poƒçet paraleln√≠ch hran)</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const multiplicityLegendDiv = document.createElement('div');
    multiplicityLegendDiv.style.backgroundColor = '#e7f3ff';
    multiplicityLegendDiv.style.padding = '0.75rem';
    multiplicityLegendDiv.style.borderRadius = '0.25rem';
    multiplicityLegendDiv.style.marginBottom = '1rem';
    multiplicityLegendDiv.style.border = '1px solid #0d6efd';
    multiplicityLegendDiv.innerHTML = `
        <strong>üìä Multiplicita hran:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Multiplicita = 1:</strong> Pr√°vƒõ 1 hrana (nebo v√≠ce v jednom smƒõru)<br>
            ‚Ä¢ <strong>Multiplicita > 1:</strong> V√≠ce paraleln√≠ch hran (multigraf)<br>
            ‚Ä¢ <strong>Poƒç√≠t√° obƒõ strany:</strong> Hrany U‚ÜíV a V‚ÜíU se sƒç√≠taj√≠<br>
            ‚Ä¢ <strong>Bez ohledu na v√°hu:</strong> Poƒç√≠t√° jen existenci hran, ne jejich v√°hu
        </div>
    `;
    multiplicitySection.appendChild(multiplicityLegendDiv);
    
    multiplicitySection.appendChild(createQuerySection('Dotaz na multiplicitu', 'multiplicity'));
    output.appendChild(multiplicitySection);

    // Power matrices with queries
    const powerSection = document.createElement('div');
    powerSection.className = 'section';
    powerSection.innerHTML = '<h2>Druh√° a t≈ôet√≠ mocnina matice sousednosti (poƒçet sled≈Ø d√©lky N)</h2>';
    
    // P≈ôidej legend
    const powerLegendDiv = document.createElement('div');
    powerLegendDiv.style.backgroundColor = '#e7f3ff';
    powerLegendDiv.style.padding = '0.75rem';
    powerLegendDiv.style.borderRadius = '0.25rem';
    powerLegendDiv.style.marginBottom = '1rem';
    powerLegendDiv.style.border = '1px solid #0d6efd';
    powerLegendDiv.innerHTML = `
        <strong>üìä Mocnina matice A<sup>k</sup>[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>A<sup>k</sup>[i,j] = ƒç√≠slo:</strong> Poƒçet proch√°zek d√©lky k z i do j<br>
            ‚Ä¢ <strong>A¬≤:</strong> Cesty s 2 hranami (zprost≈ôedkovan√≠ soused√©)<br>
            ‚Ä¢ <strong>A¬≥:</strong> Cesty s 3 hranami atd.<br>
            ‚Ä¢ <strong>Zji≈°≈•uje≈°:</strong> Kolik zp≈Øsob≈Ø j√≠t z i do j p≈ôesnƒõ k kroky
        </div>
    `;
    powerSection.appendChild(powerLegendDiv);
    
    powerSection.appendChild(createQuerySection('Dotaz na A¬≤', 'power2'));
    powerSection.appendChild(createQuerySection('Dotaz na A¬≥', 'power3'));
    
    // Custom power query section
    const customPowerDiv = document.createElement('div');
    customPowerDiv.className = 'query-section';
    customPowerDiv.innerHTML = '<h3>Libovoln√° mocnina matice sousednosti</h3>';
    
    // Add legend
    const customPowerLegendDiv = document.createElement('div');
    customPowerLegendDiv.style.backgroundColor = '#fff3cd';
    customPowerLegendDiv.style.padding = '0.75rem';
    customPowerLegendDiv.style.borderRadius = '0.25rem';
    customPowerLegendDiv.style.marginBottom = '1rem';
    customPowerLegendDiv.style.border = '1px solid #ffc107';
    customPowerLegendDiv.innerHTML = `
        <strong>üìñ Vysvƒõtlen√≠:</strong><br>
        <span style="margin-left: 1rem;">‚Ä¢ <strong>A<sup>k</sup>[u, v]</strong> ud√°v√° poƒçet cest <strong>d√©lky k</strong> z uzlu <strong>u</strong> do uzlu <strong>v</strong></span><br>
        <span style="margin-left: 1rem;">‚Ä¢ Nap≈ô√≠klad A<sup>3</sup>[A, C] = 5 znamen√°, ≈æe existuje <strong>5 r≈Øzn√Ωch cest d√©lky 3</strong> z uzlu A do uzlu C</span><br>
        <span style="margin-left: 1rem;">‚Ä¢ D√©lka cesty = poƒçet hran v cestƒõ (ne poƒçet uzl≈Ø!)</span>
    `;
    customPowerDiv.appendChild(customPowerLegendDiv);
    
    const customPowerInputDiv = document.createElement('div');
    customPowerInputDiv.className = 'query-inputs';

    const powerDatalist = document.createElement('datalist');
    powerDatalist.id = 'nodes-datalist-power';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        powerDatalist.appendChild(option);
    });
    customPowerDiv.appendChild(powerDatalist);

    const selectPowerU = document.createElement('input');
    selectPowerU.setAttribute('list', 'nodes-datalist-power');
    const selectPowerV = document.createElement('input');
    selectPowerV.setAttribute('list', 'nodes-datalist-power');
    
    const powerInput = document.createElement('input');
    powerInput.type = 'number';
    powerInput.min = '1';
    powerInput.max = '20';
    powerInput.value = '4';
    powerInput.style.width = '80px';
    powerInput.style.padding = '0.5rem';
    powerInput.style.border = '1px solid #ced4da';
    powerInput.style.borderRadius = '0.25rem';
    
    const customPowerBtn = document.createElement('button');
    customPowerBtn.textContent = 'Vypoƒç√≠tat';
    
    const customPowerResultDiv = document.createElement('div');
    customPowerResultDiv.className = 'query-result';
    customPowerResultDiv.style.display = 'none';
    
    customPowerBtn.addEventListener('click', () => {
        const u = selectPowerU.value;
        const v = selectPowerV.value;
        const k = parseInt(powerInput.value);
        
        if (k < 1 || k > 20) {
            customPowerResultDiv.textContent = 'Mocnina mus√≠ b√Ωt mezi 1 a 20';
            customPowerResultDiv.style.display = 'block';
            return;
        }
        
        customPowerBtn.disabled = true;
        customPowerBtn.textContent = 'Poƒç√≠t√°m...';
        
        setTimeout(() => {
            const result = graph.adjacencyPowerValue(u, v, k);
            customPowerResultDiv.textContent = `A^${k}[${u}, ${v}] = ${result}`;
            customPowerResultDiv.style.display = 'block';
            customPowerBtn.disabled = false;
            customPowerBtn.textContent = 'Vypoƒç√≠tat';
        }, 50);
    });
    
    const labelPowerU = document.createElement('span');
    labelPowerU.textContent = 'Od uzlu: ';
    customPowerInputDiv.appendChild(labelPowerU);
    customPowerInputDiv.appendChild(selectPowerU);
    
    const labelPowerV = document.createElement('span');
    labelPowerV.textContent = ' Do uzlu: ';
    customPowerInputDiv.appendChild(labelPowerV);
    customPowerInputDiv.appendChild(selectPowerV);
    
    const labelPower = document.createElement('span');
    labelPower.textContent = ' Mocnina: ';
    customPowerInputDiv.appendChild(labelPower);
    customPowerInputDiv.appendChild(powerInput);
    customPowerInputDiv.appendChild(customPowerBtn);
    
    customPowerDiv.appendChild(customPowerInputDiv);
    customPowerDiv.appendChild(customPowerResultDiv);
    powerSection.appendChild(customPowerDiv);
    
    const showPowerBtn = document.createElement('button');
    showPowerBtn.textContent = 'Zobrazit cel√© matice';
    const powerMatrixDiv = document.createElement('div');
    powerMatrixDiv.style.display = 'none';
    const powerStatsDiv = document.createElement('div');
    powerStatsDiv.style.display = 'none';
    powerStatsDiv.style.marginTop = '1rem';

    showPowerBtn.addEventListener('click', () => {
        if (powerMatrixDiv.style.display === 'none') {
            const A2 = graph.adjacencyPower(2);
            const A3 = graph.adjacencyPower(3);
            powerMatrixDiv.innerHTML = '<h3>A¬≤</h3>';
            const div2 = document.createElement('div');
            div2.className = 'matrix';
            div2.appendChild(createMatrixTable(A2, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div2);
            powerMatrixDiv.innerHTML += '<h3>A¬≥</h3>';
            const div3 = document.createElement('div');
            div3.className = 'matrix';
            div3.appendChild(createMatrixTable(A3, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div3);

            // Add stats
            const stats2 = countMatrixValues(A2);
            const stats3 = countMatrixValues(A3);
            powerStatsDiv.innerHTML = `
                <div style="padding: 1rem; background-color: #e7f3ff; border-radius: 0.25rem;">
                    <h4 style="margin-top: 0;">Statistika hodnot A¬≤:</h4>
                    ${Object.entries(stats2.counts).map(([key, count]) => `<strong>${key}:</strong> ${count}√ó`).join(', ')}
                </div>
                <div style="margin-top: 1rem; padding: 1rem; background-color: #e7f3ff; border-radius: 0.25rem;">
                    <h4 style="margin-top: 0;">Statistika hodnot A¬≥:</h4>
                    ${Object.entries(stats3.counts).map(([key, count]) => `<strong>${key}:</strong> ${count}√ó`).join(', ')}
                </div>
            `;

            powerMatrixDiv.style.display = 'block';
            powerStatsDiv.style.display = 'block';
            showPowerBtn.textContent = 'Skr√Ωt matice';
        } else {
            powerMatrixDiv.style.display = 'none';
            powerStatsDiv.style.display = 'none';
            showPowerBtn.textContent = 'Zobrazit cel√© matice';
        }
    });
    powerSection.appendChild(showPowerBtn);
    powerSection.appendChild(powerMatrixDiv);
    powerSection.appendChild(powerStatsDiv);
    output.appendChild(powerSection);

    // Sum of walks query section
    const sumWalksSection = document.createElement('div');
    sumWalksSection.className = 'section';
    sumWalksSection.innerHTML = '<h2>Suma v≈°ech proch√°zek (‚àë A¬π + A¬≤ + ... + A·µè)</h2>';
    
    const sumWalksDiv = document.createElement('div');
    sumWalksDiv.className = 'query-section';
    sumWalksDiv.innerHTML = '<h3>Dotaz na celkov√Ω poƒçet proch√°zek d√©lek 1 a≈æ k</h3>';
    
    // Add legend
    const sumWalksLegendDiv = document.createElement('div');
    sumWalksLegendDiv.style.backgroundColor = '#e7f3ff';
    sumWalksLegendDiv.style.padding = '0.75rem';
    sumWalksLegendDiv.style.borderRadius = '0.25rem';
    sumWalksLegendDiv.style.marginBottom = '1rem';
    sumWalksLegendDiv.style.border = '1px solid #0d6efd';
    sumWalksLegendDiv.innerHTML = `
        <strong>üìä Vysvƒõtlen√≠:</strong><br>
        <span style="margin-left: 1rem;">‚Ä¢ Seƒçte poƒçet v≈°ech proch√°zek d√©lek 1, 2, 3, ..., a≈æ k mezi uzly U a V</span><br>
        <span style="margin-left: 1rem;">‚Ä¢ Nap≈ô. pro k=3: poƒç√≠t√° cesty d√©lky 1 + cesty d√©lky 2 + cesty d√©lky 3</span><br>
        <span style="margin-left: 1rem;">‚Ä¢ U≈æiteƒçn√© pro anal√Ωzu celkov√© propojitelnosti uzl≈Ø</span>
    `;
    sumWalksDiv.appendChild(sumWalksLegendDiv);
    
    const sumWalksInputDiv = document.createElement('div');
    sumWalksInputDiv.className = 'query-inputs';

    const sumDatalist = document.createElement('datalist');
    sumDatalist.id = 'nodes-datalist-sum';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        sumDatalist.appendChild(option);
    });
    sumWalksDiv.appendChild(sumDatalist);

    const selectSumU = document.createElement('input');
    selectSumU.setAttribute('list', 'nodes-datalist-sum');
    const selectSumV = document.createElement('input');
    selectSumV.setAttribute('list', 'nodes-datalist-sum');
    
    const sumKInput = document.createElement('input');
    sumKInput.type = 'number';
    sumKInput.min = '1';
    sumKInput.max = '10';
    sumKInput.value = '3';
    sumKInput.style.width = '80px';
    sumKInput.style.padding = '0.5rem';
    sumKInput.style.border = '1px solid #ced4da';
    sumKInput.style.borderRadius = '0.25rem';
    
    const sumWalksBtn = document.createElement('button');
    sumWalksBtn.textContent = 'Vypoƒç√≠tat';
    
    const sumWalksResultDiv = document.createElement('div');
    sumWalksResultDiv.className = 'query-result';
    sumWalksResultDiv.style.display = 'none';
    
    sumWalksBtn.addEventListener('click', () => {
        const u = selectSumU.value;
        const v = selectSumV.value;
        const k = parseInt(sumKInput.value);
        
        if (k < 1 || k > 10) {
            sumWalksResultDiv.textContent = 'Hodnota k mus√≠ b√Ωt mezi 1 a 10';
            sumWalksResultDiv.style.display = 'block';
            return;
        }
        
        sumWalksBtn.disabled = true;
        sumWalksBtn.textContent = 'Poƒç√≠t√°m...';
        
        setTimeout(() => {
            const result = graph.sumWalksValue(u, v, k);
            sumWalksResultDiv.innerHTML = `‚àë proch√°zek (d√©lky 1..${k}) z <strong>${u}</strong> do <strong>${v}</strong>: <strong>${result}</strong><br>
                <small>Celkov√Ω poƒçet v≈°ech cest d√©lek 1 a≈æ ${k}</small>`;
            sumWalksResultDiv.style.display = 'block';
            sumWalksBtn.disabled = false;
            sumWalksBtn.textContent = 'Vypoƒç√≠tat';
        }, 50);
    });
    
    const labelSumU = document.createElement('span');
    labelSumU.textContent = 'Od uzlu: ';
    sumWalksInputDiv.appendChild(labelSumU);
    sumWalksInputDiv.appendChild(selectSumU);
    
    const labelSumV = document.createElement('span');
    labelSumV.textContent = ' Do uzlu: ';
    sumWalksInputDiv.appendChild(labelSumV);
    sumWalksInputDiv.appendChild(selectSumV);
    
    const labelSumK = document.createElement('span');
    labelSumK.textContent = ' Max. d√©lka k: ';
    sumWalksInputDiv.appendChild(labelSumK);
    sumWalksInputDiv.appendChild(sumKInput);
    sumWalksInputDiv.appendChild(sumWalksBtn);
    
    sumWalksDiv.appendChild(sumWalksInputDiv);
    sumWalksDiv.appendChild(sumWalksResultDiv);
    sumWalksSection.appendChild(sumWalksDiv);
    output.appendChild(sumWalksSection);

    // Incidence matrix with signed/unsigned toggle
    const incSection = document.createElement('div');
    incSection.className = 'section';
    incSection.innerHTML = '<h2>Matice incidence</h2>';
    
    const incLegendDiv = document.createElement('div');
    incLegendDiv.style.backgroundColor = '#e7f3ff';
    incLegendDiv.style.padding = '0.75rem';
    incLegendDiv.style.borderRadius = '0.25rem';
    incLegendDiv.style.marginBottom = '1rem';
    incLegendDiv.style.border = '1px solid #0d6efd';
    incLegendDiv.innerHTML = `
        <strong>ÔøΩ Matice incidence:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>-1 v ≈ô√°dku:</strong> Uzel je ocas orientovan√© hrany (v√Ωchoz√≠)<br>
            ‚Ä¢ <strong>+1 v ≈ô√°dku:</strong> Uzel je hlava orientovan√© hrany (c√≠lov√Ω)<br>
            ‚Ä¢ <strong>1 v ≈ô√°dku (oboj√≠):</strong> Uzel je incidentn√≠ s neorientovanou hranou<br>
            ‚Ä¢ <strong>0 v ≈ô√°dku:</strong> Uzel nen√≠ incidentn√≠ s touto hranou
        </div>
    `;
    incSection.appendChild(incLegendDiv);
    
    const incToggleDiv = document.createElement('div');
    incToggleDiv.style.marginBottom = '1rem';
    incToggleDiv.innerHTML = '<label><input type="checkbox" id="incSigned" checked /> Podepsan√° (signed)</label>';
    incSection.appendChild(incToggleDiv);

    const searchIncInput = document.createElement('input');
    searchIncInput.type = 'text';
    searchIncInput.placeholder = 'Hledat v matici...';
    searchIncInput.style.marginBottom = '1rem';
    searchIncInput.style.display = 'none'; // Hide by default
    searchIncInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const table = incMatrixDiv.querySelector('table');
        if (!table) return;
        table.querySelectorAll('td').forEach(cell => {
            if (query && cell.textContent.toLowerCase().includes(query)) {
                cell.classList.add('highlight');
            } else {
                cell.classList.remove('highlight');
            }
        });
    });
    incSection.appendChild(searchIncInput);
    
    const showIncBtn = document.createElement('button');
    showIncBtn.textContent = 'Zobrazit matici';
    const incMatrixDiv = document.createElement('div');
    incMatrixDiv.className = 'matrix';
    incMatrixDiv.style.display = 'none';
    
    showIncBtn.addEventListener('click', () => {
        if (incMatrixDiv.style.display === 'none') {
            const signed = document.getElementById('incSigned').checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
            incMatrixDiv.style.display = 'block';
            searchIncInput.style.display = 'block';
            showIncBtn.textContent = 'Skr√Ωt matici';
        } else {
            incMatrixDiv.style.display = 'none';
            searchIncInput.style.display = 'none';
            showIncBtn.textContent = 'Zobrazit matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'incSigned' && incMatrixDiv.style.display === 'block') {
            const signed = e.target.checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
        }
    });
    
    incSection.appendChild(showIncBtn);
    incSection.appendChild(incMatrixDiv);
    output.appendChild(incSection);

    // Reachability matrix (transitive closure)
    const reachSection = document.createElement('div');
    reachSection.className = 'section';
    reachSection.innerHTML = '<h2>Dosa≈æitelnost (transitivn√≠ uz√°vƒõr)</h2>';
    
    const reachLegendDiv = document.createElement('div');
    reachLegendDiv.style.backgroundColor = '#e7f3ff';
    reachLegendDiv.style.padding = '0.75rem';
    reachLegendDiv.style.borderRadius = '0.25rem';
    reachLegendDiv.style.marginBottom = '1rem';
    reachLegendDiv.style.border = '1px solid #0d6efd';
    reachLegendDiv.innerHTML = `
        <strong>üîÑ Dosa≈æitelnost R[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>R[i,j] = 1:</strong> Uzel j je dosa≈æiteln√Ω z i (existuje cesta)<br>
            ‚Ä¢ <strong>R[i,j] = 0:</strong> Uzel j NEN√ç dosa≈æiteln√Ω z i<br>
            ‚Ä¢ <strong>R[i,i] = 1:</strong> V≈ædy (uzel dos√°hne s√°m sebe)<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong> Zji≈°tƒõn√≠ komponent a souvislosti
        </div>
    `;
    reachSection.appendChild(reachLegendDiv);
    
    // Query interface
    const reachQueryDiv = document.createElement('div');
    reachQueryDiv.className = 'query-section';
    reachQueryDiv.innerHTML = '<h3>Dotaz na dosa≈æitelnost</h3>';
    
    const reachInputDiv = document.createElement('div');
    reachInputDiv.className = 'query-inputs';
    
    const selectReachU = document.createElement('select');
    const selectReachV = document.createElement('select');
    graph.nodes.forEach(node => {
        const opt1 = document.createElement('option');
        opt1.value = node;
        opt1.textContent = node;
        selectReachU.appendChild(opt1);
        
        const opt2 = document.createElement('option');
        opt2.value = node;
        opt2.textContent = node;
        selectReachV.appendChild(opt2);
    });
    
    const reachQueryBtn = document.createElement('button');
    reachQueryBtn.textContent = 'Je dosa≈æiteln√Ω?';
    
    const reachQueryResult = document.createElement('div');
    reachQueryResult.className = 'query-result';
    reachQueryResult.style.display = 'none';
    
    reachQueryBtn.addEventListener('click', () => {
        const u = selectReachU.value;
        const v = selectReachV.value;
        const reachMat = graph.reachability();
        const uIdx = graph.nodes.indexOf(u);
        const vIdx = graph.nodes.indexOf(v);
        const isReachable = reachMat[uIdx][vIdx] === 1;
        
        reachQueryResult.innerHTML = `<strong>${u} ‚Üí ${v}:</strong> ${isReachable ? '‚úÖ ANO (dosa≈æiteln√Ω)' : '‚ùå NE (nedosa≈æiteln√Ω)'}`;
        reachQueryResult.style.display = 'block';
    });
    
    const labelReachU = document.createElement('span');
    labelReachU.textContent = 'Z uzlu: ';
    reachInputDiv.appendChild(labelReachU);
    reachInputDiv.appendChild(selectReachU);
    
    const labelReachV = document.createElement('span');
    labelReachV.textContent = ' Do uzlu: ';
    reachInputDiv.appendChild(labelReachV);
    reachInputDiv.appendChild(selectReachV);
    reachInputDiv.appendChild(reachQueryBtn);
    
    reachQueryDiv.appendChild(reachInputDiv);
    reachQueryDiv.appendChild(reachQueryResult);
    reachSection.appendChild(reachQueryDiv);
    
    // Statistics button
    const showReachStatsBtn = document.createElement('button');
    showReachStatsBtn.textContent = 'Zobrazit statistiky dosa≈æitelnosti';
    showReachStatsBtn.style.marginTop = '1rem';
    const reachStatsDiv = document.createElement('div');
    reachStatsDiv.style.display = 'none';
    reachStatsDiv.style.marginTop = '1rem';
    
    showReachStatsBtn.addEventListener('click', () => {
        if (reachStatsDiv.style.display === 'none') {
            const reachMat = graph.reachability();
            const n = graph.nodes.length;
            const components = graph.getComponents();
            
            // Calculate statistics
            const reachableFrom = {}; // kolik uzl≈Ø je dosa≈æiteln√Ωch z ka≈æd√©ho uzlu
            const reachableBy = {};   // z kolika uzl≈Ø je ka≈æd√Ω uzel dosa≈æiteln√Ω
            let totalReachable = 0;
            
            for (let i = 0; i < n; i++) {
                reachableFrom[graph.nodes[i]] = 0;
                reachableBy[graph.nodes[i]] = 0;
            }
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (i !== j && reachMat[i][j] === 1) {
                        reachableFrom[graph.nodes[i]]++;
                        reachableBy[graph.nodes[j]]++;
                        totalReachable++;
                    }
                }
            }
            
            const maxPossible = n * (n - 1);
            const reachabilityPercent = ((totalReachable / maxPossible) * 100).toFixed(1);
            
            // Isolated nodes (cannot reach anyone, no one can reach them)
            const isolated = graph.nodes.filter(node => 
                reachableFrom[node] === 0 && reachableBy[node] === 0
            );
            
            reachStatsDiv.innerHTML = `
                <div style="background-color: #f8f9fa; padding: 1rem; border-radius: 0.25rem; border: 1px solid #dee2e6;">
                    <h3 style="margin-top: 0; color: #0d6efd;">üìà Statistiky dosa≈æitelnosti a komponent</h3>
                    
                    <div style="background-color: white; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem;">
                        <strong>Celkov√° dosa≈æitelnost:</strong><br>
                        ‚Ä¢ <strong>${totalReachable}</strong> z ${maxPossible} mo≈æn√Ωch spojen√≠ (${reachabilityPercent}%)<br>
                        ‚Ä¢ Pr≈Ømƒõrnƒõ ka≈æd√Ω uzel dos√°hne <strong>${(totalReachable / n).toFixed(1)}</strong> uzl≈Ø<br>
                        ‚Ä¢ Graf m√° <strong>${components.length}</strong> ${components.length === 1 ? 'komponentu' : components.length < 5 ? 'komponenty' : 'komponent'}
                    </div>
                    
                    ${isolated.length > 0 ? `
                    <div style="background-color: #fff3cd; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem; border: 1px solid #ffc107;">
                        <strong>‚ö†Ô∏è Izolovan√© uzly (${isolated.length}):</strong><br>
                        <span style="font-size: 0.9rem;">Tyto uzly nemaj√≠ ≈æ√°dn√© spojen√≠ s ostatn√≠mi:</span><br>
                        <code style="background-color: #fff; padding: 0.25rem 0.5rem; border-radius: 0.25rem; display: inline-block; margin-top: 0.25rem;">
                            ${isolated.slice(0, 30).join(', ')}${isolated.length > 30 ? ` ... a dal≈°√≠ch ${isolated.length - 30}` : ''}
                        </code>
                    </div>
                    ` : ''}
                    
                    <div style="background-color: white; padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 1rem;">
                        <strong>üîó Komponenty grafu (${components.length}):</strong><br>
                        <span style="font-size: 0.9rem; color: #666;">Ka≈æd√° komponenta m√° reprezentanta (ko≈ôenov√Ω uzel) - pou≈æij ho pro BFS:</span><br>
                        <div style="margin-top: 0.5rem;">
                            ${components.map((comp, idx) => `
                                <div style="background-color: ${idx % 2 === 0 ? '#f8f9fa' : '#fff'}; padding: 0.5rem; margin-top: 0.25rem; border-radius: 0.25rem; border-left: 3px solid ${idx === 0 ? '#0d6efd' : idx === 1 ? '#198754' : '#dc3545'};">
                                    <strong>Komponenta ${idx + 1}</strong> (${comp.size} ${comp.size === 1 ? 'uzel' : comp.size < 5 ? 'uzly' : 'uzl≈Ø'}):
                                    <br>
                                    <span style="font-size: 0.9rem;">
                                        üéØ <strong>Reprezentant (root):</strong> <code style="background-color: #e7f3ff; padding: 0.1rem 0.4rem; border-radius: 0.2rem; font-weight: bold;">${comp.root}</code>
                                        ${comp.size <= 20 ? `<br>üì¶ Uzly: ${comp.nodes.join(', ')}` : `<br>üì¶ Prvn√≠ uzly: ${comp.nodes.slice(0, 20).join(', ')} ... (celkem ${comp.size})`}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            reachStatsDiv.style.display = 'block';
            showReachStatsBtn.textContent = 'Skr√Ωt statistiky';
        } else {
            reachStatsDiv.style.display = 'none';
            showReachStatsBtn.textContent = 'Zobrazit statistiky dosa≈æitelnosti';
        }
    });
    
    reachSection.appendChild(showReachStatsBtn);
    reachSection.appendChild(reachStatsDiv);
    
    // Full matrix (only for small graphs)
    if (graph.nodes.length <= 50) {
        const showReachMatrixBtn = document.createElement('button');
        showReachMatrixBtn.textContent = 'Zobrazit celou matici';
        showReachMatrixBtn.style.marginTop = '0.5rem';
        const reachMatrixDiv = document.createElement('div');
        reachMatrixDiv.className = 'matrix';
        reachMatrixDiv.style.display = 'none';
        
        showReachMatrixBtn.addEventListener('click', () => {
            if (reachMatrixDiv.style.display === 'none') {
                const reachMat = graph.reachability();
                reachMatrixDiv.innerHTML = '';
                reachMatrixDiv.appendChild(createMatrixTable(reachMat, graph.nodes, graph.nodes));
                reachMatrixDiv.style.display = 'block';
                showReachMatrixBtn.textContent = 'Skr√Ωt matici';
            } else {
                reachMatrixDiv.style.display = 'none';
                showReachMatrixBtn.textContent = 'Zobrazit celou matici';
            }
        });
        
        reachSection.appendChild(showReachMatrixBtn);
        reachSection.appendChild(reachMatrixDiv);
    } else {
        const warningDiv = document.createElement('div');
        warningDiv.style.marginTop = '1rem';
        warningDiv.style.padding = '0.75rem';
        warningDiv.style.backgroundColor = '#fff3cd';
        warningDiv.style.borderRadius = '0.25rem';
        warningDiv.style.border = '1px solid #ffc107';
        warningDiv.innerHTML = `
            <strong>‚ÑπÔ∏è Pozn√°mka:</strong> Graf m√° ${graph.nodes.length} uzl≈Ø - matice ${graph.nodes.length}√ó${graph.nodes.length} by byla nep≈ôehledn√°. 
            Pou≈æijte dotaz nebo statistiky v√Ω≈°e.
        `;
        reachSection.appendChild(warningDiv);
    }
    
    output.appendChild(reachSection);

    // BFS Layers
    const bfsSection = document.createElement('div');
    bfsSection.className = 'section';
    bfsSection.innerHTML = '<h2>BFS Vrstvy (Breadth-First Search Layers)</h2>';
    
    const bfsLegendDiv = document.createElement('div');
    bfsLegendDiv.style.backgroundColor = '#e7f3ff';
    bfsLegendDiv.style.padding = '0.75rem';
    bfsLegendDiv.style.borderRadius = '0.25rem';
    bfsLegendDiv.style.marginBottom = '1rem';
    bfsLegendDiv.style.border = '1px solid #0d6efd';
    bfsLegendDiv.innerHTML = `
        <strong>üåä BFS vrstvy:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Vrstva 0:</strong> Startovn√≠ uzel<br>
            ‚Ä¢ <strong>Vrstva k:</strong> Uzly dostupn√© v k kroc√≠ch ze startu<br>
            ‚Ä¢ <strong>Ka≈æd√Ω uzel:</strong> Objev√≠ se pr√°vƒõ v jedn√© vrstvƒõ<br>
            ‚Ä¢ <strong>U≈æit√≠:</strong> Vzd√°lenost od start, komponenty, ≈°√≠≈ôen√≠ informace
        </div>
    `;
    bfsSection.appendChild(bfsLegendDiv);
    
    const bfsControlDiv = document.createElement('div');
    bfsControlDiv.style.marginBottom = '1rem';
    bfsControlDiv.innerHTML = '<label>Startovn√≠ uzel: <input id="bfsStart" list="nodes-datalist-bfs"></label> <button id="bfsBtn" class="btn" style="margin-left: 0.5rem;">Spoƒç√≠tat vrstvy</button>';
    bfsSection.appendChild(bfsControlDiv);

    const bfsDatalist = document.createElement('datalist');
    bfsDatalist.id = 'nodes-datalist-bfs';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        bfsDatalist.appendChild(option);
    });
    bfsSection.appendChild(bfsDatalist);

    const bfsStartSelect = document.getElementById('bfsStart');
    
    const bfsResultDiv = document.createElement('div');
    bfsResultDiv.className = 'scroll';
    bfsResultDiv.style.display = 'none';
    bfsSection.appendChild(bfsResultDiv);
    
    bfsControlDiv.querySelector('#bfsBtn').addEventListener('click', () => {
        const start = document.getElementById('bfsStart').value;
        const layers = graph.bfsLayers(start);
        let html = '<h4>Vrstvy uzl≈Ø:</h4>';
        for (const [k, nodes] of Object.entries(layers)) {
            html += `<div style="margin: 0.5rem 0;"><strong>Vrstva ${k}:</strong> ${nodes.join(', ')}</div>`;
        }
        bfsResultDiv.innerHTML = html;
        bfsResultDiv.style.display = 'block';
    });
    
    output.appendChild(bfsSection);

    // All shortest paths (unweighted)
    const allPathsSection = document.createElement('div');
    allPathsSection.className = 'section';
    allPathsSection.innerHTML = '<h2>V≈°echny nejkrat≈°√≠ cesty (neohodnocen√©)</h2>';
    
    const allPathsLegendDiv = document.createElement('div');
    allPathsLegendDiv.style.backgroundColor = '#e7f3ff';
    allPathsLegendDiv.style.padding = '0.75rem';
    allPathsLegendDiv.style.borderRadius = '0.25rem';
    allPathsLegendDiv.style.marginBottom = '1rem';
    allPathsLegendDiv.style.border = '1px solid #0d6efd';
    allPathsLegendDiv.innerHTML = `
        <strong>üõ§Ô∏è V≈°echny nejkrat≈°√≠ cesty:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Najde V≈†ECHNY:</strong> Cesty stejn√© d√©lky mezi U a V<br>
            ‚Ä¢ <strong>Algoritmus:</strong> BFS (d√©lka = poƒçet hran)<br>
            ‚Ä¢ <strong>Limit 200:</strong> Zobraz√≠ max 200 cest (m≈Ø≈æe jich b√Ωt hodnƒõ!)<br>
            ‚Ä¢ <strong>Vyu≈æit√≠:</strong> Anal√Ωza redundance, alternativn√≠ trasy
        </div>
    `;
    allPathsSection.appendChild(allPathsLegendDiv);
    
    const allPathsControlDiv = document.createElement('div');
    allPathsControlDiv.className = 'query-inputs';

    const allPathsDatalist = document.createElement('datalist');
    allPathsDatalist.id = 'nodes-datalist-allpaths';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        allPathsDatalist.appendChild(option);
    });
    allPathsSection.appendChild(allPathsDatalist);

    const selectAllU = document.createElement('input');
    selectAllU.setAttribute('list', 'nodes-datalist-allpaths');
    const selectAllV = document.createElement('input');
    selectAllV.setAttribute('list', 'nodes-datalist-allpaths');
    
    const allPathsBtn = document.createElement('button');
    allPathsBtn.textContent = 'Naj√≠t v≈°echny cesty';
    
    allPathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    allPathsControlDiv.appendChild(selectAllU);
    const labelAllV = document.createElement('span');
    labelAllV.textContent = ' Do uzlu: ';
    allPathsControlDiv.appendChild(labelAllV);
    allPathsControlDiv.appendChild(selectAllV);
    allPathsControlDiv.appendChild(allPathsBtn);
    
    allPathsSection.appendChild(allPathsControlDiv);
    
    const allPathsResultDiv = document.createElement('div');
    allPathsResultDiv.className = 'scroll';
    allPathsResultDiv.style.display = 'none';
    allPathsSection.appendChild(allPathsResultDiv);
    
    allPathsBtn.addEventListener('click', () => {
        const u = selectAllU.value;
        const v = selectAllV.value;
        const paths = graph.allShortestPathsUnweighted(u, v);
        
        if (paths.length === 0) {
            allPathsResultDiv.textContent = 'Nenalezena ≈æ√°dn√° cesta.';
        } else {
            let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">Poƒçet nejkrat≈°√≠ch cest: ${paths.length}</div>`;
            html += paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' ‚Üí ')}`).join('<br/>');
            if (paths.length > 200) html += '<br/>‚Ä¶ dal≈°√≠ nezobrazeny (limit 200)';
            allPathsResultDiv.innerHTML = html;
        }
        allPathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(allPathsSection);

    // Simple paths up to K
    const simplePathsSection = document.createElement('div');
    simplePathsSection.className = 'section';
    simplePathsSection.innerHTML = '<h2>Jednoduch√© cesty U‚ÜíV do d√©lky K</h2>';
    
    const simplePathsLegendDiv = document.createElement('div');
    simplePathsLegendDiv.style.backgroundColor = '#e7f3ff';
    simplePathsLegendDiv.style.padding = '0.75rem';
    simplePathsLegendDiv.style.borderRadius = '0.25rem';
    simplePathsLegendDiv.style.marginBottom = '1rem';
    simplePathsLegendDiv.style.border = '1px solid #0d6efd';
    simplePathsLegendDiv.innerHTML = `
        <strong>üéØ Jednoduch√© cesty (do d√©lky K):</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>Jednoduch√° cesta:</strong> Neproch√°z√≠ ≈æ√°dn√Ω uzel v√≠cekr√°t<br>
            ‚Ä¢ <strong>Max d√©lka K:</strong> Obsahuje max K hran<br>
            ‚Ä¢ <strong>Bez limitu K:</strong> Hled√° a≈æ do d√©lky |V|-1<br>
            ‚Ä¢ <strong>Limit 10,000:</strong> Maxim√°lnƒõ 10,000 v√Ωsledk≈Ø kv≈Øli v√Ωkonu
        </div>
    `;
    simplePathsSection.appendChild(simplePathsLegendDiv);
    
    const simplePathsControlDiv = document.createElement('div');
    simplePathsControlDiv.className = 'query-inputs';

    const simplePathsDatalist = document.createElement('datalist');
    simplePathsDatalist.id = 'nodes-datalist-simplepaths';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        simplePathsDatalist.appendChild(option);
    });
    simplePathsSection.appendChild(simplePathsDatalist);

    const selectSimpleU = document.createElement('input');
    selectSimpleU.setAttribute('list', 'nodes-datalist-simplepaths');
    const selectSimpleV = document.createElement('input');
    selectSimpleV.setAttribute('list', 'nodes-datalist-simplepaths');
    
    const simpleKInput = document.createElement('input');
    simpleKInput.type = 'number';
    simpleKInput.min = '1';
    simpleKInput.placeholder = 'K (pr√°zdn√© = |V|-1)';
    simpleKInput.style.width = '150px';
    simpleKInput.style.padding = '0.5rem';
    simpleKInput.style.border = '1px solid #ced4da';
    simpleKInput.style.borderRadius = '0.25rem';
    
    const simplePathsBtn = document.createElement('button');
    simplePathsBtn.textContent = 'Naj√≠t cesty';
    
    simplePathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    simplePathsControlDiv.appendChild(selectSimpleU);
    const labelSimpleV = document.createElement('span');
    labelSimpleV.textContent = ' Do uzlu: ';
    simplePathsControlDiv.appendChild(labelSimpleV);
    simplePathsControlDiv.appendChild(selectSimpleV);
    const labelSimpleK = document.createElement('span');
    labelSimpleK.textContent = ' Max d√©lka K: ';
    simplePathsControlDiv.appendChild(labelSimpleK);
    simplePathsControlDiv.appendChild(simpleKInput);
    simplePathsControlDiv.appendChild(simplePathsBtn);
    
    simplePathsSection.appendChild(simplePathsControlDiv);
    
    const simplePathsResultDiv = document.createElement('div');
    simplePathsResultDiv.className = 'scroll';
    simplePathsResultDiv.style.display = 'none';
    simplePathsSection.appendChild(simplePathsResultDiv);
    
    simplePathsBtn.addEventListener('click', () => {
        const u = selectSimpleU.value;
        const v = selectSimpleV.value;
        const K = simpleKInput.value ? parseInt(simpleKInput.value, 10) : null;
        const result = graph.simplePathsUpTo(u, v, K, 10000);
        
        const more = (result.count > result.paths.length) ? ' (zastaveno na limitu 10,000)' : '';
        let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">Poƒçet: ${result.count}${more}</div>`;
        html += result.paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' ‚Üí ')}`).join('<br/>');
        if (result.count > 200) html += '<br/>‚Ä¶ dal≈°√≠ nezobrazeny (limit 200)';
        
        simplePathsResultDiv.innerHTML = html;
        simplePathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(simplePathsSection);

    // Neighbor sets by direction
    const neighborSection = document.createElement('div');
    neighborSection.className = 'section';
    neighborSection.innerHTML = '<h2>Soused√© podle smƒõru</h2>';
    
    const neighborLegendDiv = document.createElement('div');
    neighborLegendDiv.style.backgroundColor = '#e7f3ff';
    neighborLegendDiv.style.padding = '0.75rem';
    neighborLegendDiv.style.borderRadius = '0.25rem';
    neighborLegendDiv.style.marginBottom = '1rem';
    neighborLegendDiv.style.border = '1px solid #0d6efd';
    neighborLegendDiv.innerHTML = `
        <strong>üë• Soused√© podle typu hrany:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>OUT (‚Üí):</strong> Uzly, do kter√Ωch vede hrana ven<br>
            ‚Ä¢ <strong>IN (‚Üê):</strong> Uzly, ze kter√Ωch vede hrana dovnit≈ô<br>
            ‚Ä¢ <strong>UND (‚Äî):</strong> Uzly spojen√© neorientovanou hranou<br>
            ‚Ä¢ <strong>Stupe≈à uzlu:</strong> |OUT| + |IN| + |UND| (s korekc√≠)
        </div>
    `;
    neighborSection.appendChild(neighborLegendDiv);
    
    const neighborControlDiv = document.createElement('div');
    neighborControlDiv.style.marginBottom = '1rem';
    neighborControlDiv.innerHTML = '<label>Uzel: <input id="neighborSelect" list="nodes-datalist-neighbor"></label> <button id="neighborBtn" style="margin-left: 0.5rem;">Zobrazit sousedy</button>';
    neighborSection.appendChild(neighborControlDiv);

    const neighborDatalist = document.createElement('datalist');
    neighborDatalist.id = 'nodes-datalist-neighbor';
    graph.nodes.forEach(node => {
        const option = document.createElement('option');
        option.value = node;
        neighborDatalist.appendChild(option);
    });
    neighborSection.appendChild(neighborDatalist);

    const neighborSelect = document.getElementById('neighborSelect');
    
    const neighborResultDiv = document.createElement('div');
    neighborResultDiv.className = 'scroll';
    neighborResultDiv.style.display = 'none';
    neighborSection.appendChild(neighborResultDiv);
    
    neighborControlDiv.querySelector('#neighborBtn').addEventListener('click', () => {
        const node = document.getElementById('neighborSelect').value;
        const neighbors = graph.neighborSets(node);
        let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
        html += `<div style="padding: 0.5rem; background-color: #d1ecf1; border-radius: 0.25rem;"><strong>OUT (odchoz√≠):</strong> ${neighbors.out.join(', ') || '‚àÖ'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #d4edda; border-radius: 0.25rem;"><strong>IN (p≈ô√≠choz√≠):</strong> ${neighbors.inn.join(', ') || '‚àÖ'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #fff3cd; border-radius: 0.25rem;"><strong>Neorientovan√≠:</strong> ${neighbors.und.join(', ') || '‚àÖ'}</div>`;
        html += '</div>';
        neighborResultDiv.innerHTML = html;
        neighborResultDiv.style.display = 'block';
    });
    
    output.appendChild(neighborSection);

    // Length matrix with query
    const lenSection = document.createElement('div');
    lenSection.className = 'section';
    lenSection.innerHTML = '<h2>Matice d√©lek</h2>';
    
    // P≈ôidej vysvƒõtlivku
    const lenLegendDiv = document.createElement('div');
    lenLegendDiv.style.backgroundColor = '#e7f3ff';
    lenLegendDiv.style.padding = '0.75rem';
    lenLegendDiv.style.borderRadius = '0.25rem';
    lenLegendDiv.style.marginBottom = '1rem';
    lenLegendDiv.style.border = '1px solid #0d6efd';
    lenLegendDiv.innerHTML = `
        <strong>üìä Matice d√©lek L[i,j]:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem;">
            ‚Ä¢ <strong>L[i,j] = ƒç√≠slo:</strong> V√°ha/d√©lka p≈ô√≠m√© hrany<br>
            ‚Ä¢ <strong>L[i,j] = ‚àû:</strong> Bez p≈ô√≠m√©ho spojen√≠<br>
            ‚Ä¢ <strong>L[i,i] = 0:</strong> Vzd√°lenost k sobƒõ sam√©mu<br>
            ‚Ä¢ <strong>Pozn√°mka:</strong> Jen p≈ô√≠m√© hrany, ne nejkrat≈°√≠ cesty
        </div>
    `;
    lenSection.appendChild(lenLegendDiv);
    
    lenSection.appendChild(createQuerySection('Dotaz na hodnotu', 'length'));

    const searchLenInput = document.createElement('input');
    searchLenInput.type = 'text';
    searchLenInput.placeholder = 'Hledat v matici...';
    searchLenInput.style.marginBottom = '1rem';
    searchLenInput.style.display = 'none'; // Hide by default
    searchLenInput.addEventListener('input', (e) => {
        const query = e.target.value.toLowerCase();
        const table = lenMatrixDiv.querySelector('table');
        if (!table) return;
        table.querySelectorAll('td').forEach(cell => {
            if (query && cell.textContent.toLowerCase().includes(query)) {
                cell.classList.add('highlight');
            } else {
                cell.classList.remove('highlight');
            }
        });
    });
    lenSection.appendChild(searchLenInput);
    
    const showLenBtn = document.createElement('button');
    showLenBtn.textContent = 'Zobrazit celou matici';
    const lenMatrixDiv = document.createElement('div');
    lenMatrixDiv.className = 'matrix';
    lenMatrixDiv.style.display = 'none';
    const lenStatsDiv = document.createElement('div');
    lenStatsDiv.style.display = 'none';
    lenStatsDiv.style.marginTop = '1rem';
    lenStatsDiv.style.padding = '1rem';
    lenStatsDiv.style.backgroundColor = '#e7f3ff';
    lenStatsDiv.style.borderRadius = '0.25rem';

    showLenBtn.addEventListener('click', () => {
        if (lenMatrixDiv.style.display === 'none') {
            const lenMat = graph.lengthMatrix();
            lenMatrixDiv.innerHTML = '';
            lenMatrixDiv.appendChild(createMatrixTable(lenMat, graph.nodes, graph.nodes));

            // Count values in length matrix
            const { counts, total } = countMatrixValues(lenMat);
            lenStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
            const statsHTML = Object.entries(counts).map(([key, count]) => {
                const percentage = ((count / total) * 100).toFixed(1);
                return `<div style="display: inline-block; margin-right: 1.5rem; margin-bottom: 0.5rem;">
                    <strong>Hodnota ${key}:</strong> ${count}√ó (${percentage}%)
                </div>`;
            }).join('');
            lenStatsDiv.innerHTML += statsHTML;
            lenStatsDiv.innerHTML += `<div style="margin-top: 0.5rem; font-weight: bold;">Celkem hodnot: ${total}</div>`;

            const rowColStatsDiv = document.createElement('div');
            rowColStatsDiv.style.marginTop = '1rem';
            lenStatsDiv.appendChild(rowColStatsDiv);

            const showRowStatsBtn = document.createElement('button');
            showRowStatsBtn.textContent = 'Statistiky po ≈ô√°dc√≠ch';
            showRowStatsBtn.onclick = () => showRowColStats('row', lenMat, rowColStatsDiv);
            lenStatsDiv.appendChild(showRowStatsBtn);

            const showColStatsBtn = document.createElement('button');
            showColStatsBtn.textContent = 'Statistiky po sloupc√≠ch';
            showColStatsBtn.onclick = () => showRowColStats('col', lenMat, rowColStatsDiv);
            lenStatsDiv.appendChild(showColStatsBtn);

            lenMatrixDiv.style.display = 'block';
            lenStatsDiv.style.display = 'block';
            searchLenInput.style.display = 'block';
            showLenBtn.textContent = 'Skr√Ωt matici';
        } else {
            lenMatrixDiv.style.display = 'none';
            lenStatsDiv.style.display = 'none';
            searchLenInput.style.display = 'none';
            showLenBtn.textContent = 'Zobrazit celou matici';
        }
    });
    lenSection.appendChild(showLenBtn);
    lenSection.appendChild(lenMatrixDiv);
    lenSection.appendChild(lenStatsDiv);
    output.appendChild(lenSection);

    // Shortest path query
    const shortestSection = document.createElement('div');
    shortestSection.className = 'section';
    shortestSection.innerHTML = '<h2>Nejkrat≈°√≠ cesty (Floyd-Warshall)</h2>';
    shortestSection.appendChild(createQuerySection('Dotaz na nejkrat≈°√≠ cestu', 'shortest'));
    
    const showPredBtn = document.createElement('button');
    showPredBtn.textContent = 'Vypoƒç√≠tat celou matici p≈ôedch≈Ødc≈Ø';
    const predMatrixDiv = document.createElement('div');
    predMatrixDiv.className = 'matrix';
    predMatrixDiv.style.display = 'none';
    showPredBtn.addEventListener('click', () => {
        if (predMatrixDiv.style.display === 'none') {
            showPredBtn.disabled = true;
            showPredBtn.textContent = 'Poƒç√≠t√°m...';
            setTimeout(() => {
                const fw = graph.floydWarshall();
                const pred = fw.pred.map(row => row.map(p => p === null ? '‚Äì' : graph.nodes[p]));
                predMatrixDiv.innerHTML = '';
                predMatrixDiv.appendChild(createMatrixTable(pred, graph.nodes, graph.nodes));
                predMatrixDiv.style.display = 'block';
                showPredBtn.textContent = 'Skr√Ωt matici';
                showPredBtn.disabled = false;
            }, 50);
        } else {
            predMatrixDiv.style.display = 'none';
            showPredBtn.textContent = 'Zobrazit celou matici';
        }
    });
    shortestSection.appendChild(showPredBtn);
    shortestSection.appendChild(predMatrixDiv);
    output.appendChild(shortestSection);

    // Incident edges
    const incident = graph.incidentEdges();
    const incEdgeSection = document.createElement('div');
    incEdgeSection.className = 'section';
    incEdgeSection.innerHTML = '<h2>Tabulka incidentn√≠ch hran</h2>';
    const incEdgeDiv = document.createElement('div');
    incEdgeDiv.className = 'matrix';
    incEdgeDiv.appendChild(createListTable(incident));
    incEdgeSection.appendChild(incEdgeDiv);
    output.appendChild(incEdgeSection);

    // Neighbours
    const neighbours = graph.neighbours();
    const neighSection = document.createElement('div');
    neighSection.className = 'section';
    neighSection.innerHTML = '<h2>Seznam soused≈Ø</h2>';
    const neighDiv = document.createElement('div');
    neighDiv.className = 'matrix';
    neighDiv.appendChild(createListTable(neighbours));
    neighSection.appendChild(neighDiv);
    output.appendChild(neighSection);

    // Multiple edges detection and listing
    const multipleEdges = graph.findMultipleEdges();
    const multiEdgeSection = document.createElement('div');
    multiEdgeSection.className = 'section';
    multiEdgeSection.innerHTML = '<h2>V√≠ce√°sobn√© hrany</h2>';
    
    if (multipleEdges.length === 0) {
        const noMultiMsg = document.createElement('p');
        noMultiMsg.textContent = 'Graf neobsahuje ≈æ√°dn√© v√≠ce√°sobn√© hrany.';
        noMultiMsg.style.color = '#28a745';
        noMultiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(noMultiMsg);
    } else {
        const multiMsg = document.createElement('p');
        multiMsg.textContent = `Nalezeno ${multipleEdges.length} skupin v√≠ce√°sobn√Ωch hran:`;
        multiMsg.style.color = '#dc3545';
        multiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(multiMsg);
        
        const multiEdgeDiv = document.createElement('div');
        multiEdgeDiv.className = 'scrollable-list';
        const multiList = document.createElement('ul');
        multiList.style.listStyle = 'none';
        multiList.style.padding = '0';
        
        for (const group of multipleEdges) {
            const li = document.createElement('li');
            li.style.marginBottom = '1rem';
            li.style.padding = '0.5rem';
            li.style.backgroundColor = '#fff3cd';
            li.style.border = '1px solid #ffc107';
            li.style.borderRadius = '0.25rem';
            
            const title = document.createElement('strong');
            title.textContent = `${group.key} (${group.count}√ó n√°sobn√° hrana)`;
            li.appendChild(title);
            
            const edgeList = document.createElement('ul');
            edgeList.style.marginTop = '0.5rem';
            edgeList.style.marginLeft = '1rem';
            
            for (const e of group.edges) {
                const edgeLi = document.createElement('li');
                const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
                const label = e.label ? ` [${e.label}]` : '';
                let orientation;
                if (e.direction === '>') orientation = '‚Üí';
                else if (e.direction === '<') orientation = '‚Üê';
                else orientation = '‚Äî';
                edgeLi.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
                edgeList.appendChild(edgeLi);
            }
            
            li.appendChild(edgeList);
            multiList.appendChild(li);
        }
        
        multiEdgeDiv.appendChild(multiList);
        multiEdgeSection.appendChild(multiEdgeDiv);
    }
    
    output.appendChild(multiEdgeSection);

    // Properties (props u≈æ je definovan√© na zaƒç√°tku)
    const propSection = document.createElement('div');
    propSection.className = 'section';
    propSection.innerHTML = '<h2>Vlastnosti grafu</h2>';
    
    // P≈ôidej vysvƒõtlivky pro u≈æivatele
    const legendDiv = document.createElement('div');
    legendDiv.style.backgroundColor = '#fff3cd';
    legendDiv.style.padding = '1rem';
    legendDiv.style.borderRadius = '0.25rem';
    legendDiv.style.marginBottom = '1rem';
    legendDiv.style.border = '1px solid #ffc107';
    legendDiv.innerHTML = `
        <strong>üìñ Rychl√Ω slovn√≠k pojm≈Ø:</strong><br>
        <div style="margin-left: 1rem; margin-top: 0.5rem; line-height: 1.6; font-size: 0.95rem;">
            ‚Ä¢ <strong>Ohodnocen√Ω:</strong> M√° v√°hy na hran√°ch/uzlech | <strong>Orientovan√Ω:</strong> Hrany maj√≠ smƒõr (‚Üí)<br>
            ‚Ä¢ <strong>Souvisl√Ω:</strong> Z ka≈æd√©ho uzlu lze dojet do ka≈æd√©ho | <strong>Silnƒõ/Slabƒõ:</strong> Pouze v orientovan√Ωch<br>
            ‚Ä¢ <strong>Prost√Ω:</strong> Max 1 hrana mezi uzly | <strong>Jednoduch√Ω:</strong> Prost√Ω bez smyƒçek<br>
            ‚Ä¢ <strong>√öpln√Ω:</strong> V≈°echny uzly spojeny | <strong>Regul√°rn√≠:</strong> V≈°echny uzly stejn√Ω stupe≈à<br>
            ‚Ä¢ <strong>Bipartitn√≠:</strong> Uzly v 2 skupin√°ch, hrany jen mezi | <strong>Rovinn√Ω:</strong> Nakresliteln√Ω bez k≈ô√≠≈æen√≠
        </div>
    `;
    propSection.appendChild(legendDiv);
    
    const propDiv = document.createElement('div');
    propDiv.className = 'properties';
    const addProp = (name, value) => {
        const span = document.createElement('span');
        span.textContent = `${name}: ${value}`;
        propDiv.appendChild(span);
    };
    addProp('Ohodnocen√Ω', props.weighted ? 'ano' : 'ne');
    addProp('Orientace', props.oriented);
    addProp('Souvisl√Ω', props.connected ? 'ano' : 'ne');
    
    // ‚ö° OPRAVA: Zobraz strong/weak connectivity chyt≈ôe
    if (props.oriented === 'orientovan√Ω') {
        if (props.stronglyConnected) {
            addProp('Silnƒõ souvisl√Ω', 'ano');
            // Slabƒõ souvisl√Ω nemus√≠me zobrazovat - je implicitn√≠!
        } else if (props.weaklyConnected) {
            addProp('Silnƒõ souvisl√Ω', 'ne');
            addProp('Slabƒõ souvisl√Ω', 'ano');
        } else {
            addProp('Silnƒõ souvisl√Ω', 'ne');
            addProp('Slabƒõ souvisl√Ω', 'ne');
        }
    }
    
    addProp('Prost√Ω', props.prosty ? 'ano' : 'ne');
    addProp('Jednoduch√Ω', props.jednoduchy ? 'ano' : 'ne');
    addProp('Multigraf', props.multigraph ? 'ano' : 'ne');
    addProp('Diskr√©tn√≠', props.discrete ? 'ano (bez hran)' : 'ne');
    addProp('Koneƒçn√Ω', props.finite ? 'ano' : 'ne');
    addProp('Symetrizovan√Ω', props.symmetric ? 'ano' : 'ne');
    addProp('√öpln√Ω', props.complete ? 'ano' : 'ne');
    addProp('Regul√°rn√≠', props.regular ? 'ano' : 'ne');
    addProp('Bipartitn√≠', props.bipartite ? 'ano' : 'ne');
    addProp('Rovinn√Ω', typeof props.planar === 'string' ? props.planar : (props.planar ? 'ano' : 'ne'));
    propSection.appendChild(propDiv);
    output.appendChild(propSection);
});
</script>
</body>
</html>