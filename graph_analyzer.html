<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="utf-8">
    <title>Graph Analyzer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 1.5rem;
            background-color: #f8f9fa;
            color: #212529;
        }
        h1, h2, h3 {
            color: #0d6efd;
        }
        textarea {
            width: 100%;
            max-width: 100%;
            min-height: 160px;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            font-family: monospace;
            margin-bottom: 1rem;
        }
        button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background-color: #0d6efd;
            color: #fff;
            border: none;
            border-radius: 0.25rem;
            cursor: pointer;
            margin-bottom: 1rem;
            margin-right: 0.5rem;
        }
        button:hover {
            background-color: #0b5ed7;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 0.25rem 0.5rem;
            text-align: center;
        }
        th {
            background-color: #e9ecef;
        }
        .matrix {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
        .section {
            margin-bottom: 2rem;
        }
        .properties span {
            display: inline-block;
            margin-right: 1rem;
            margin-bottom: 0.5rem;
            padding: 0.25rem 0.5rem;
            background-color: #e2e3e5;
            border-radius: 0.25rem;
        }
        .query-section {
            background-color: #fff;
            padding: 1rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            margin-bottom: 1rem;
        }
        .query-inputs {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .query-inputs select {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
        }
        .query-result {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: #e7f3ff;
            border-radius: 0.25rem;
            font-weight: bold;
        }
        .scrollable-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            padding: 0.5rem;
            background-color: #fff;
        }
        .degree-info {
            display: inline-block;
            margin-left: 0.5rem;
            color: #6c757d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
<h1>Graph Analyzer</h1>
<p>Zadejte definici grafu ve formátu uvedeném v zadání. Každý uzel se definuje
pomocí řádku začínajícího <code>u</code> a každá hrana pomocí řádku začínajícího
<code>h</code>. Orientace hrany se určuje šipkami <code>&lt;</code>, <code>&gt;</code> nebo
pomlčkou <code>-</code>. Ohodnocení je volitelné.</p>
<textarea id="graphInput">u A;
u B;
h A &gt; B 1 :h1;
u C;
h B &gt; C 1 :h2;
u D;
h A &gt; D 2 :h3;
u E;
h A &lt; E 2 :h4;
h B &lt; E 3 :h5;
h C &gt; E 3 :h6;
h D &gt; E 4 :h8;
u F;
h C &gt; F 4 :h7;
h E &gt; F 5 :h9;
u G;
h D &lt; G 5 :h10;
h E &gt; G 6 :h11;
u H;
h H &gt; E 6 :h12;
h F &gt; H 7 :h13;
h G &lt; H 7 :h14;</textarea>
<button id="parseBtn">Analyzovat graf</button>

<div id="counters" style="margin: 1rem 0; padding: 1rem; background-color: #e7f3ff; border: 1px solid #0d6efd; border-radius: 0.25rem; display: none;">
    <h3 style="margin-top: 0; color: #0d6efd;">Základní statistiky</h3>
    <div style="display: flex; gap: 2rem; font-size: 1.1rem;">
        <div><strong>Počet uzlů:</strong> <span id="nodeCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
        <div><strong>Počet hran:</strong> <span id="edgeCount" style="color: #0b5ed7; font-weight: bold;">0</span></div>
    </div>
</div>

<div id="output"></div>

<script>
// Graph analyzer with optimizations for large graphs
class Graph {
    constructor() {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
    }

    parse(text) {
        this.nodes = [];
        this.nodeWeights = {};
        this.edges = [];
        this._cachedAdjMatrix = null;
        this._cachedDegrees = null;
        
        const lines = text.split(/\r?\n/);
        const nodePattern = /^u\s+([^\s;]+)(?:\s+([-+]?[0-9]*\.?[0-9]+))?\s*;/i;
        const edgePattern = /^h\s+([^\s<>-]+)\s*([<>-])\s*([^\s<>-]+)\s*(?:([-+]?[0-9]*\.?[0-9]+))?\s*(?::([^;]+))?\s*;/i;
        
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue;
            let m;
            if ((m = nodePattern.exec(trimmed))) {
                const id = m[1];
                if (id === '*') continue;
                const weight = m[2] !== undefined ? parseFloat(m[2]) : null;
                if (!this.nodes.includes(id)) {
                    this.nodes.push(id);
                    this.nodeWeights[id] = weight;
                }
            } else if ((m = edgePattern.exec(trimmed))) {
                const u = m[1];
                const direction = m[2];
                const v = m[3];
                const weight = m[4] !== undefined ? parseFloat(m[4]) : null;
                const label = m[5] ? m[5].trim() : null;
                this.edges.push({ u, v, direction, weight, label });
            }
        }
        this.edges = this.edges.filter(e => this.nodes.includes(e.u) && this.nodes.includes(e.v));
    }

    adjacencyMatrix(binary = false) {
        if (!binary && this._cachedAdjMatrix) return this._cachedAdjMatrix;
        
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const mat = Array.from({ length: n }, () => Array(n).fill(0));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                mat[i][j] += 1;
            } else if (e.direction === '<') {
                mat[j][i] += 1;
            } else {
                mat[i][j] += 1;
                mat[j][i] += 1;
            }
        }
        
        if (binary) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    mat[i][j] = mat[i][j] > 0 ? 1 : 0;
                }
            }
        } else {
            this._cachedAdjMatrix = mat;
        }
        
        return mat;
    }

    // Optimized: query single cell instead of computing full matrix
    adjacencyValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) count++;
            else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) count++;
            else if (e.direction === '-' && 
                     ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) count++;
        }
        return count;
    }

    lengthMatrix() {
        const n = this.nodes.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const INF = Infinity;
        const mat = Array.from({ length: n }, (_, i) => 
            Array.from({ length: n }, (__, j) => i === j ? 0 : INF));
        
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>') {
                if (w < mat[i][j]) mat[i][j] = w;
            } else if (e.direction === '<') {
                if (w < mat[j][i]) mat[j][i] = w;
            } else {
                if (w < mat[i][j]) mat[i][j] = w;
                if (w < mat[j][i]) mat[j][i] = w;
            }
        }
        return mat;
    }

    // Optimized: query single cell
    lengthValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        if (nodeU === nodeV) return 0;
        
        let minWeight = Infinity;
        for (const e of this.edges) {
            const w = e.weight !== null && e.weight !== undefined ? e.weight : 1;
            if (e.direction === '>' && e.u === nodeU && e.v === nodeV) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '<' && e.u === nodeV && e.v === nodeU) {
                minWeight = Math.min(minWeight, w);
            } else if (e.direction === '-' && 
                       ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU))) {
                minWeight = Math.min(minWeight, w);
            }
        }
        return minWeight;
    }

    signMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const S = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                S[i][j] = A[i][j] - A[j][i];
            }
        }
        return S;
    }

    signValue(nodeU, nodeV) {
        const adjUV = this.adjacencyValue(nodeU, nodeV);
        const adjVU = this.adjacencyValue(nodeV, nodeU);
        if (adjUV === null || adjVU === null) return null;
        return adjUV - adjVU;
    }

    static multiplyMatrices(X, Y) {
        const n = X.length;
        const result = Array.from({ length: n }, () => Array(n).fill(0));
        for (let i = 0; i < n; i++) {
            for (let k = 0; k < n; k++) {
                if (X[i][k] === 0) continue;
                for (let j = 0; j < n; j++) {
                    if (Y[k][j] === 0) continue;
                    result[i][j] += X[i][k] * Y[k][j];
                }
            }
        }
        return result;
    }

    adjacencyPower(k) {
        let A = this.adjacencyMatrix();
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result;
    }

    // Optimized: compute power for specific cell
    adjacencyPowerValue(nodeU, nodeV, k) {
        const A = this.adjacencyMatrix();
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let result = A;
        for (let i = 1; i < k; i++) {
            result = Graph.multiplyMatrices(result, A);
        }
        return result[uIdx][vIdx];
    }

    // Laplacian matrix L = D - A
    laplacianMatrix() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const L = Array.from({ length: n }, () => Array(n).fill(0));
        
        // Compute degree for each node
        for (let i = 0; i < n; i++) {
            let degree = 0;
            for (let j = 0; j < n; j++) {
                degree += A[i][j];
            }
            L[i][i] = degree; // Diagonal: degree
            for (let j = 0; j < n; j++) {
                if (i !== j) {
                    L[i][j] = -A[i][j]; // Off-diagonal: -A[i][j]
                }
            }
        }
        return L;
    }

    // Get single value from Laplacian matrix
    laplacianValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        if (uIdx === vIdx) {
            // Diagonal: degree of node
            let degree = 0;
            for (const e of this.edges) {
                if (e.u === nodeU || e.v === nodeU) {
                    if (e.u === e.v) degree += 2; // Loop counts twice
                    else degree += 1;
                }
            }
            return degree;
        } else {
            // Off-diagonal: -A[i][j]
            return -this.adjacencyValue(nodeU, nodeV);
        }
    }

    // Sum of all walks from length 1 to k
    sumWalksValue(nodeU, nodeV, k) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        const A = this.adjacencyMatrix();
        let sum = 0;
        let currentPower = A;
        
        for (let i = 1; i <= k; i++) {
            sum += currentPower[uIdx][vIdx];
            if (i < k) {
                currentPower = Graph.multiplyMatrices(currentPower, A);
            }
        }
        return sum;
    }

    // Multiplicity: count all edges between U and V (regardless of direction for undirected)
    multiplicityValue(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        let count = 0;
        for (const e of this.edges) {
            // Count all edges connecting these two nodes
            if ((e.u === nodeU && e.v === nodeV) || (e.u === nodeV && e.v === nodeU)) {
                count++;
            }
        }
        return count;
    }

    // Reachability matrix (transitive closure)
    reachability() {
        const A = this.adjacencyMatrix();
        const n = A.length;
        const R = A.map(row => row.map(v => v > 0 ? 1 : 0));
        
        // Floyd-Warshall on binary matrix
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                if (R[i][k] === 1) {
                    for (let j = 0; j < n; j++) {
                        if (R[k][j] === 1) R[i][j] = 1;
                    }
                }
            }
        }
        return R;
    }

    // BFS Layers from start node
    bfsLayers(startNode) {
        const idx = this.nodes.indexOf(startNode);
        if (idx === -1) return {};
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const layers = { 0: [startNode] };
        const seen = new Set([idx]);
        let frontier = [idx];
        let k = 0;
        
        while (frontier.length) {
            const next = [];
            for (const u of frontier) {
                for (const v of adjList[u]) {
                    if (!seen.has(v)) {
                        seen.add(v);
                        next.push(v);
                    }
                }
            }
            if (!next.length) break;
            k++;
            layers[k] = next.map(i => this.nodes[i]).sort();
            frontier = next;
        }
        return layers;
    }

    // All shortest paths (unweighted BFS)
    allShortestPathsUnweighted(src, dst) {
        const srcIdx = this.nodes.indexOf(src);
        const dstIdx = this.nodes.indexOf(dst);
        if (srcIdx === -1 || dstIdx === -1) return [];
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list (outgoing edges)
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const dist = Array(n).fill(Infinity);
        dist[srcIdx] = 0;
        const parents = Array.from({ length: n }, () => []);
        const queue = [srcIdx];
        
        while (queue.length) {
            const u = queue.shift();
            for (const v of adjList[u]) {
                if (dist[v] === Infinity) {
                    dist[v] = dist[u] + 1;
                    parents[v].push(u);
                    queue.push(v);
                } else if (dist[v] === dist[u] + 1) {
                    parents[v].push(u);
                }
            }
        }
        
        if (dist[dstIdx] === Infinity) return [];
        
        // Reconstruct all paths
        const paths = [];
        const stack = [dstIdx];
        
        const reconstruct = (v) => {
            if (v === srcIdx) {
                paths.push(stack.slice().reverse().map(i => this.nodes[i]));
                return;
            }
            for (const p of parents[v]) {
                stack.push(p);
                reconstruct(p);
                stack.pop();
            }
        };
        
        reconstruct(dstIdx);
        return paths;
    }

    // Simple paths up to length K (no repeated nodes)
    simplePathsUpTo(srcNode, dstNode, K = null, cap = 10000) {
        const srcIdx = this.nodes.indexOf(srcNode);
        const dstIdx = this.nodes.indexOf(dstNode);
        if (srcIdx === -1 || dstIdx === -1) return { count: 0, paths: [] };
        
        const n = this.nodes.length;
        const adjList = Array.from({ length: n }, () => []);
        
        // Build adjacency list
        for (const e of this.edges) {
            const i = this.nodes.indexOf(e.u);
            const j = this.nodes.indexOf(e.v);
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        const maxLen = (K === null) ? (n - 1) : K;
        const paths = [];
        let count = 0;
        const visited = new Set();
        
        const dfs = (u, depth, acc) => {
            if (count >= cap) return;
            if (u === dstIdx) {
                paths.push(acc.map(i => this.nodes[i]));
                count++;
                return;
            }
            if (depth === 0) return;
            
            for (const w of adjList[u]) {
                if (visited.has(w)) continue;
                visited.add(w);
                acc.push(w);
                dfs(w, depth - 1, acc);
                acc.pop();
                visited.delete(w);
            }
        };
        
        visited.add(srcIdx);
        dfs(srcIdx, maxLen, [srcIdx]);
        visited.delete(srcIdx);
        
        return { count, paths };
    }

    // Neighbor sets by direction
    neighborSets(nodeU) {
        const out = new Set();
        const inn = new Set();
        const und = new Set();
        
        for (const e of this.edges) {
            if (e.direction === '>') {
                if (e.u === nodeU) out.add(e.v);
                if (e.v === nodeU) inn.add(e.u);
            } else if (e.direction === '<') {
                if (e.v === nodeU) out.add(e.u);
                if (e.u === nodeU) inn.add(e.v);
            } else {
                if (e.u === nodeU) und.add(e.v);
                if (e.v === nodeU) und.add(e.u);
            }
        }
        
        return {
            out: [...out].sort(),
            inn: [...inn].sort(),
            und: [...und].sort()
        };
    }

    incidenceMatrix(signed = true) {
        const n = this.nodes.length;
        const m = this.edges.length;
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        const inc = Array.from({ length: n }, () => Array(m).fill(0));
        
        this.edges.forEach((e, ci) => {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                if (signed) {
                    inc[i][ci] = -1;
                    inc[j][ci] = 1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else if (e.direction === '<') {
                if (signed) {
                    inc[j][ci] = 1;
                    inc[i][ci] = -1;
                } else {
                    inc[i][ci] = 1;
                    inc[j][ci] = 1;
                }
            } else {
                inc[i][ci] = 1;
                inc[j][ci] = 1;
            }
        });
        return inc;
    }

    floydWarshall() {
        const n = this.nodes.length;
        const dist = this.lengthMatrix().map(row => row.slice());
        const pred = Array.from({ length: n }, () => Array(n).fill(null));
        
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                if (i !== j && dist[i][j] < Infinity) {
                    pred[i][j] = i;
                }
            }
        }
        
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const alt = dist[i][k] + dist[k][j];
                    if (alt < dist[i][j]) {
                        dist[i][j] = alt;
                        pred[i][j] = pred[k][j];
                    }
                }
            }
        }
        return { dist, pred };
    }

    // Optimized: compute shortest path for specific pair
    shortestPath(nodeU, nodeV) {
        const uIdx = this.nodes.indexOf(nodeU);
        const vIdx = this.nodes.indexOf(nodeV);
        if (uIdx === -1 || vIdx === -1) return null;
        
        // Simple Dijkstra for single source-target
        const n = this.nodes.length;
        const dist = Array(n).fill(Infinity);
        const visited = Array(n).fill(false);
        const pred = Array(n).fill(null);
        dist[uIdx] = 0;
        
        for (let count = 0; count < n; count++) {
            let minDist = Infinity;
            let u = -1;
            for (let i = 0; i < n; i++) {
                if (!visited[i] && dist[i] < minDist) {
                    minDist = dist[i];
                    u = i;
                }
            }
            if (u === -1 || u === vIdx) break;
            visited[u] = true;
            
            for (const e of this.edges) {
                const w = e.weight !== null ? e.weight : 1;
                let vNeighbor = -1;
                if (e.direction === '>' && e.u === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.v);
                } else if (e.direction === '<' && e.v === this.nodes[u]) {
                    vNeighbor = this.nodes.indexOf(e.u);
                } else if (e.direction === '-') {
                    if (e.u === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.v);
                    else if (e.v === this.nodes[u]) vNeighbor = this.nodes.indexOf(e.u);
                }
                
                if (vNeighbor !== -1 && !visited[vNeighbor]) {
                    const alt = dist[u] + w;
                    if (alt < dist[vNeighbor]) {
                        dist[vNeighbor] = alt;
                        pred[vNeighbor] = u;
                    }
                }
            }
        }
        
        // Reconstruct path
        const path = [];
        if (dist[vIdx] < Infinity) {
            let current = vIdx;
            while (current !== null) {
                path.unshift(this.nodes[current]);
                current = pred[current];
            }
        }
        
        return {
            distance: dist[vIdx],
            predecessor: pred[vIdx] !== null ? this.nodes[pred[vIdx]] : null,
            path: path
        };
    }

    incidentEdges() {
        const map = {};
        this.nodes.forEach(id => { map[id] = []; });
        this.edges.forEach(e => {
            const desc = e.label ? e.label : `${e.u}${e.direction}${e.v}`;
            map[e.u].push(desc);
            map[e.v].push(desc);
        });
        return map;
    }

    neighbours() {
        const map = {};
        this.nodes.forEach(id => { map[id] = new Set(); });
        this.edges.forEach(e => {
            map[e.u].add(e.v);
            map[e.v].add(e.u);
        });
        const result = {};
        for (const id of this.nodes) {
            result[id] = Array.from(map[id]);
        }
        return result;
    }

    // Compute and cache degrees
    degrees() {
        if (this._cachedDegrees) return this._cachedDegrees;
        
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            if (e.u === e.v) {
                degrees[e.u] += 2;
            } else {
                degrees[e.u] += 1;
                degrees[e.v] += 1;
            }
        }
        this._cachedDegrees = degrees;
        return degrees;
    }

    // Check if directed graph is strongly connected using Kosaraju's algorithm
    isStronglyConnected() {
        const n = this.nodes.length;
        if (n === 0) return true;
        
        const idx = {};
        this.nodes.forEach((id, i) => { idx[id] = i; });
        
        // Build directed adjacency list
        const adjList = Array.from({ length: n }, () => []);
        for (const e of this.edges) {
            const i = idx[e.u];
            const j = idx[e.v];
            if (e.direction === '>') {
                adjList[i].push(j);
            } else if (e.direction === '<') {
                adjList[j].push(i);
            } else {
                // Undirected edge - add both directions
                adjList[i].push(j);
                adjList[j].push(i);
            }
        }
        
        // DFS from first node
        const visited = new Array(n).fill(false);
        const dfs = (start) => {
            const stack = [start];
            visited[start] = true;
            let count = 1;
            
            while (stack.length > 0) {
                const u = stack.pop();
                for (const v of adjList[u]) {
                    if (!visited[v]) {
                        visited[v] = true;
                        stack.push(v);
                        count++;
                    }
                }
            }
            return count;
        };
        
        if (dfs(0) !== n) return false;
        
        // Build reverse graph
        const reverseAdj = Array.from({ length: n }, () => []);
        for (let u = 0; u < n; u++) {
            for (const v of adjList[u]) {
                reverseAdj[v].push(u);
            }
        }
        
        // DFS on reverse graph
        visited.fill(false);
        const stack = [0];
        visited[0] = true;
        let count = 1;
        
        while (stack.length > 0) {
            const u = stack.pop();
            for (const v of reverseAdj[u]) {
                if (!visited[v]) {
                    visited[v] = true;
                    stack.push(v);
                    count++;
                }
            }
        }
        
        return count === n;
    }

    // Find all multiple edges in the graph
    findMultipleEdges() {
        const edgeMap = new Map();
        const multipleEdges = [];
        
        for (const e of this.edges) {
            // Create key based on nodes and direction
            let key;
            if (e.direction === '>') {
                key = `${e.u}>${e.v}`;
            } else if (e.direction === '<') {
                key = `${e.v}>${e.u}`;
            } else {
                // For undirected edges, normalize the key
                key = e.u <= e.v ? `${e.u}-${e.v}` : `${e.v}-${e.u}`;
            }
            
            if (!edgeMap.has(key)) {
                edgeMap.set(key, []);
            }
            edgeMap.get(key).push(e);
        }
        
        // Find groups with multiple edges
        for (const [key, edges] of edgeMap.entries()) {
            if (edges.length > 1) {
                multipleEdges.push({
                    key: key,
                    count: edges.length,
                    edges: edges
                });
            }
        }
        
        return multipleEdges;
    }

    
    properties() {
        const props = {};
        const n = this.nodes.length;
        
        // Weighted: any edge weight specified and different from 1, or any node has weight
        let weightedEdge = false;
        for (const e of this.edges) {
            if (e.weight !== null && e.weight !== undefined && e.weight !== 1) {
                weightedEdge = true;
                break;
            }
        }
        let weightedNode = false;
        for (const id of this.nodes) {
            const w = this.nodeWeights[id];
            if (w !== null && w !== undefined) {
                weightedNode = true;
                break;
            }
        }
        props.weighted = weightedEdge || weightedNode;
        
        // Orientation: determine if graph is directed, undirected or mixed
        let hasDirected = false;
        let hasUndirected = false;
        for (const e of this.edges) {
            if (e.direction === '-' || e.direction === '–') hasUndirected = true;
            else hasDirected = true;
        }
        if (hasDirected && !hasUndirected) props.oriented = 'orientovaný';
        else if (!hasDirected && hasUndirected) props.oriented = 'neorientovaný';
        else props.oriented = 'smíšený';
        
        // Connectivity: BFS on underlying undirected graph
        const visited = new Array(n).fill(false);
        if (n > 0) {
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            const neighbours = this.neighbours();
            const queue = [0];
            visited[0] = true;
            while (queue.length > 0) {
                const i = queue.shift();
                const u = this.nodes[i];
                for (const v of neighbours[u]) {
                    const j = idx[v];
                    if (!visited[j]) {
                        visited[j] = true;
                        queue.push(j);
                    }
                }
            }
        }
        props.connected = visited.every(v => v);
        
        // Strong and weak connectivity for directed graphs
        if (props.oriented === 'orientovaný') {
            props.stronglyConnected = this.isStronglyConnected();
            props.weaklyConnected = props.connected;
        }
        
        // Finite: always true for parsed input
        props.finite = true;
        
        // Loops and multiple edges - OPTIMIZED with Set
        let loops = 0;
        const edgeSet = new Set();
        let multiEdges = false;
        
        for (const e of this.edges) {
            if (e.u === e.v) {
                loops++;
                continue;
            }
            const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
            if (edgeSet.has(key)) {
                multiEdges = true;
                if (loops > 0) break;
            } else {
                edgeSet.add(key);
            }
        }
        
        props.prosty = !multiEdges;
        props.jednoduchy = !multiEdges && loops === 0;
        
        // Complete: OPTIMIZED - skip for large graphs
        if (n > 50) {
            props.complete = false;
        } else {
            let complete = true;
            const edgeSetComplete = new Set();
            for (const e of this.edges) {
                const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
                edgeSetComplete.add(key);
            }
            const expectedEdges = (n * (n - 1)) / 2;
            complete = edgeSetComplete.size >= expectedEdges;
            if (complete) {
                for (let i = 0; i < n && complete; i++) {
                    for (let j = i + 1; j < n; j++) {
                        const u = this.nodes[i];
                        const v = this.nodes[j];
                        const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                        if (!edgeSetComplete.has(key)) {
                            complete = false;
                            break;
                        }
                    }
                }
            }
            props.complete = complete;
        }
        
        // Regular: OPTIMIZED - compute degrees efficiently
        const degrees = {};
        this.nodes.forEach(id => { degrees[id] = 0; });
        
        for (const e of this.edges) {
            if (e.u === e.v) {
                degrees[e.u] += 2;
            } else {
                degrees[e.u] += 1;
                degrees[e.v] += 1;
            }
        }
        
        const degValues = Object.values(degrees);
        const firstDeg = degValues[0];
        props.regular = degValues.every(d => d === firstDeg);
        
        // Bipartite: OPTIMIZED - early exit on odd cycle
        props.bipartite = (() => {
            if (n === 0) return true;
            const colours = new Array(n).fill(-1);
            const neighbours = this.neighbours();
            const idx = {};
            this.nodes.forEach((id,i) => { idx[id] = i; });
            
            for (let start = 0; start < n; start++) {
                if (colours[start] !== -1) continue;
                const queue = [start];
                colours[start] = 0;
                
                while (queue.length > 0) {
                    const uIdx = queue.shift();
                    const u = this.nodes[uIdx];
                    const currentColour = colours[uIdx];
                    
                    for (const v of neighbours[u]) {
                        const vIdx = idx[v];
                        if (colours[vIdx] === -1) {
                            colours[vIdx] = 1 - currentColour;
                            queue.push(vIdx);
                        } else if (colours[vIdx] === currentColour) {
                            return false;
                        }
                    }
                }
            }
            return true;
        })();
        
        // Planar: OPTIMIZED for ALL graph sizes using fast heuristics
        props.planar = (() => {
            // Count unique undirected edges efficiently
            const uniqueEdges = new Set();
            for (const e of this.edges) {
                const key = e.u <= e.v ? `${e.u}|${e.v}` : `${e.v}|${e.u}`;
                uniqueEdges.add(key);
            }
            const m = uniqueEdges.size;
            
            // Trivial cases
            if (n <= 4) return true;
            if (m === 0) return true;
            if (m <= 1) return true; // ⚡ Single edge is always planar
            
            // ⚡ VYLEPŠENÍ 1: Přesnější Eulerova formule pro nesouvislé grafy
            // Pro nesouvislý graf: m ≤ 3n - 6k, kde k = počet komponent
            if (props.prosty) {
                // Počet komponent pomocí BFS
                const visited = new Set();
                let components = 0;
                const adj = {};
                this.nodes.forEach(id => adj[id] = new Set());
                for (const e of this.edges) {
                    adj[e.u].add(e.v);
                    adj[e.v].add(e.u);
                }
                
                for (const start of this.nodes) {
                    if (visited.has(start)) continue;
                    components++;
                    const queue = [start];
                    visited.add(start);
                    while (queue.length) {
                        const u = queue.shift();
                        for (const v of adj[u]) {
                            if (!visited.has(v)) {
                                visited.add(v);
                                queue.push(v);
                            }
                        }
                    }
                }
                
                // Eulerova formule: m ≤ 3n - 6k (pro k komponent)
                if (m > 3 * n - 6 * components) {
                    return false;
                }
            }
            
            // ⚡ VYLEPŠENÍ 2: Zpřesnění pro bipartitní grafy
            if (props.bipartite) {
                // Pro bipartitní graf: m ≤ 2n - 4 (pokud souvislý)
                // Pro nesouvislý: použij podobnou formuli jako výše
                if (props.connected && m > 2 * n - 4) {
                    return false;
                }
            }
            
            // ⚡ VYLEPŠENÍ 3: Kontrola průměrného stupně (zpřesnění)
            const avgDegree = (2 * m) / n;
            if (avgDegree > 6) { // Změna z >= na > (6.0 je ještě možné)
                return false;
            }
            
            // ⚡ VYLEPŠENÍ 4: Kontrola maximálního stupně
            // Rovinný graf nemůže mít uzel se stupněm > 5 u malých grafů
            const maxDegree = Math.max(...Object.values(degrees));
            if (n <= 10 && maxDegree > n - 1) {
                // Pokud má uzel stupeň n-1, je to hvězda → rovinné
                // Jinak pokračuj v kontrolách
            }
            
            // ⚡ VYLEPŠENÍ 5: Speciální případy - stromy a lesy
            if (m === n - 1 && props.connected) {
                return true; // Strom je vždy rovinný!
            }
            if (m < n) {
                return true; // Les (m < n) je vždy rovinný!
            }
            
            // ⚡ VYLEPŠENÍ 6: Optimalizovaná detekce K5 s lepším targeting
            if (n >= 5 && m >= 10) {
                // K5 potřebuje 10 hran mezi 5 uzly
                // Nejprve najdi uzly s vysokým stupněm (≥4)
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 4) { // K5 má všechny uzly se stupněm 4
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                // Zkontroluj jen high-degree uzly (výrazně rychlejší!)
                if (highDegreeNodes.length >= 5) {
                    const maxSamples = Math.min(50, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        // Random sampling z high-degree uzlů
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 5);
                        
                        let isK5 = true;
                        let edgeCount = 0;
                        
                        // Check if these 5 nodes form K5
                        for (let i = 0; i < 5 && isK5; i++) {
                            for (let j = i + 1; j < 5; j++) {
                                const u = candidateNodes[i];
                                const v = candidateNodes[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgeCount++;
                                } else {
                                    isK5 = false;
                                    break;
                                }
                            }
                        }
                        
                        // K5 má přesně 10 hran
                        if (isK5 && edgeCount === 10) return false;
                    }
                }
            }
            
            // ⚡ VYLEPŠENÍ 7: Optimalizovaná detekce K3,3 s bipartitní analýzou
            if (n >= 6 && m >= 9) {
                // K3,3 potřebuje 9 hran a je bipartitní
                // Pokud graf není bipartitní, zkontroluj subgrafy
                
                const highDegreeNodes = [];
                for (const [nodeId, deg] of Object.entries(degrees)) {
                    if (deg >= 3) { // K3,3 má všechny uzly se stupněm přesně 3
                        highDegreeNodes.push(nodeId);
                    }
                }
                
                if (highDegreeNodes.length >= 6) {
                    const maxSamples = Math.min(30, highDegreeNodes.length);
                    
                    for (let attempt = 0; attempt < maxSamples; attempt++) {
                        const shuffle = [...highDegreeNodes].sort(() => Math.random() - 0.5);
                        const candidateNodes = shuffle.slice(0, 6);
                        
                        // ⚡ Optimalizace: Zkus jen logické partitiony
                        // Namísto všech 2^6 = 64 kombinací, zkus jen validní
                        const partitions = [
                            [[0,1,2], [3,4,5]],
                            [[0,1,3], [2,4,5]],
                            [[0,1,4], [2,3,5]],
                            [[0,1,5], [2,3,4]],
                            [[0,2,3], [1,4,5]],
                            [[0,2,4], [1,3,5]],
                            [[0,2,5], [1,3,4]],
                            [[0,3,4], [1,2,5]],
                            [[0,3,5], [1,2,4]],
                            [[0,4,5], [1,2,3]]
                        ];
                        
                        for (const [setAIdx, setBIdx] of partitions) {
                            const setA = setAIdx.map(i => candidateNodes[i]);
                            const setB = setBIdx.map(i => candidateNodes[i]);
                            
                            // Check if complete bipartite
                            let isK33 = true;
                            let edgeCount = 0;
                            
                            // Kontroluj jen hrany mezi množinami (ne uvnitř!)
                            for (const ua of setA) {
                                for (const vb of setB) {
                                    const key = ua <= vb ? `${ua}|${vb}` : `${vb}|${ua}`;
                                    if (uniqueEdges.has(key)) {
                                        edgeCount++;
                                    } else {
                                        isK33 = false;
                                        break;
                                    }
                                }
                                if (!isK33) break;
                            }
                            
                            // K3,3 má přesně 9 hran a žádné hrany uvnitř množin
                            if (isK33 && edgeCount === 9) {
                                // Ověř, že nejsou hrany uvnitř setA a setB
                                let hasInternalEdge = false;
                                for (let i = 0; i < 3; i++) {
                                    for (let j = i + 1; j < 3; j++) {
                                        const keyA = setA[i] <= setA[j] ? `${setA[i]}|${setA[j]}` : `${setA[j]}|${setA[i]}`;
                                        const keyB = setB[i] <= setB[j] ? `${setB[i]}|${setB[j]}` : `${setB[j]}|${setB[i]}`;
                                        if (uniqueEdges.has(keyA) || uniqueEdges.has(keyB)) {
                                            hasInternalEdge = true;
                                            break;
                                        }
                                    }
                                    if (hasInternalEdge) break;
                                }
                                
                                if (!hasInternalEdge) return false; // K3,3 found!
                            }
                        }
                    }
                }
            }
            
            // ⚡ VYLEPŠENÍ 8: Kontrola hustoty subgrafů
            // Rovinný graf nemůže obsahovat "lokálně hustý" subgraf
            if (n >= 10 && m >= 20) {
                // Vyber náhodné uzly a kontroluj jejich okolí
                const samples = Math.min(10, n);
                for (let s = 0; s < samples; s++) {
                    const centerIdx = Math.floor(Math.random() * n);
                    const center = this.nodes[centerIdx];
                    
                    // Najdi sousedy centra
                    const neighbors = new Set();
                    for (const e of this.edges) {
                        if (e.u === center) neighbors.add(e.v);
                        if (e.v === center) neighbors.add(e.u);
                    }
                    
                    if (neighbors.size >= 6) {
                        // Spočítej hrany mezi sousedy
                        const neighborsList = Array.from(neighbors);
                        let edgesInNeighborhood = 0;
                        for (let i = 0; i < neighborsList.length; i++) {
                            for (let j = i + 1; j < neighborsList.length; j++) {
                                const u = neighborsList[i];
                                const v = neighborsList[j];
                                const key = u <= v ? `${u}|${v}` : `${v}|${u}`;
                                if (uniqueEdges.has(key)) {
                                    edgesInNeighborhood++;
                                }
                            }
                        }
                        
                        // Pokud má okolí příliš mnoho hran, není rovinný
                        const k = neighbors.size;
                        const maxEdgesInNeighborhood = 3 * k - 6;
                        if (edgesInNeighborhood > maxEdgesInNeighborhood) {
                            return false;
                        }
                    }
                }
            }
            
            // ⚡ VYLEPŠENÍ 9: Zpřesnění odpovědi podle jistoty
            if (n > 100) {
                // Pro velmi velké grafy použij disclaimer
                return 'pravděpodobně ano (heuristika)';
            } else if (n > 50 && (m > 2.5 * n)) {
                // Pro středně velké hustší grafy buď opatrnější
                return 'pravděpodobně ano (heuristika)';
            } else if (m <= n + 3) {
                // Řídké grafy (m ≤ n+3) jsou téměř jistě rovinné
                return true;
            }
            
            return true;
        })();
        
        return props;
    }
}


function createMatrixTable(matrix, rowLabels, colLabels) {
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    
    const headRow = document.createElement('tr');
    headRow.appendChild(document.createElement('th'));
    for (const label of colLabels) {
        const th = document.createElement('th');
        th.textContent = label;
        headRow.appendChild(th);
    }
    thead.appendChild(headRow);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (let i = 0; i < matrix.length; i++) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = rowLabels[i];
        tr.appendChild(th);
        for (let j = 0; j < matrix[i].length; j++) {
            const td = document.createElement('td');
            const val = matrix[i][j];
            td.textContent = (val === Infinity ? '∞' : val);
            tr.appendChild(td);
        }
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
}

function countBinaryMatrix(matrix) {
    const n = matrix.length;
    const m = matrix[0] ? matrix[0].length : 0;
    
    const colStats = [];
    for (let j = 0; j < m; j++) {
        colStats.push({ zeros: 0, ones: 0 });
    }
    
    let totalZeros = 0;
    let totalOnes = 0;
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            const val = matrix[i][j];
            if (val === 0) {
                colStats[j].zeros++;
                totalZeros++;
            } else if (val === 1) {
                colStats[j].ones++;
                totalOnes++;
            }
        }
    }
    
    return { colStats, totalZeros, totalOnes };
}

function countMatrixValues(matrix) {
    const counts = {};
    let total = 0;
    
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            const val = matrix[i][j];
            if (val === Infinity) continue;
            
            counts[val] = (counts[val] || 0) + 1;
            total++;
        }
    }
    
    return { counts, total };
}

function createListTable(map) {
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');
    for (const key of Object.keys(map)) {
        const tr = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = key;
        tr.appendChild(th);
        const td = document.createElement('td');
        td.textContent = map[key].join(', ');
        tr.appendChild(td);
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
}

let currentGraph = null;

document.getElementById('parseBtn').addEventListener('click', () => {
    const input = document.getElementById('graphInput').value;
    const graph = new Graph();
    graph.parse(input);
    currentGraph = graph;
    
    const output = document.getElementById('output');
    output.innerHTML = '';
    
    if (graph.nodes.length === 0) {
        output.textContent = 'Nebyl rozpoznán žádný uzel. Zkontrolujte prosím vstup.';
        document.getElementById('counters').style.display = 'none';
        return;
    }

    // Update counters
    document.getElementById('nodeCount').textContent = graph.nodes.length;
    document.getElementById('edgeCount').textContent = graph.edges.length;
    document.getElementById('counters').style.display = 'block';

    // Query sections for each matrix type
    const createQuerySection = (title, matrixType) => {
    const section = document.createElement('div');
    section.className = 'query-section';
    section.innerHTML = `<h3>${title}</h3>`;
    
    const inputDiv = document.createElement('div');
    inputDiv.className = 'query-inputs';
    
    const selectU = document.createElement('select');
    const selectV = document.createElement('select');
    graph.nodes.forEach(node => {
        const opt1 = document.createElement('option');
        opt1.value = node;
        opt1.textContent = node;
        selectU.appendChild(opt1);
        
        const opt2 = document.createElement('option');
        opt2.value = node;
        opt2.textContent = node;
        selectV.appendChild(opt2);
    });
    
    const queryBtn = document.createElement('button');
    queryBtn.textContent = 'Dotaz';
    
    const resultDiv = document.createElement('div');
    resultDiv.className = 'query-result';
    resultDiv.style.display = 'none';
    
    queryBtn.addEventListener('click', () => {
        const u = selectU.value;
        const v = selectV.value;
        let result;
        
        switch(matrixType) {
            case 'adjacency':
                result = graph.adjacencyValue(u, v);
                resultDiv.textContent = `A[${u}, ${v}] = ${result}`;
                break;
            case 'sign':
                result = graph.signValue(u, v);
                resultDiv.textContent = `S[${u}, ${v}] = ${result}`;
                break;
            case 'length':
                result = graph.lengthValue(u, v);
                resultDiv.textContent = `L[${u}, ${v}] = ${result === Infinity ? '∞' : result}`;
                break;
            case 'power2':
                result = graph.adjacencyPowerValue(u, v, 2);
                resultDiv.textContent = `A²[${u}, ${v}] = ${result}`;
                break;
            case 'power3':
                result = graph.adjacencyPowerValue(u, v, 3);
                resultDiv.textContent = `A³[${u}, ${v}] = ${result}`;
                break;
            case 'laplacian':
                result = graph.laplacianValue(u, v);
                resultDiv.innerHTML = `Laplaciánská matice <strong>L[${u}, ${v}] = ${result}</strong><br>
                    <small>L = D - A (D = matice stupňů, A = matice sousednosti)</small>`;
                break;
            case 'multiplicity':
                result = graph.multiplicityValue(u, v);
                resultDiv.innerHTML = `Multiplicita hran mezi <strong>${u}</strong> a <strong>${v}</strong>: <strong>${result}</strong><br>
                    <small>Počet všech hran (včetně paralelních) spojujících tyto uzly</small>`;
                break;
            case 'shortest':
                result = graph.shortestPath(u, v);
                if (result.distance === Infinity) {
                    resultDiv.textContent = `Nejkratší cesta z ${u} do ${v}: neexistuje`;
                } else {
                    const pathStr = result.path.join(' → ');
                    resultDiv.innerHTML = `Nejkratší cesta z <strong>${u}</strong> do <strong>${v}</strong>:<br>
                        Délka: <strong>${result.distance}</strong><br>
                        Sled: <strong>${pathStr}</strong>`;
                }
                break;
        }
        resultDiv.style.display = 'block';
    });
    
    // ✅ OPRAVA: Správné vytváření labelu a přidání elementů
    const labelU = document.createElement('span');
    labelU.textContent = 'Od uzlu: ';
    inputDiv.appendChild(labelU);
    inputDiv.appendChild(selectU);
    
    const labelV = document.createElement('span');
    labelV.textContent = ' Do uzlu: ';
    inputDiv.appendChild(labelV);
    inputDiv.appendChild(selectV);
    
    inputDiv.appendChild(queryBtn);
    
    section.appendChild(inputDiv);
    section.appendChild(resultDiv);
    return section;
};

    // Node and edge list with degrees (scrollable)
    const listSection = document.createElement('div');
    listSection.className = 'section';
    listSection.innerHTML = '<h2>Seznam uzlů a hran</h2>';
    
    const degrees = graph.degrees();
    const nodeListDiv = document.createElement('div');
    nodeListDiv.className = 'scrollable-list';
    const nodeList = document.createElement('ul');
    nodeList.style.listStyle = 'none';
    nodeList.style.padding = '0';
    graph.nodes.forEach(id => {
        const li = document.createElement('li');
        const w = graph.nodeWeights[id];
        const deg = degrees[id];
        li.innerHTML = `<strong>Uzel ${id}</strong>${w !== null && w !== undefined ? ` (hodnota: ${w})` : ''}<span class="degree-info">stupeň: ${deg}</span>`;
        nodeList.appendChild(li);
    });
    nodeListDiv.appendChild(nodeList);
    listSection.appendChild(nodeListDiv);
    
    const edgeListDiv = document.createElement('div');
    edgeListDiv.className = 'scrollable-list';
    const edgeList = document.createElement('ul');
    edgeList.style.listStyle = 'none';
    edgeList.style.padding = '0';
    graph.edges.forEach(e => {
        const li = document.createElement('li');
        const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
        const label = e.label ? ` [${e.label}]` : '';
        let orientation;
        if (e.direction === '>') orientation = '→';
        else if (e.direction === '<') orientation = '←';
        else orientation = '—';
        li.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
        edgeList.appendChild(li);
    });
    edgeListDiv.appendChild(edgeList);
    listSection.appendChild(edgeListDiv);
    output.appendChild(listSection);

    // Adjacency matrix with query and binary/count toggle
    const adjSection = document.createElement('div');
    adjSection.className = 'section';
    adjSection.innerHTML = '<h2>Matice sousednosti</h2>';
    
    const adjLegendDiv = document.createElement('div');
    adjLegendDiv.style.backgroundColor = '#e7f3ff';
    adjLegendDiv.style.padding = '0.75rem';
    adjLegendDiv.style.borderRadius = '0.25rem';
    adjLegendDiv.style.marginBottom = '1rem';
    adjLegendDiv.style.border = '1px solid #0d6efd';
    adjLegendDiv.innerHTML = `
        <strong>📊 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• <strong>Počtová verze:</strong> v buňce (i,j) je počet hran z uzlu i do j (zobrazuje multiplicitu)</span><br>
        <span style="margin-left: 1rem;">• <strong>Binární verze:</strong> hodnota 1 existuje-li alespoň jedna hrana i→j, jinak 0</span><br>
        <span style="margin-left: 1rem;">• U neorientovaných hran se zapisuje do obou směrů</span>
    `;
    adjSection.appendChild(adjLegendDiv);
    
    const adjToggleDiv = document.createElement('div');
    adjToggleDiv.style.marginBottom = '1rem';
    adjToggleDiv.innerHTML = '<label><input type="checkbox" id="adjBinary" /> Binární verze (0/1)</label>';
    adjSection.appendChild(adjToggleDiv);
    
    adjSection.appendChild(createQuerySection('Dotaz na hodnotu', 'adjacency'));
    
    const showAdjBtn = document.createElement('button');
    showAdjBtn.textContent = 'Zobrazit celou matici';
    const adjMatrixDiv = document.createElement('div');
    adjMatrixDiv.className = 'matrix';
    adjMatrixDiv.style.display = 'none';
    const adjStatsDiv = document.createElement('div');
    adjStatsDiv.style.display = 'none';
    adjStatsDiv.style.marginTop = '1rem';
    adjStatsDiv.style.padding = '1rem';
    adjStatsDiv.style.backgroundColor = '#e7f3ff';
    adjStatsDiv.style.borderRadius = '0.25rem';
    
    showAdjBtn.addEventListener('click', () => {
        if (adjMatrixDiv.style.display === 'none') {
            const binary = document.getElementById('adjBinary').checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            // Count 0s and 1s in adjacency matrix
            const { colStats, totalZeros, totalOnes } = countBinaryMatrix(adjMat);
            adjStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Celková statistika hodnot 0 a 1:</h4>';
            adjStatsDiv.innerHTML += `<div style="display: flex; gap: 2rem; margin-top: 0.5rem;">`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #0b5ed7; font-weight: bold;">Počet 1:</span> ${totalOnes}×</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #dc3545; font-weight: bold;">Počet 0:</span> ${totalZeros}×</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="font-weight: bold;">Celkem:</span> ${totalOnes + totalZeros}</div>`;
            adjStatsDiv.innerHTML += `</div>`;
            
            adjMatrixDiv.style.display = 'block';
            adjStatsDiv.style.display = 'block';
            showAdjBtn.textContent = 'Skrýt matici';
        } else {
            adjMatrixDiv.style.display = 'none';
            adjStatsDiv.style.display = 'none';
            showAdjBtn.textContent = 'Zobrazit celou matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'adjBinary' && adjMatrixDiv.style.display === 'block') {
            const binary = e.target.checked;
            const adjMat = graph.adjacencyMatrix(binary);
            adjMatrixDiv.innerHTML = '';
            adjMatrixDiv.appendChild(createMatrixTable(adjMat, graph.nodes, graph.nodes));
            
            const { colStats, totalZeros, totalOnes } = countBinaryMatrix(adjMat);
            adjStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Celková statistika hodnot 0 a 1:</h4>';
            adjStatsDiv.innerHTML += `<div style="display: flex; gap: 2rem; margin-top: 0.5rem;">`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #0b5ed7; font-weight: bold;">Počet 1:</span> ${totalOnes}×</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="color: #dc3545; font-weight: bold;">Počet 0:</span> ${totalZeros}×</div>`;
            adjStatsDiv.innerHTML += `<div style="font-size: 1.1rem;"><span style="font-weight: bold;">Celkem:</span> ${totalOnes + totalZeros}</div>`;
            adjStatsDiv.innerHTML += `</div>`;
        }
    });
    
    adjSection.appendChild(showAdjBtn);
    adjSection.appendChild(adjMatrixDiv);
    adjSection.appendChild(adjStatsDiv);
    output.appendChild(adjSection);

    // Sign matrix with query
    const signSection = document.createElement('div');
    signSection.className = 'section';
    signSection.innerHTML = '<h2>Znaménková matice</h2>';
    signSection.appendChild(createQuerySection('Dotaz na hodnotu', 'sign'));
    
    const showSignBtn = document.createElement('button');
    showSignBtn.textContent = 'Zobrazit celou matici';
    const signMatrixDiv = document.createElement('div');
    signMatrixDiv.className = 'matrix';
    signMatrixDiv.style.display = 'none';
    const signStatsDiv = document.createElement('div');
    signStatsDiv.style.display = 'none';
    signStatsDiv.style.marginTop = '1rem';
    signStatsDiv.style.padding = '1rem';
    signStatsDiv.style.backgroundColor = '#e7f3ff';
    signStatsDiv.style.borderRadius = '0.25rem';
    
    showSignBtn.addEventListener('click', () => {
        if (signMatrixDiv.style.display === 'none') {
            const signMat = graph.signMatrix();
            signMatrixDiv.innerHTML = '';
            signMatrixDiv.appendChild(createMatrixTable(signMat, graph.nodes, graph.nodes));
            
            // Count values in sign matrix
            const { counts, total } = countMatrixValues(signMat);
            signStatsDiv.innerHTML = '<h4 style="margin-top: 0;">Statistika hodnot:</h4>';
            
            // Sort keys numerically
            const sortedKeys = Object.keys(counts).map(Number).sort((a, b) => a - b);
            const statsHTML = sortedKeys.map(key => {
                const count = counts[key];
                const percentage = ((count / total) * 100).toFixed(1);
                return `<div style="display: inline-block; margin-right: 1.5rem; margin-bottom: 0.5rem;">
                    <strong>Hodnota ${key}:</strong> ${count}× (${percentage}%)
                </div>`;
            }).join('');
            
            signStatsDiv.innerHTML += statsHTML;
            signStatsDiv.innerHTML += `<div style="margin-top: 0.5rem; font-weight: bold;">Celkem hodnot: ${total}</div>`;
            
            signMatrixDiv.style.display = 'block';
            signStatsDiv.style.display = 'block';
            showSignBtn.textContent = 'Skrýt matici';
        } else {
            signMatrixDiv.style.display = 'none';
            signStatsDiv.style.display = 'none';
            showSignBtn.textContent = 'Zobrazit celou matici';
        }
    });
    signSection.appendChild(showSignBtn);
    signSection.appendChild(signMatrixDiv);
    signSection.appendChild(signStatsDiv);
    output.appendChild(signSection);

    // Laplacian matrix with query
    const laplacianSection = document.createElement('div');
    laplacianSection.className = 'section';
    laplacianSection.innerHTML = '<h2>Laplaciánská matice (L = D - A)</h2>';
    laplacianSection.appendChild(createQuerySection('Dotaz na hodnotu L[U,V]', 'laplacian'));
    
    const showLaplacianBtn = document.createElement('button');
    showLaplacianBtn.textContent = 'Zobrazit celou matici';
    const laplacianMatrixDiv = document.createElement('div');
    laplacianMatrixDiv.className = 'matrix';
    laplacianMatrixDiv.style.display = 'none';
    
    showLaplacianBtn.addEventListener('click', () => {
        if (laplacianMatrixDiv.style.display === 'none') {
            const laplacianMat = graph.laplacianMatrix();
            laplacianMatrixDiv.innerHTML = '';
            laplacianMatrixDiv.appendChild(createMatrixTable(laplacianMat, graph.nodes, graph.nodes));
            laplacianMatrixDiv.style.display = 'block';
            showLaplacianBtn.textContent = 'Skrýt matici';
        } else {
            laplacianMatrixDiv.style.display = 'none';
            showLaplacianBtn.textContent = 'Zobrazit celou matici';
        }
    });
    laplacianSection.appendChild(showLaplacianBtn);
    laplacianSection.appendChild(laplacianMatrixDiv);
    output.appendChild(laplacianSection);

    // Multiplicity query section
    const multiplicitySection = document.createElement('div');
    multiplicitySection.className = 'section';
    multiplicitySection.innerHTML = '<h2>Multiplicita hran (počet paralelních hran)</h2>';
    multiplicitySection.appendChild(createQuerySection('Dotaz na multiplicitu', 'multiplicity'));
    output.appendChild(multiplicitySection);

    // Power matrices with queries
    const powerSection = document.createElement('div');
    powerSection.className = 'section';
    powerSection.innerHTML = '<h2>Druhá a třetí mocnina matice sousednosti</h2>';
    powerSection.appendChild(createQuerySection('Dotaz na A²', 'power2'));
    powerSection.appendChild(createQuerySection('Dotaz na A³', 'power3'));
    
    // Custom power query section
    const customPowerDiv = document.createElement('div');
    customPowerDiv.className = 'query-section';
    customPowerDiv.innerHTML = '<h3>Libovolná mocnina matice sousednosti</h3>';
    
    // Add legend
    const powerLegendDiv = document.createElement('div');
    powerLegendDiv.style.backgroundColor = '#fff3cd';
    powerLegendDiv.style.padding = '0.75rem';
    powerLegendDiv.style.borderRadius = '0.25rem';
    powerLegendDiv.style.marginBottom = '1rem';
    powerLegendDiv.style.border = '1px solid #ffc107';
    powerLegendDiv.innerHTML = `
        <strong>📖 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• <strong>A<sup>k</sup>[u, v]</strong> udává počet cest <strong>délky k</strong> z uzlu <strong>u</strong> do uzlu <strong>v</strong></span><br>
        <span style="margin-left: 1rem;">• Například A<sup>3</sup>[A, C] = 5 znamená, že existuje <strong>5 různých cest délky 3</strong> z uzlu A do uzlu C</span><br>
        <span style="margin-left: 1rem;">• Délka cesty = počet hran v cestě (ne počet uzlů!)</span>
    `;
    customPowerDiv.appendChild(powerLegendDiv);
    
    const customPowerInputDiv = document.createElement('div');
    customPowerInputDiv.className = 'query-inputs';
    
    const selectPowerU = document.createElement('select');
    const selectPowerV = document.createElement('select');
    graph.nodes.forEach(node => {
        const opt1 = document.createElement('option');
        opt1.value = node;
        opt1.textContent = node;
        selectPowerU.appendChild(opt1);
        
        const opt2 = document.createElement('option');
        opt2.value = node;
        opt2.textContent = node;
        selectPowerV.appendChild(opt2);
    });
    
    const powerInput = document.createElement('input');
    powerInput.type = 'number';
    powerInput.min = '1';
    powerInput.max = '20';
    powerInput.value = '4';
    powerInput.style.width = '80px';
    powerInput.style.padding = '0.5rem';
    powerInput.style.border = '1px solid #ced4da';
    powerInput.style.borderRadius = '0.25rem';
    
    const customPowerBtn = document.createElement('button');
    customPowerBtn.textContent = 'Vypočítat';
    
    const customPowerResultDiv = document.createElement('div');
    customPowerResultDiv.className = 'query-result';
    customPowerResultDiv.style.display = 'none';
    
    customPowerBtn.addEventListener('click', () => {
        const u = selectPowerU.value;
        const v = selectPowerV.value;
        const k = parseInt(powerInput.value);
        
        if (k < 1 || k > 20) {
            customPowerResultDiv.textContent = 'Mocnina musí být mezi 1 a 20';
            customPowerResultDiv.style.display = 'block';
            return;
        }
        
        customPowerBtn.disabled = true;
        customPowerBtn.textContent = 'Počítám...';
        
        setTimeout(() => {
            const result = graph.adjacencyPowerValue(u, v, k);
            customPowerResultDiv.textContent = `A^${k}[${u}, ${v}] = ${result}`;
            customPowerResultDiv.style.display = 'block';
            customPowerBtn.disabled = false;
            customPowerBtn.textContent = 'Vypočítat';
        }, 50);
    });
    
    const labelPowerU = document.createElement('span');
    labelPowerU.textContent = 'Od uzlu: ';
    customPowerInputDiv.appendChild(labelPowerU);
    customPowerInputDiv.appendChild(selectPowerU);
    
    const labelPowerV = document.createElement('span');
    labelPowerV.textContent = ' Do uzlu: ';
    customPowerInputDiv.appendChild(labelPowerV);
    customPowerInputDiv.appendChild(selectPowerV);
    
    const labelPower = document.createElement('span');
    labelPower.textContent = ' Mocnina: ';
    customPowerInputDiv.appendChild(labelPower);
    customPowerInputDiv.appendChild(powerInput);
    customPowerInputDiv.appendChild(customPowerBtn);
    
    customPowerDiv.appendChild(customPowerInputDiv);
    customPowerDiv.appendChild(customPowerResultDiv);
    powerSection.appendChild(customPowerDiv);
    
    const showPowerBtn = document.createElement('button');
    showPowerBtn.textContent = 'Zobrazit celé matice';
    const powerMatrixDiv = document.createElement('div');
    powerMatrixDiv.style.display = 'none';
    showPowerBtn.addEventListener('click', () => {
        if (powerMatrixDiv.style.display === 'none') {
            const A2 = graph.adjacencyPower(2);
            const A3 = graph.adjacencyPower(3);
            powerMatrixDiv.innerHTML = '<h3>A²</h3>';
            const div2 = document.createElement('div');
            div2.className = 'matrix';
            div2.appendChild(createMatrixTable(A2, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div2);
            powerMatrixDiv.innerHTML += '<h3>A³</h3>';
            const div3 = document.createElement('div');
            div3.className = 'matrix';
            div3.appendChild(createMatrixTable(A3, graph.nodes, graph.nodes));
            powerMatrixDiv.appendChild(div3);
            powerMatrixDiv.style.display = 'block';
            showPowerBtn.textContent = 'Skrýt matice';
        } else {
            powerMatrixDiv.style.display = 'none';
            showPowerBtn.textContent = 'Zobrazit celé matice';
        }
    });
    powerSection.appendChild(showPowerBtn);
    powerSection.appendChild(powerMatrixDiv);
    output.appendChild(powerSection);

    // Sum of walks query section
    const sumWalksSection = document.createElement('div');
    sumWalksSection.className = 'section';
    sumWalksSection.innerHTML = '<h2>Suma všech procházek (∑ A¹ + A² + ... + Aᵏ)</h2>';
    
    const sumWalksDiv = document.createElement('div');
    sumWalksDiv.className = 'query-section';
    sumWalksDiv.innerHTML = '<h3>Dotaz na celkový počet procházek délek 1 až k</h3>';
    
    // Add legend
    const sumWalksLegendDiv = document.createElement('div');
    sumWalksLegendDiv.style.backgroundColor = '#e7f3ff';
    sumWalksLegendDiv.style.padding = '0.75rem';
    sumWalksLegendDiv.style.borderRadius = '0.25rem';
    sumWalksLegendDiv.style.marginBottom = '1rem';
    sumWalksLegendDiv.style.border = '1px solid #0d6efd';
    sumWalksLegendDiv.innerHTML = `
        <strong>📊 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• Sečte počet všech procházek délek 1, 2, 3, ..., až k mezi uzly U a V</span><br>
        <span style="margin-left: 1rem;">• Např. pro k=3: počítá cesty délky 1 + cesty délky 2 + cesty délky 3</span><br>
        <span style="margin-left: 1rem;">• Užitečné pro analýzu celkové propojitelnosti uzlů</span>
    `;
    sumWalksDiv.appendChild(sumWalksLegendDiv);
    
    const sumWalksInputDiv = document.createElement('div');
    sumWalksInputDiv.className = 'query-inputs';
    
    const selectSumU = document.createElement('select');
    const selectSumV = document.createElement('select');
    graph.nodes.forEach(node => {
        const opt1 = document.createElement('option');
        opt1.value = node;
        opt1.textContent = node;
        selectSumU.appendChild(opt1);
        
        const opt2 = document.createElement('option');
        opt2.value = node;
        opt2.textContent = node;
        selectSumV.appendChild(opt2);
    });
    
    const sumKInput = document.createElement('input');
    sumKInput.type = 'number';
    sumKInput.min = '1';
    sumKInput.max = '10';
    sumKInput.value = '3';
    sumKInput.style.width = '80px';
    sumKInput.style.padding = '0.5rem';
    sumKInput.style.border = '1px solid #ced4da';
    sumKInput.style.borderRadius = '0.25rem';
    
    const sumWalksBtn = document.createElement('button');
    sumWalksBtn.textContent = 'Vypočítat';
    
    const sumWalksResultDiv = document.createElement('div');
    sumWalksResultDiv.className = 'query-result';
    sumWalksResultDiv.style.display = 'none';
    
    sumWalksBtn.addEventListener('click', () => {
        const u = selectSumU.value;
        const v = selectSumV.value;
        const k = parseInt(sumKInput.value);
        
        if (k < 1 || k > 10) {
            sumWalksResultDiv.textContent = 'Hodnota k musí být mezi 1 a 10';
            sumWalksResultDiv.style.display = 'block';
            return;
        }
        
        sumWalksBtn.disabled = true;
        sumWalksBtn.textContent = 'Počítám...';
        
        setTimeout(() => {
            const result = graph.sumWalksValue(u, v, k);
            sumWalksResultDiv.innerHTML = `∑ procházek (délky 1..${k}) z <strong>${u}</strong> do <strong>${v}</strong>: <strong>${result}</strong><br>
                <small>Celkový počet všech cest délek 1 až ${k}</small>`;
            sumWalksResultDiv.style.display = 'block';
            sumWalksBtn.disabled = false;
            sumWalksBtn.textContent = 'Vypočítat';
        }, 50);
    });
    
    const labelSumU = document.createElement('span');
    labelSumU.textContent = 'Od uzlu: ';
    sumWalksInputDiv.appendChild(labelSumU);
    sumWalksInputDiv.appendChild(selectSumU);
    
    const labelSumV = document.createElement('span');
    labelSumV.textContent = ' Do uzlu: ';
    sumWalksInputDiv.appendChild(labelSumV);
    sumWalksInputDiv.appendChild(selectSumV);
    
    const labelSumK = document.createElement('span');
    labelSumK.textContent = ' Max. délka k: ';
    sumWalksInputDiv.appendChild(labelSumK);
    sumWalksInputDiv.appendChild(sumKInput);
    sumWalksInputDiv.appendChild(sumWalksBtn);
    
    sumWalksDiv.appendChild(sumWalksInputDiv);
    sumWalksDiv.appendChild(sumWalksResultDiv);
    sumWalksSection.appendChild(sumWalksDiv);
    output.appendChild(sumWalksSection);

    // Incidence matrix with signed/unsigned toggle
    const incSection = document.createElement('div');
    incSection.className = 'section';
    incSection.innerHTML = '<h2>Matice incidence</h2>';
    
    const incLegendDiv = document.createElement('div');
    incLegendDiv.style.backgroundColor = '#e7f3ff';
    incLegendDiv.style.padding = '0.75rem';
    incLegendDiv.style.borderRadius = '0.25rem';
    incLegendDiv.style.marginBottom = '1rem';
    incLegendDiv.style.border = '1px solid #0d6efd';
    incLegendDiv.innerHTML = `
        <strong>📖 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• <strong>Podepsaná</strong> varianta: u orientované hrany dává -1 do ocasu a +1 do hlavy; u neorientované 1/1</span><br>
        <span style="margin-left: 1rem;">• <strong>Nepodepsaná</strong> varianta: má v příslušných uzlech u hrany hodnotu 1 (nezávisle na směru)</span><br>
        <span style="margin-left: 1rem;">• Popisuje vztah uzel–hrana (které hrany jsou incidentní s kterými uzly)</span>
    `;
    incSection.appendChild(incLegendDiv);
    
    const incToggleDiv = document.createElement('div');
    incToggleDiv.style.marginBottom = '1rem';
    incToggleDiv.innerHTML = '<label><input type="checkbox" id="incSigned" checked /> Podepsaná (signed)</label>';
    incSection.appendChild(incToggleDiv);
    
    const showIncBtn = document.createElement('button');
    showIncBtn.textContent = 'Zobrazit matici';
    const incMatrixDiv = document.createElement('div');
    incMatrixDiv.className = 'matrix';
    incMatrixDiv.style.display = 'none';
    
    showIncBtn.addEventListener('click', () => {
        if (incMatrixDiv.style.display === 'none') {
            const signed = document.getElementById('incSigned').checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
            incMatrixDiv.style.display = 'block';
            showIncBtn.textContent = 'Skrýt matici';
        } else {
            incMatrixDiv.style.display = 'none';
            showIncBtn.textContent = 'Zobrazit matici';
        }
    });
    
    // Re-render on checkbox change
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'incSigned' && incMatrixDiv.style.display === 'block') {
            const signed = e.target.checked;
            const incMat = graph.incidenceMatrix(signed);
            const colLabels = graph.edges.map(e => e.label ? e.label : `${e.u}${e.direction}${e.v}`);
            incMatrixDiv.innerHTML = '';
            incMatrixDiv.appendChild(createMatrixTable(incMat, graph.nodes, colLabels));
        }
    });
    
    incSection.appendChild(showIncBtn);
    incSection.appendChild(incMatrixDiv);
    output.appendChild(incSection);

    // Reachability matrix (transitive closure)
    const reachSection = document.createElement('div');
    reachSection.className = 'section';
    reachSection.innerHTML = '<h2>Dosažitelnost (transitivní uzávěr)</h2>';
    
    const reachLegendDiv = document.createElement('div');
    reachLegendDiv.style.backgroundColor = '#e7f3ff';
    reachLegendDiv.style.padding = '0.75rem';
    reachLegendDiv.style.borderRadius = '0.25rem';
    reachLegendDiv.style.marginBottom = '1rem';
    reachLegendDiv.style.border = '1px solid #0d6efd';
    reachLegendDiv.innerHTML = `
        <strong>🔄 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• Uzávěr dosažitelnosti na binární matici sousednosti</span><br>
        <span style="margin-left: 1rem;">• Hodnota 1 znamená, že existuje cesta z uzlu i do uzlu j libovolné délky</span><br>
        <span style="margin-left: 1rem;">• Hodnota 0 znamená, že uzel j není dosažitelný z uzlu i</span><br>
        <span style="margin-left: 1rem;">• Vypočteno pomocí Floyd-Warshall algoritmu na binární matici</span>
    `;
    reachSection.appendChild(reachLegendDiv);
    
    const showReachBtn = document.createElement('button');
    showReachBtn.textContent = 'Zobrazit matici dosažitelnosti';
    const reachMatrixDiv = document.createElement('div');
    reachMatrixDiv.className = 'matrix';
    reachMatrixDiv.style.display = 'none';
    
    showReachBtn.addEventListener('click', () => {
        if (reachMatrixDiv.style.display === 'none') {
            const reachMat = graph.reachability();
            reachMatrixDiv.innerHTML = '';
            reachMatrixDiv.appendChild(createMatrixTable(reachMat, graph.nodes, graph.nodes));
            reachMatrixDiv.style.display = 'block';
            showReachBtn.textContent = 'Skrýt matici';
        } else {
            reachMatrixDiv.style.display = 'none';
            showReachBtn.textContent = 'Zobrazit matici dosažitelnosti';
        }
    });
    
    reachSection.appendChild(showReachBtn);
    reachSection.appendChild(reachMatrixDiv);
    output.appendChild(reachSection);

    // BFS Layers
    const bfsSection = document.createElement('div');
    bfsSection.className = 'section';
    bfsSection.innerHTML = '<h2>BFS Vrstvy (Breadth-First Search Layers)</h2>';
    
    const bfsLegendDiv = document.createElement('div');
    bfsLegendDiv.style.backgroundColor = '#e7f3ff';
    bfsLegendDiv.style.padding = '0.75rem';
    bfsLegendDiv.style.borderRadius = '0.25rem';
    bfsLegendDiv.style.marginBottom = '1rem';
    bfsLegendDiv.style.border = '1px solid #0d6efd';
    bfsLegendDiv.innerHTML = `
        <strong>🌊 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• Uzly rozložené do vrstev podle vzdálenosti od startovního uzlu</span><br>
        <span style="margin-left: 1rem;">• Vrstva 0: startovní uzel</span><br>
        <span style="margin-left: 1rem;">• Vrstva k: uzly dostupné v k krocích ze startu</span><br>
        <span style="margin-left: 1rem;">• Užitečné pro vizualizaci šíření informace v grafu</span>
    `;
    bfsSection.appendChild(bfsLegendDiv);
    
    const bfsControlDiv = document.createElement('div');
    bfsControlDiv.style.marginBottom = '1rem';
    bfsControlDiv.innerHTML = '<label>Startovní uzel: <select id="bfsStart"></select></label> <button id="bfsBtn" class="btn" style="margin-left: 0.5rem;">Spočítat vrstvy</button>';
    bfsSection.appendChild(bfsControlDiv);
    
    const bfsStartSelect = document.createElement('select');
    bfsStartSelect.id = 'bfsStartSelect';
    graph.nodes.forEach(node => {
        const opt = document.createElement('option');
        opt.value = node;
        opt.textContent = node;
        bfsStartSelect.appendChild(opt);
    });
    bfsControlDiv.querySelector('label').appendChild(bfsStartSelect);
    
    const bfsResultDiv = document.createElement('div');
    bfsResultDiv.className = 'scroll';
    bfsResultDiv.style.display = 'none';
    bfsSection.appendChild(bfsResultDiv);
    
    bfsControlDiv.querySelector('#bfsBtn').addEventListener('click', () => {
        const start = bfsStartSelect.value;
        const layers = graph.bfsLayers(start);
        let html = '<h4>Vrstvy uzlů:</h4>';
        for (const [k, nodes] of Object.entries(layers)) {
            html += `<div style="margin: 0.5rem 0;"><strong>Vrstva ${k}:</strong> ${nodes.join(', ')}</div>`;
        }
        bfsResultDiv.innerHTML = html;
        bfsResultDiv.style.display = 'block';
    });
    
    output.appendChild(bfsSection);

    // All shortest paths (unweighted)
    const allPathsSection = document.createElement('div');
    allPathsSection.className = 'section';
    allPathsSection.innerHTML = '<h2>Všechny nejkratší cesty (neohodnocené)</h2>';
    
    const allPathsLegendDiv = document.createElement('div');
    allPathsLegendDiv.style.backgroundColor = '#e7f3ff';
    allPathsLegendDiv.style.padding = '0.75rem';
    allPathsLegendDiv.style.borderRadius = '0.25rem';
    allPathsLegendDiv.style.marginBottom = '1rem';
    allPathsLegendDiv.style.border = '1px solid #0d6efd';
    allPathsLegendDiv.innerHTML = `
        <strong>🛤️ Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• Najde VŠECHNY stejně krátké cesty mezi U a V při délce hrany = 1</span><br>
        <span style="margin-left: 1rem;">• Používá BFS (Breadth-First Search) pro neohodnocený graf</span><br>
        <span style="margin-left: 1rem;">• Zobrazí maximálně prvních 200 cest</span><br>
        <span style="margin-left: 1rem;">• Při velkých grafech může být výsledků hodně</span>
    `;
    allPathsSection.appendChild(allPathsLegendDiv);
    
    const allPathsControlDiv = document.createElement('div');
    allPathsControlDiv.className = 'query-inputs';
    
    const selectAllU = document.createElement('select');
    const selectAllV = document.createElement('select');
    graph.nodes.forEach(node => {
        const opt1 = document.createElement('option');
        opt1.value = node;
        opt1.textContent = node;
        selectAllU.appendChild(opt1);
        
        const opt2 = document.createElement('option');
        opt2.value = node;
        opt2.textContent = node;
        selectAllV.appendChild(opt2);
    });
    
    const allPathsBtn = document.createElement('button');
    allPathsBtn.textContent = 'Najít všechny cesty';
    
    allPathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    allPathsControlDiv.appendChild(selectAllU);
    const labelAllV = document.createElement('span');
    labelAllV.textContent = ' Do uzlu: ';
    allPathsControlDiv.appendChild(labelAllV);
    allPathsControlDiv.appendChild(selectAllV);
    allPathsControlDiv.appendChild(allPathsBtn);
    
    allPathsSection.appendChild(allPathsControlDiv);
    
    const allPathsResultDiv = document.createElement('div');
    allPathsResultDiv.className = 'scroll';
    allPathsResultDiv.style.display = 'none';
    allPathsSection.appendChild(allPathsResultDiv);
    
    allPathsBtn.addEventListener('click', () => {
        const u = selectAllU.value;
        const v = selectAllV.value;
        const paths = graph.allShortestPathsUnweighted(u, v);
        
        if (paths.length === 0) {
            allPathsResultDiv.textContent = 'Nenalezena žádná cesta.';
        } else {
            let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">Počet nejkratších cest: ${paths.length}</div>`;
            html += paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' → ')}`).join('<br/>');
            if (paths.length > 200) html += '<br/>… další nezobrazeny (limit 200)';
            allPathsResultDiv.innerHTML = html;
        }
        allPathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(allPathsSection);

    // Simple paths up to K
    const simplePathsSection = document.createElement('div');
    simplePathsSection.className = 'section';
    simplePathsSection.innerHTML = '<h2>Jednoduché cesty U→V do délky K</h2>';
    
    const simplePathsLegendDiv = document.createElement('div');
    simplePathsLegendDiv.style.backgroundColor = '#e7f3ff';
    simplePathsLegendDiv.style.padding = '0.75rem';
    simplePathsLegendDiv.style.borderRadius = '0.25rem';
    simplePathsLegendDiv.style.marginBottom = '1rem';
    simplePathsLegendDiv.style.border = '1px solid #0d6efd';
    simplePathsLegendDiv.innerHTML = `
        <strong>🎯 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• Jednoduchá cesta neprochází žádný uzel vícekrát</span><br>
        <span style="margin-left: 1rem;">• Hledá cesty s maximálně K hranami</span><br>
        <span style="margin-left: 1rem;">• Pokud K není zadáno, hledá do délky |V|-1</span><br>
        <span style="margin-left: 1rem;">• Limit 10,000 výsledků kvůli výkonu (zobrazí se max 200)</span>
    `;
    simplePathsSection.appendChild(simplePathsLegendDiv);
    
    const simplePathsControlDiv = document.createElement('div');
    simplePathsControlDiv.className = 'query-inputs';
    
    const selectSimpleU = document.createElement('select');
    const selectSimpleV = document.createElement('select');
    graph.nodes.forEach(node => {
        const opt1 = document.createElement('option');
        opt1.value = node;
        opt1.textContent = node;
        selectSimpleU.appendChild(opt1);
        
        const opt2 = document.createElement('option');
        opt2.value = node;
        opt2.textContent = node;
        selectSimpleV.appendChild(opt2);
    });
    
    const simpleKInput = document.createElement('input');
    simpleKInput.type = 'number';
    simpleKInput.min = '1';
    simpleKInput.placeholder = 'K (prázdné = |V|-1)';
    simpleKInput.style.width = '150px';
    simpleKInput.style.padding = '0.5rem';
    simpleKInput.style.border = '1px solid #ced4da';
    simpleKInput.style.borderRadius = '0.25rem';
    
    const simplePathsBtn = document.createElement('button');
    simplePathsBtn.textContent = 'Najít cesty';
    
    simplePathsControlDiv.innerHTML = '<span>Od uzlu: </span>';
    simplePathsControlDiv.appendChild(selectSimpleU);
    const labelSimpleV = document.createElement('span');
    labelSimpleV.textContent = ' Do uzlu: ';
    simplePathsControlDiv.appendChild(labelSimpleV);
    simplePathsControlDiv.appendChild(selectSimpleV);
    const labelSimpleK = document.createElement('span');
    labelSimpleK.textContent = ' Max délka K: ';
    simplePathsControlDiv.appendChild(labelSimpleK);
    simplePathsControlDiv.appendChild(simpleKInput);
    simplePathsControlDiv.appendChild(simplePathsBtn);
    
    simplePathsSection.appendChild(simplePathsControlDiv);
    
    const simplePathsResultDiv = document.createElement('div');
    simplePathsResultDiv.className = 'scroll';
    simplePathsResultDiv.style.display = 'none';
    simplePathsSection.appendChild(simplePathsResultDiv);
    
    simplePathsBtn.addEventListener('click', () => {
        const u = selectSimpleU.value;
        const v = selectSimpleV.value;
        const K = simpleKInput.value ? parseInt(simpleKInput.value, 10) : null;
        const result = graph.simplePathsUpTo(u, v, K, 10000);
        
        const more = (result.count > result.paths.length) ? ' (zastaveno na limitu 10,000)' : '';
        let html = `<div style="margin-bottom: 1rem; font-weight: bold; color: #0d6efd;">Počet: ${result.count}${more}</div>`;
        html += result.paths.slice(0, 200).map((p, i) => `${i + 1}) ${p.join(' → ')}`).join('<br/>');
        if (result.count > 200) html += '<br/>… další nezobrazeny (limit 200)';
        
        simplePathsResultDiv.innerHTML = html;
        simplePathsResultDiv.style.display = 'block';
    });
    
    output.appendChild(simplePathsSection);

    // Neighbor sets by direction
    const neighborSection = document.createElement('div');
    neighborSection.className = 'section';
    neighborSection.innerHTML = '<h2>Sousedé podle směru</h2>';
    
    const neighborLegendDiv = document.createElement('div');
    neighborLegendDiv.style.backgroundColor = '#e7f3ff';
    neighborLegendDiv.style.padding = '0.75rem';
    neighborLegendDiv.style.borderRadius = '0.25rem';
    neighborLegendDiv.style.marginBottom = '1rem';
    neighborLegendDiv.style.border = '1px solid #0d6efd';
    neighborLegendDiv.innerHTML = `
        <strong>👥 Vysvětlení:</strong><br>
        <span style="margin-left: 1rem;">• <strong>OUT (odchozí):</strong> uzly, do kterých vede hrana z daného uzlu</span><br>
        <span style="margin-left: 1rem;">• <strong>IN (příchozí):</strong> uzly, ze kterých vede hrana do daného uzlu</span><br>
        <span style="margin-left: 1rem;">• <strong>Neorientovaní:</strong> uzly spojené neorientovanou hranou</span>
    `;
    neighborSection.appendChild(neighborLegendDiv);
    
    const neighborControlDiv = document.createElement('div');
    neighborControlDiv.style.marginBottom = '1rem';
    neighborControlDiv.innerHTML = '<label>Uzel: <select id="neighborSelect"></select></label> <button id="neighborBtn" style="margin-left: 0.5rem;">Zobrazit sousedy</button>';
    neighborSection.appendChild(neighborControlDiv);
    
    const neighborSelect = document.createElement('select');
    neighborSelect.id = 'neighborSelectActual';
    graph.nodes.forEach(node => {
        const opt = document.createElement('option');
        opt.value = node;
        opt.textContent = node;
        neighborSelect.appendChild(opt);
    });
    neighborControlDiv.querySelector('label').appendChild(neighborSelect);
    
    const neighborResultDiv = document.createElement('div');
    neighborResultDiv.className = 'scroll';
    neighborResultDiv.style.display = 'none';
    neighborSection.appendChild(neighborResultDiv);
    
    neighborControlDiv.querySelector('#neighborBtn').addEventListener('click', () => {
        const node = neighborSelect.value;
        const neighbors = graph.neighborSets(node);
        let html = '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
        html += `<div style="padding: 0.5rem; background-color: #d1ecf1; border-radius: 0.25rem;"><strong>OUT (odchozí):</strong> ${neighbors.out.join(', ') || '∅'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #d4edda; border-radius: 0.25rem;"><strong>IN (příchozí):</strong> ${neighbors.inn.join(', ') || '∅'}</div>`;
        html += `<div style="padding: 0.5rem; background-color: #fff3cd; border-radius: 0.25rem;"><strong>Neorientovaní:</strong> ${neighbors.und.join(', ') || '∅'}</div>`;
        html += '</div>';
        neighborResultDiv.innerHTML = html;
        neighborResultDiv.style.display = 'block';
    });
    
    output.appendChild(neighborSection);

    // Length matrix with query
    const lenSection = document.createElement('div');
    lenSection.className = 'section';
    lenSection.innerHTML = '<h2>Matice délek</h2>';
    lenSection.appendChild(createQuerySection('Dotaz na hodnotu', 'length'));
    
    const showLenBtn = document.createElement('button');
    showLenBtn.textContent = 'Zobrazit celou matici';
    const lenMatrixDiv = document.createElement('div');
    lenMatrixDiv.className = 'matrix';
    lenMatrixDiv.style.display = 'none';
    showLenBtn.addEventListener('click', () => {
        if (lenMatrixDiv.style.display === 'none') {
            const lenMat = graph.lengthMatrix();
            lenMatrixDiv.innerHTML = '';
            lenMatrixDiv.appendChild(createMatrixTable(lenMat, graph.nodes, graph.nodes));
            lenMatrixDiv.style.display = 'block';
            showLenBtn.textContent = 'Skrýt matici';
        } else {
            lenMatrixDiv.style.display = 'none';
            showLenBtn.textContent = 'Zobrazit celou matici';
        }
    });
    lenSection.appendChild(showLenBtn);
    lenSection.appendChild(lenMatrixDiv);
    output.appendChild(lenSection);

    // Shortest path query
    const shortestSection = document.createElement('div');
    shortestSection.className = 'section';
    shortestSection.innerHTML = '<h2>Nejkratší cesty (Floyd-Warshall)</h2>';
    shortestSection.appendChild(createQuerySection('Dotaz na nejkratší cestu', 'shortest'));
    
    const showPredBtn = document.createElement('button');
    showPredBtn.textContent = 'Vypočítat celou matici předchůdců';
    const predMatrixDiv = document.createElement('div');
    predMatrixDiv.className = 'matrix';
    predMatrixDiv.style.display = 'none';
    showPredBtn.addEventListener('click', () => {
        if (predMatrixDiv.style.display === 'none') {
            showPredBtn.disabled = true;
            showPredBtn.textContent = 'Počítám...';
            setTimeout(() => {
                const fw = graph.floydWarshall();
                const pred = fw.pred.map(row => row.map(p => p === null ? '–' : graph.nodes[p]));
                predMatrixDiv.innerHTML = '';
                predMatrixDiv.appendChild(createMatrixTable(pred, graph.nodes, graph.nodes));
                predMatrixDiv.style.display = 'block';
                showPredBtn.textContent = 'Skrýt matici';
                showPredBtn.disabled = false;
            }, 50);
        } else {
            predMatrixDiv.style.display = 'none';
            showPredBtn.textContent = 'Zobrazit celou matici';
        }
    });
    shortestSection.appendChild(showPredBtn);
    shortestSection.appendChild(predMatrixDiv);
    output.appendChild(shortestSection);

    // Incident edges
    const incident = graph.incidentEdges();
    const incEdgeSection = document.createElement('div');
    incEdgeSection.className = 'section';
    incEdgeSection.innerHTML = '<h2>Tabulka incidentních hran</h2>';
    const incEdgeDiv = document.createElement('div');
    incEdgeDiv.className = 'matrix';
    incEdgeDiv.appendChild(createListTable(incident));
    incEdgeSection.appendChild(incEdgeDiv);
    output.appendChild(incEdgeSection);

    // Neighbours
    const neighbours = graph.neighbours();
    const neighSection = document.createElement('div');
    neighSection.className = 'section';
    neighSection.innerHTML = '<h2>Seznam sousedů</h2>';
    const neighDiv = document.createElement('div');
    neighDiv.className = 'matrix';
    neighDiv.appendChild(createListTable(neighbours));
    neighSection.appendChild(neighDiv);
    output.appendChild(neighSection);

    // Multiple edges detection and listing
    const multipleEdges = graph.findMultipleEdges();
    const multiEdgeSection = document.createElement('div');
    multiEdgeSection.className = 'section';
    multiEdgeSection.innerHTML = '<h2>Víceásobné hrany</h2>';
    
    if (multipleEdges.length === 0) {
        const noMultiMsg = document.createElement('p');
        noMultiMsg.textContent = 'Graf neobsahuje žádné víceásobné hrany.';
        noMultiMsg.style.color = '#28a745';
        noMultiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(noMultiMsg);
    } else {
        const multiMsg = document.createElement('p');
        multiMsg.textContent = `Nalezeno ${multipleEdges.length} skupin víceásobných hran:`;
        multiMsg.style.color = '#dc3545';
        multiMsg.style.fontWeight = 'bold';
        multiEdgeSection.appendChild(multiMsg);
        
        const multiEdgeDiv = document.createElement('div');
        multiEdgeDiv.className = 'scrollable-list';
        const multiList = document.createElement('ul');
        multiList.style.listStyle = 'none';
        multiList.style.padding = '0';
        
        for (const group of multipleEdges) {
            const li = document.createElement('li');
            li.style.marginBottom = '1rem';
            li.style.padding = '0.5rem';
            li.style.backgroundColor = '#fff3cd';
            li.style.border = '1px solid #ffc107';
            li.style.borderRadius = '0.25rem';
            
            const title = document.createElement('strong');
            title.textContent = `${group.key} (${group.count}× násobná hrana)`;
            li.appendChild(title);
            
            const edgeList = document.createElement('ul');
            edgeList.style.marginTop = '0.5rem';
            edgeList.style.marginLeft = '1rem';
            
            for (const e of group.edges) {
                const edgeLi = document.createElement('li');
                const weight = e.weight !== null && e.weight !== undefined ? e.weight : 1;
                const label = e.label ? ` [${e.label}]` : '';
                let orientation;
                if (e.direction === '>') orientation = '→';
                else if (e.direction === '<') orientation = '←';
                else orientation = '—';
                edgeLi.textContent = `${e.u} ${orientation} ${e.v} (h=${weight})${label}`;
                edgeList.appendChild(edgeLi);
            }
            
            li.appendChild(edgeList);
            multiList.appendChild(li);
        }
        
        multiEdgeDiv.appendChild(multiList);
        multiEdgeSection.appendChild(multiEdgeDiv);
    }
    
    output.appendChild(multiEdgeSection);

    // Properties
    const props = graph.properties();
    const propSection = document.createElement('div');
    propSection.className = 'section';
    propSection.innerHTML = '<h2>Vlastnosti grafu</h2>';
    const propDiv = document.createElement('div');
    propDiv.className = 'properties';
    const addProp = (name, value) => {
        const span = document.createElement('span');
        span.textContent = `${name}: ${value}`;
        propDiv.appendChild(span);
    };
    addProp('Ohodnocený', props.weighted ? 'ano' : 'ne');
    addProp('Orientace', props.oriented);
    addProp('Souvislý', props.connected ? 'ano' : 'ne');
    
    // Add strong/weak connectivity for directed graphs
    if (props.oriented === 'orientovaný') {
        addProp('Silně souvislý', props.stronglyConnected ? 'ano' : 'ne');
        addProp('Slabě souvislý', props.weaklyConnected ? 'ano' : 'ne');
    }
    
    addProp('Prostý', props.prosty ? 'ano' : 'ne');
    addProp('Jednoduchý', props.jednoduchy ? 'ano' : 'ne');
    addProp('Konečný', props.finite ? 'ano' : 'ne');
    addProp('Úplný', props.complete ? 'ano' : 'ne');
    addProp('Regulární', props.regular ? 'ano' : 'ne');
    addProp('Bipartitní', props.bipartite ? 'ano' : 'ne');
    addProp('Rovinný', typeof props.planar === 'string' ? props.planar : (props.planar ? 'ano' : 'ne'));
    propSection.appendChild(propDiv);
    output.appendChild(propSection);
});
</script>
</body>
</html>